<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta property="og:title" content="【译】理解PHP内部函数的定义（给PHP开发者的PHP源码-第二部分）" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://hoohack.me/blog/2016/2016-02-10-understanding-phps-internal-function-definitions-ch/" />
  <link rel="stylesheet" href="/styles/main.css">
  <link rel="me" href="https://mas.to/@djyde">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/themes/prism.min.css">
  
  <title>【译】理解PHP内部函数的定义（给PHP开发者的PHP源码-第二部分） | Hoohack&#39;s Blog</title>
  
  <script async src="https://analytics.umami.is/script.js" data-website-id="4869a1e9-28c6-4ba7-9a31-d65c087f2583"></script>
</head>
<body>
  
<div>
  <div class="container mx-auto prose py-12 sm:py-24 px-12 sm:px-0">
    <div class="mb-12">
      <a class="no-underline font-bold" href="/">Hoohack&#39;s Blog</a>
    </div>
    <h1>【译】理解PHP内部函数的定义（给PHP开发者的PHP源码-第二部分）</h1>
    <div class="italic text-gray-500">
      2016/02/10
    </div>
    <div>
      <p>原文：<a href="https://nikic.github.io/2012/03/16/Understanding-PHPs-internal-function-definitions.html">https://nikic.github.io/2012/03/16/Understanding-PHPs-internal-function-definitions.html</a></p>
<p>欢迎来到&quot;给PHP开发者的PHP源码&quot;系列的第二部分。</p>
<p>在上一篇中，ircmaxell说明了你可以在哪里找到PHP的源码，它的基本目录结构以及简单地介绍了一些C语言（因为PHP是用C语言来写的）。如果你错过了那篇文章，在你开始读这篇文章之前也许你应该读一下它。</p>
<p>在这篇文章中，我们谈论的是定位PHP内部函数的定义，以及理解它们的原理。</p>
<h2 id="%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89" tabindex="-1">如何找到函数的定义</h2>
<p>作为开始，让我们尝试找出strpos函数的定义。</p>
<p>尝试的第一步，就是去PHP 5.4根目录然后在页面顶部的搜索框输入strpos。搜索的结果是一个很大的列表，展示了<code>strpos</code>在PHP源码中出现的位置。</p>
<p>因为这个结果对我们并没有太大的帮助，我们使用一个小技巧：我们搜索&quot;PHP_FUNCTION strpos&quot;（不要漏了双引号，它们很重要），而不是<code>strpos</code>.</p>
<p>现在我们得到两个入口链接：</p>
<p>/PHP_5_4/ext/standard/
php_string.h 48   PHP_FUNCTION(strpos);
string.c     1789 PHP_FUNCTION(strpos)</p>
<p>第一个要注意的事情是，两个位置都是在<code>ext/standard</code>文件夹。这就是我们希望找到的，因为strpos函数（跟大部分string，array和文件函数一样）是standard扩展的一部分。</p>
<p>现在，在新标签页打开两个链接，然后看看它们背后藏了什么代码。</p>
<p>你会看到第一个链接带你到了php_string.h文件，它包含了下面的代码：</p>
<p>// ...
PHP_FUNCTION(strpos);
PHP_FUNCTION(stripos);
PHP_FUNCTION(strrpos);
PHP_FUNCTION(strripos);
PHP_FUNCTION(strrchr);
PHP_FUNCTION(substr);
// ...</p>
<p>这就是一个典型的头文件（以.h后缀结尾的文件）的样子：单纯的函数列表，函数在其他地方定义。事实上，我们对这些并不感兴趣，因为我们已经知道我们要找的是什么。</p>
<p>第二个链接更有趣：它带我们到<code>string.c</code>文件，这个文件包含了函数真正的源代码。</p>
<p>在我带你一步一步地查阅这个函数之前，我推荐你自己尝试理解这个函数。这是一个很简单的函数，尽管你不知道真正的细节，但大多数代码看起来都很清晰。</p>
<h2 id="php%E5%87%BD%E6%95%B0%E7%9A%84%E9%AA%A8%E6%9E%B6" tabindex="-1">PHP函数的骨架</h2>
<p>所有的PHP函数都使用同一个基本结构。在函数顶部定义了各个变量，然后调用<code>zend_parse_parameters</code>函数，然后到了主要的逻辑，当中有<code>RETURN_***</code>和<code>php_error_docref</code>的调用。</p>
<p>那么，让我们以函数的定义来开始：</p>
<p>zval *needle;
char *haystack;
char *found = NULL;
char  needle_char[2];
long  offset = 0;
int   haystack_len;</p>
<p>第一行定义了一个指向<code>zval</code>的指针<code>needle</code>。zval是在PHP内部代表任意一个PHP变量的定义。它真正是怎么样的会在下一篇文章重点谈论。</p>
<p>第二行定义了指向单个字符的指针<code>haystack</code>。这时候，你需要记住，在C语言里面，数组代表指向它们第一个元素的指针。比如说，<code>haystack</code>变量会指向你所传递的<code>$haystack</code>字符串变量的第一个字符。<code>haystack + 1</code>会指向第二个字符，<code>haystack + 2</code>指向第三个，以此类推。因此，通过逐个递增指针，可以读取整个字符串。</p>
<p>那么问题来了，PHP需要知道字符串在哪里结束。不然的话，它会一直递增指针而不会停止。为了解决这个问题，PHP也保存了明确的长度，这就是<code>haystack_len</code>变量。</p>
<p>现在，在上面的定义中，我们感兴趣的是offset变量，这个变量用来保存函数的第三个参数：开始搜索的偏移量。它使用long来定义，跟int一样，也是整型数据类型。现在这两者的差异并不重要，但你需要知道的是在PHP中，整型值使用long来存储，字符串的长度使用int来存储。</p>
<p>现在来看看下面的三行：</p>
<p>if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;sz|l&quot;, &amp;haystack, &amp;haystack_len, &amp;needle, &amp;offset) == FAILURE) {
return;
}</p>
<p>这三行代码做的事情就是，获取传递到函数的参数，然后把它们存储到上面声明的变量中。</p>
<p>传递给函数的第一个参数是传递参数的数量。这个数字通过<code>ZEND_NUM_ARGS()</code>宏提供。</p>
<p>下一个函数是<code>TSRMLS_CC</code>宏，这是PHP的一种特性。你会发现这个奇怪的宏分散在PHP代码库的很多地方。是线程安全资源管理器（TSRM）的一部分，它保证PHP不会在多线程之间混乱变量。这对我们来说不是很重要，当你在代码中看到<code>TSRMLS_CC</code>（或者<code>TSRMLS_DC</code>）的时候，忽略它就行。（有一个奇怪的地方你需要注意的是，在&quot;argument&quot;之前没有逗号。这是因为不管你是否使用线程安全创建函数，该宏会被解释为空或者, trsm_ls。因此，逗号是宏的一部分。）</p>
<p>现在，我们来到重要的东西：&quot;sz|l&quot;字符串标记了函数接收的参数。：</p>
<p>s  // 第一个参数是字符串
z  // 第二个参数是一个zval结构体，任意的变量
|  // 标识接下来的参数是可选的
l  // 第三个参数是long类型（整型）</p>
<p>除了s，z，l之外，还有更多的标识类型，但是大部分都能从字符中清楚其意思。例如b是boolean，d是double（浮点型数字），a是array，f是回调（function），o是object。</p>
<p>接下来的参数<code>&amp;haystack</code>，<code>&amp;haystack_len</code>，<code>&amp;needle</code>，<code>&amp;offset</code>指定了需要赋值的参数的变量。你可以看到，它们都是使用引用（&amp;）传递的，意味着它们传递的不是变量本身，而是指向它们的指针。</p>
<p>这个函数调用之后，<code>haystack</code>会包含haystack字符串，<code>haystack_len</code>是字符串的长度，needle是needle的值，offset是开始的偏移量。</p>
<p>而且，这个函数使用FAILURE（当你尝试传递无效参数到函数时会发生，比如传递一个数组赋值到字符串）来检查。这种情况下<code>zend_parse_parameters</code>函数会抛出警告，而此函数马上返回（会返回null给PHP的用户层代码）。</p>
<p>在参数解析完毕以后，主函数体开始：</p>
<p>if (offset &lt; 0 || offset &gt; haystack_len) {
php_error_docref(NULL TSRMLS_CC, E_WARNING, &quot;Offset not contained in string&quot;);
RETURN_FALSE;
}</p>
<p>这段代码做的事情很明显，如果offset超出了边界，一个E_WARNING级别的错误会通过php_error_docref函数抛出，然后函数使用RETURN_FALSE宏返回false。</p>
<p><code>php_error_docref</code>是一个错误函数，你可以在扩展目录找到它（比如，ext文件夹）。它的名字根据它在错误页面中返回文档参考（就是那些不会正常工作的函数）定义。还有一个<code>zend_error</code>函数，它主要被Zend Engine使用，但也经常出现在扩展代码中。</p>
<p>两个函数都使用sprintf函数，比如格式化信息，因此错误信息可以包含占位符，那些占位符会被后面的参数填充。下面有一个例子：</p>
<p>php_error_docref(NULL TSRMLS_CC, E_WARNING, &quot;Failed to write %d bytes to %s&quot;, Z_STRLEN_PP(tmp), filename);
// %d is filled with Z_STRLEN_PP(tmp)
// %s is filled with filename</p>
<p>让我们继续解析代码：</p>
<p>if (Z_TYPE_P(needle) == IS_STRING) {
if (!Z_STRLEN_P(needle)) {
php_error_docref(NULL TSRMLS_CC, E_WARNING, &quot;Empty delimiter&quot;);
RETURN_FALSE;
}</p>
<p>found = php_memnstr(haystack + offset,
Z_STRVAL_P(needle),
Z_STRLEN_P(needle),
haystack + haystack_len);
}</p>
<p>前面的5行非常清晰：这个分支只会在needle为字符串的情况下执行，而且如果它是空的话会抛出错误。然后到了比较有趣的一部分：<code>php_memnstr</code>被调用了，这个函数做了主要的工作。跟往常一样，你可以点击该函数名然后查看它的源码。</p>
<p><code>php_memnstr</code>返回指向needle在haystack第一次出现的位置的指针（这就是为什么found变量要定义为char *，例如，指向字符的指针）。从这里可以知道，偏移量（offset）可以通过减法被简单地计算，可以在函数的最后看到：</p>
<p>RETURN_LONG(found - haystack);</p>
<p>最后，让我们来看看当needle作为非字符串的时候的分支：</p>
<p>else {
if (php_needle_char(needle, needle_char TSRMLS_CC) != SUCCESS) {
RETURN_FALSE;
}
needle_char[1] = 0;</p>
<p>found = php_memnstr(haystack + offset,
needle_char,
1,
haystack + haystack_len);
}</p>
<p>我只引用在手册上写的&quot;如果 needle 不是一个字符串，那么它将被转换为整型并被视为字符顺序值。&quot;这基本上说明，除了写<code>strpos($str, 'A')</code>，你还可以写<code>strpos($str, 65)</code>，因为A字符的编码是65。</p>
<p>如果你再查看变量定义，你可以看到<code>needle_char</code>被定义为<code>char needle_char[2]</code>，即有两个字符的字符串，<code>php_needle_char</code>会将真正的字符（在这里是'A'）到needle_char[0]。然后strpos函数会设置needle_char[1]为0。这背后的原因是因为，在C里面，字符串是使用'\0'结尾，就是说，最后一个字符被设置为NUL（编码为0的字符）。在PHP的语法环境里，这样的情况不存在，因为PHP存储了所有字符串的长度（因此它不需要0来帮助找到字符串的结尾），但是为了保证与C函数的兼容性，还是在PHP的内部实现了。</p>
<h2 id="zend-functions" tabindex="-1">Zend functions</h2>
<p>我对strpos这个函数感觉好累，让我们找另一个函数吧：strlen。我们使用之前的方法：</p>
<p>从PHP5.4源码根目录开始搜索strlen。</p>
<p>你会看到一堆无关的函数的使用，因此，搜索“PHP_FUNCTION strlen”。当你这么搜索的时候，你会发现一些奇怪的事情发生了：没有任何的结果。</p>
<p>原因是，strlen是少数通过Zend Engine而不是PHP扩展定义的函数。这种情况下，函数不是使用<code>PHP_FUNCTION(strlen)</code>定义，而是<code>ZEND_FUNCTION(strlen)</code>。因此，我们也要搜索“ZEND_FUNCTION strlen”。</p>
<p>我们都知道，我们需要点击没有分号结尾的链接跳到源码的定义。这个链接带我们到下面的函数定义：</p>
<p>ZEND_FUNCTION(strlen)
{
char *s1;
int s1_len;</p>
<p>if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;s&quot;, &amp;s1, &amp;s1_len) == FAILURE) {
return;
}</p>
<p>RETVAL_LONG(s1_len);
}</p>
<p>这个函数实现太简单了，我不觉得我还需要进一步的解释。</p>
<h2 id="%E6%96%B9%E6%B3%95" tabindex="-1">方法</h2>
<p>我们会谈论类和对象如何工作的更多细节在其他文章里，但作为一个小小的剧透：你可以通过在搜索框搜索<code>ClassName::methodName</code>来搜索对象方法。例如，尝试搜索<code>SplFixedArray::getSize</code>。</p>
<h2 id="%E4%B8%8B%E4%B8%80%E9%83%A8%E5%88%86" tabindex="-1">下一部分</h2>
<p>下一部分会再次发表在。会谈论到zval是什么，它们是怎么工作的，以及它们是怎么在源码中被使用的（所有的Z_***宏）。</p>

    </div>
    <hr />
      <div class="text-sm text-center">
        评论和交流请发送邮件到 hoohackhu@gmail.com
      </div>
      <hr />
    <div class="text-center">
<img class="w-64 inline-block" src="https://www.hoohack.me/assets/images/reward.jpeg" alt="" />
<div class="text-sm">
通过赞赏码赞助此文
</div>
</div>
    <footer class="text-sm py-12 text-gray-500 text-center">
  Hoohack's Blog since 2014
</footer>
  </div>

</div>



</body>
</html>