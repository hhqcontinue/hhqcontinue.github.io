<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta property="og:title" content="[PHP源码阅读]empty和isset函数" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://hoohack.me/blog/2016/2016-05-26-php-source-code-empty-isset/" />
  <link rel="stylesheet" href="/styles/main.css">
  <link rel="me" href="https://mas.to/@djyde">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/themes/prism.min.css">
  
  <title>[PHP源码阅读]empty和isset函数 | Hoohack&#39;s Blog</title>
  
  <script async src="https://ana.hoohack.me/ana.js" data-website-id="380499a9-5e2b-4320-bb7d-fc6bb57fdf79"></script>
</head>
<body>
  
<div>
  <div class="container mx-auto prose py-12 sm:py-24 px-12 sm:px-0">
    <div class="mb-12">
      <a class="no-underline font-bold" href="/">Hoohack&#39;s Blog</a>
    </div>
    <h1>[PHP源码阅读]empty和isset函数</h1>
    <div class="italic text-gray-500">
      2016/05/26
    </div>
    <div>
      <p>近日被问到PHP中empty和isset函数时怎么判断变量的，刚开始我是一脸懵逼的，因为我自己也只是一知半解，为了弄懂其真正的原理，赶紧翻开源码研究研究。经过分析可发现两个函数调用的都是同一个函数，因此本文将对两个函数一起分析。</p>
<p>我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。<a href="https://github.com/read-php-src/read-php-src">PHP5.4源码注解</a>。可以通过<a href="https://github.com/read-php-src/read-php-src/commits/master">commit记录</a>查看已添加的注解。</p>
<h2 id="%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%A0%BC%E5%BC%8F" tabindex="-1">函数使用格式</h2>
<h3 id="empty" tabindex="-1">empty</h3>
<p>bool empty ( mixed $var )</p>
<p>判断变量是否为空。</p>
<h3 id="isset" tabindex="-1">isset</h3>
<p>bool isset ( mixed $var [ , mixed $... ] )</p>
<p>判断变量是否被设置且不为NULL。</p>
<h2 id="%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E" tabindex="-1">参数说明</h2>
<p>对于empty，在PHP5.5版本以前，empty只支持变量参数，其他类型的参数会导致解析错误，比如函数调用的结果不能作为参数。</p>
<p>对于isset，如果变量被如unset的函数设为NULL，则函数会返回false。如果多个参数被传递到isset函数，那么只有所有参数都被设置isset函数才会返回true。从左到右计算，一旦遇到没被设置的变量就停止。</p>
<p>运行示例</p>
<p>$result = empty(0); // true
$result = empty(null); // true
$result = empty(false); // true
$result = empty(array()); // true
$result = empty('0'); // true
$result = empty(1); // false
$result = empty(callback function); // 报错</p>
<p>$a = null;
$result = isset($a); // false;</p>
<p>$a = 1;
$result = isset($a); // true;</p>
<p>$a = 1;$b = 2;$c = 3;
$result = isset($a, $b, $c); // true</p>
<p>$a = 1;$b = null;$c = 3;
$result = isset($a, $b, $c); // false</p>
<p>找到函数的定义位置</p>
<p>实际上，empty不是一个函数，而是一个语言结构。语言结构是在PHP程序运行前编译好的，因此不能像之前那样简单地搜索<strong>PHP_FUNCTION empty</strong>或<strong>ZEND_FUNCTION empty</strong>查看其源码。要想看empty等语言结构的源码，先要理解PHP代码执行的机制。</p>
<p>PHP执行代码会经过4个步骤，其流程图如下所示：</p>
<p><img src="http://7u2eqw.com1.z0.glb.clouddn.com/PHP%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4.png" alt="PHP执行步骤"></p>
<p>在第一个阶段，即Scanning阶段，程序会扫描<strong>zend_language_scanner.l</strong>文件将代码文件转换成语言片段。对于isset和empty函数来说，在<strong>zend_language_scanner.l</strong>文件中搜索empty和isset可以得到函数在此文件中的宏定义如下：</p>
<p>&lt;ST_IN_SCRIPTING&gt;&quot;isset&quot; {
return T_ISSET;
}</p>
<p>&lt;ST_IN_SCRIPTING&gt;&quot;empty&quot; {
return T_EMPTY;
}</p>
<p>接下来就到了Parsing阶段，这个阶段，程序将T_ISSET和T_EMPTY等Tokens转换成有意义的表达式，此时会做语法分析，Tokens的yacc保存在zend_language_parser.y文件中，可以找到T_ISSET和T_EMPTY的定义：</p>
<p>internal_functions_in_yacc:
T_ISSET '(' isset_variables ')' { $$ = $3; }
| T_EMPTY '(' variable ')' { zend_do_isset_or_isempty(ZEND_ISEMPTY, &amp;$$, &amp;$3 TSRMLS_CC); }
| T_INCLUDE expr { zend_do_include_or_eval(ZEND_INCLUDE, &amp;$$, &amp;$2 TSRMLS_CC); }
| T_INCLUDE_ONCE expr { zend_do_include_or_eval(ZEND_INCLUDE_ONCE, &amp;$$, &amp;$2 TSRMLS_CC); }
| T_EVAL '(' expr ')' { zend_do_include_or_eval(ZEND_EVAL, &amp;$$, &amp;$3 TSRMLS_CC); }
| T_REQUIRE expr { zend_do_include_or_eval(ZEND_REQUIRE, &amp;$$, &amp;$2 TSRMLS_CC); }
| T_REQUIRE_ONCE expr { zend_do_include_or_eval(ZEND_REQUIRE_ONCE, &amp;$$, &amp;$2 TSRMLS_CC); }
;</p>
<p>isset和empty函数最终都执行了<strong>zend_do_isset_or_isempty</strong>函数，在源码目录中查找</p>
<p>grep -rn &quot;zend_do_isset_or_isempty&quot;</p>
<p>可以发现，此函数在zend_compile.c文件中定义。</p>
<p>函数执行步骤</p>
<blockquote>
<p>1、解析参数</p>
<p>2、检查是否为可写变量</p>
<p>3、如果是变量的op_type是IS_CV（编译时期的变量），则设置其opcode为ZEND_ISSET_ISEMPTY_VAR；否则从active_op_array中获取下一个op值，根据其op值设置last_op的opcode。</p>
<p>4、设置了opcode之后，之后会交给zend_excute执行。</p>
</blockquote>
<h2 id="%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB" tabindex="-1">源码解读</h2>
<p>IS_CV是编译器使用的一种cache机制，这种变量保存着它被引用的变量的地址，当一个变量第一次被引用的时候，就会被CV起来，以后这个变量的引用就不需要再去查找active符号表了。</p>
<p>对于empty函数，到了opcode的步骤后，参阅opcode处理函数，可以知道，isset和empty在excute的时候执行的是<strong>ZEND_ISSET_ISEMPTY_VAR</strong>等一系列函数，以<strong>ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_VAR_HANDLER</strong>为例，找到这个函数的定义在<strong>zend_vm_execute.h</strong>。查看函数可以知道，empty函数的最终执行函数是<strong>i_zend_is_true()</strong>，而i_zend_is_true函数定义在<strong>zend_execute.h</strong>。i_zend_is_true函数的核心代码如下：</p>
<p>switch (Z_TYPE_P(op)) {
case IS_NULL:
result = 0;
break;
case IS_LONG:
case IS_BOOL:
case IS_RESOURCE:
// empty参数为整数时非0的话就为false
result = (Z_LVAL_P(op)?1:0);
break;
case IS_DOUBLE:
result = (Z_DVAL_P(op) ? 1 : 0);
break;
case IS_STRING:
if (Z_STRLEN_P(op) == 0
|| (Z_STRLEN_P(op)==1 &amp;&amp; Z_STRVAL_P(op)[0]=='0')) {
// empty(&quot;0&quot;) == true
result = 0;
} else {
result = 1;
}
break;
case IS_ARRAY:
// empty(array) 是根据数组的数量来判断
result = (zend_hash_num_elements(Z_ARRVAL_P(op))?1:0);
break;
case IS_OBJECT:
if(IS_ZEND_STD_OBJECT(*op)) {
TSRMLS_FETCH();</p>
<p>if (Z_OBJ_HT_P(op)-&gt;cast_object) {
zval tmp;
if (Z_OBJ_HT_P(op)-&gt;cast_object(op, &amp;tmp, IS_BOOL TSRMLS_CC) == SUCCESS) {
result = Z_LVAL(tmp);
break;
}
} else if (Z_OBJ_HT_P(op)-&gt;get) {
zval <em>tmp = Z_OBJ_HT_P(op)-&gt;get(op TSRMLS_CC);
if(Z_TYPE_P(tmp) != IS_OBJECT) {
/</em> for safety - avoid loop */
convert_to_boolean(tmp);
result = Z_LVAL_P(tmp);
zval_ptr_dtor(&amp;tmp);
break;
}
}
}
result = 1;
break;
default:
result = 0;
break;
}</p>
<p>这段代码比较直观，函数没有对检测值做任何的转换，通过这段代码来进一步分析示例中的empty函数做分析：
empty(null)，到IS_NULL分支，result=0，i_zend_is_true() == 0，!i_zend_is_true() == 1，因此返回true。</p>
<p>empty(false)，到IS_BOOL分支，result = ZLVAL_P(false) = 0，i_zend_is_true() == 0，!i_zend_is_true() == 1，因此返回true。</p>
<p>empty(array())，到IS_ARRAY分支，result = zend_hash_num_elements(Z_ARRVAL_P(op)) ? 1 : 0)，zend_hash_num_elements返回数组元素的数量，array为空，因此result为0，i_zend_is_true() == 0，!i_zend_is_true() == 1，因此返回true。</p>
<p>empty('0')，到IS_STRING分支，因为Z_STRLENP(op) == 1 且 Z_STRVAL_P(op)[0] == '0'，因此result为0，i_zend_is_true() == 0，!i_zend_is_true() == 1，因此返回true。</p>
<p>empty(1)，到IS_LONG分支，result = Z_LVAL_P(op) = 1，i_zend_is_true == 1，!i_zend_is_true() == 0，因此返回false。</p>
<p>对于isset函数，最终实现判断的代码是：</p>
<p>if (isset &amp;&amp; Z_TYPE_PP(value) != IS_NULL) {
ZVAL_BOOL(&amp;EX_T(opline-&gt;result.var).tmp_var, 1);
} else {
ZVAL_BOOL(&amp;EX_T(opline-&gt;result.var).tmp_var, 0);
}</p>
<p>只要value被设置了且不为NULL，isset函数就返回true。</p>
<h2 id="%E5%B0%8F%E7%BB%93" tabindex="-1">小结</h2>
<p>这次阅读这两个函数的源码，学习到了：</p>
<p>1、PHP代码在编译期间的执行步骤</p>
<p>2、如何查找PHP语言结构的源码位置</p>
<p>3、如何查找opcode处理函数的具体函数</p>
<p>学无止境，每个人都有自己的短板，只有通过不断学习才能将自己的短板补上。</p>
<p>原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。</p>
<p>如果本文对你有帮助，请点下推荐吧，谢谢^_^</p>
<p>我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。<a href="https://github.com/read-php-src/read-php-src">PHP5.4源码注解</a>。可以通过<a href="https://github.com/read-php-src/read-php-src/commits/master">commit记录</a>查看已添加的注解。</p>
<p>参考文章</p>
<p>opcode处理函数查找：<a href="http://www.laruence.com/2008/06/18/221.html">http://www.laruence.com/2008/06/18/221.html</a></p>
<p>PHPopcode深入理解及PHP代码执行步骤：<a href="http://www.php-internals.com/book/?p=chapt02/02-03-03-from-opcode-to-handler">http://www.php-internals.com/book/?p=chapt02/02-03-03-from-opcode-to-handler</a></p>
<p>更多源码文章，欢迎访问个人主页继续查看：<a href="https://www.hoohack.me">hoohack</a></p>

    </div>
    <hr />
      <div class="text-sm text-center">
        评论和交流请发送邮件到 hoohackhu@gmail.com
      </div>
      <hr />
    <div class="text-center">
<img class="w-64 inline-block" src="https://www.hoohack.me/assets/images/reward.jpeg" alt="" />
<div class="text-sm">
通过赞赏码赞助此文
</div>
</div>
    <footer class="text-sm py-12 text-gray-500 text-center">
  Hoohack's Blog since 2014
</footer>
  </div>

</div>



</body>
</html>