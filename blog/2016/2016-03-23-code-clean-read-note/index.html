<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta property="og:title" content="【读书笔记】代码整洁之道" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://hoohack.me/blog/2016/2016-03-23-code-clean-read-note/" />
  <link rel="stylesheet" href="/styles/main.css">
  <link rel="me" href="https://mas.to/@djyde">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/themes/prism.min.css">
  
  <title>【读书笔记】代码整洁之道 | Hoohack&#39;s Blog</title>
  
</head>
<body>
  
<div>
  <div class="container mx-auto prose py-12 sm:py-24 px-12 sm:px-0">
    <div class="mb-12">
      <a class="no-underline font-bold" href="/">Hoohack&#39;s Blog</a>
    </div>
    <h1>【读书笔记】代码整洁之道</h1>
    <div class="italic text-gray-500">
      2016/03/23
    </div>
    <div>
      <h2 id="%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B4%E6%B4%81%E4%BB%A3%E7%A0%81" tabindex="-1">第一章 整洁代码</h2>
<p>赶上期限的唯一方法：始终尽可能保持代码整洁。</p>
<p>整洁的代码只做好一件事。</p>
<p>整本书的主旨，不要重复代码，只做一件事，表达力，小规模抽象。</p>
<p>要想干得快，要想快点做完，要想轻松写代码，先让代码易读吧。</p>
<p>让每次签入时，代码都比签出时干净。</p>
<h2 id="%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%8C%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84%E5%91%BD%E5%90%8D" tabindex="-1">第二章，有意义的命名</h2>
<p>1、名副其实</p>
<p>如果名称需要注释来补充，那就不算是名副其实。</p>
<p>2、避免误导</p>
<p>别用xxxList来指称一组账号，除非它真的是List类型。（用xxxGroup/bunchOfxxx/xxxs代替更好）</p>
<p>3、做有意义的区分</p>
<p>不要使用数字区分变量/函数命名。如a1,a2,...</p>
<p>不要添加废话区分命名。如：ProductInfo和ProductData</p>
<p>4、使用读得出来的名称</p>
<p>比如日期：用generationTimestamp，而不要使用genymdhms。</p>
<p>5、使用可搜索的名称</p>
<p>单字母和数字常量很难搜出。使用宏或者变量命名这类数据。</p>
<p>6、避免使用编码</p>
<p>不必用前缀表示成员变量。</p>
<p>7、避免思维映射</p>
<p>8、类名</p>
<p>类名和对象应该是名词或名词短语。</p>
<p>9、方法名</p>
<p>方法名应该是动词或动词短语。</p>
<p>10、别扮可爱</p>
<p>11、每个概念对应一个词</p>
<p>12、别用双关语</p>
<p>避免将同一个单词用于不同目的。</p>
<p>13、使用解决方案领域名称</p>
<p>尽可能使用IT类术语</p>
<p>14、使用源自所涉问题领域的名称</p>
<p>15、使用有意义的语境</p>
<p>如：使用addrState代替state</p>
<p>16、不要添加没用的语境</p>
<p>如：不要用GSD代替GasStationDeluxe这样类似的短语。</p>
<h2 id="%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%87%BD%E6%95%B0" tabindex="-1">第三章 函数</h2>
<p>函数的第一规则是要短小，第二规则是还要更短小。</p>
<p>函数的缩进层数不该多于一层或两层。</p>
<p>函数应该做一件事，做好这件事，只做这一件事。</p>
<p>要判断函数是否不止做了一件事，看是否能再拆出一个函数，该函数不仅是单纯地重新诠释其实现。</p>
<p>函数参数，最理想的参数是0,其次是1,再次是2.尽量避免3个。有足够特殊的理由才能用3个以上函数。</p>
<p>如果函数看起来需要两个，三个或三个以上参数，就说明其中一些参数应该封装成类了。</p>
<p>函数不应有副作用，如，检查密码的函数不应该有初始化Session的步骤。</p>
<p>把指令和询问分隔开来。</p>
<p>别重复自己。</p>
<p>如何做到：先想些什么就写什么，然后再打磨它。</p>
<h2 id="%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%B3%A8%E9%87%8A" tabindex="-1">第四章 注释</h2>
<p>注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。</p>
<p>注释会撒谎，因为修改代码后并不会让注释随之变动。</p>
<p>注释不会美化糟糕的代码。</p>
<p>与其花时间美化代码，不如花时间清洁代码。</p>
<p>好注释：</p>
<blockquote>
<p>1、法律信息</p>
<p>2、提供信息的注释</p>
<p>3、对意图的注释</p>
<p>4、阐释</p>
<p>5、警示</p>
<p>6、TODO</p>
<p>7、放大：放大某种看起来不合理之物的重要性</p>
<p>8、公共API中的javadoc</p>
</blockquote>
<p>坏注释：</p>
<blockquote>
<p>1、喃喃自语</p>
<p>2、多余的注释</p>
<p>3、误导性注释</p>
<p>4、循规式注释</p>
<p>5、日志式注释</p>
<p>6、废话注释</p>
<p>7、可怕的废话</p>
<p>8、能用函数或变量时就别用注释</p>
<p>9、位置标记</p>
<p>10、括号后面的注释</p>
<p>11、归属和署名</p>
<p>12、注释掉的代码（别这么干）</p>
<p>13、html注释</p>
<p>14、非本地信息</p>
<p>15、信息过多</p>
<p>16、不明显的联系</p>
<p>17、函数头</p>
<p>18、非公共代码中的javadoc</p>
</blockquote>
<h2 id="%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%BC%E5%BC%8F" tabindex="-1">第五章 格式</h2>
<p>代码格式很重要，关乎沟通。</p>
<p>实体变量应该在类的顶部声明。</p>
<p>相关函数。若某个函数调用了另一个，就应该把它们放到一起。而且调用着应该尽可能放在被调用着上面。</p>
<p>四则运算时，运算级较高的符号可以不用空格隔开。</p>
<p>每个程序员都有自己喜欢的格式规则，但如果在一个团队中工作，就是团队说了算。</p>
<h2 id="%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" tabindex="-1">第六章 对象和数据结构</h2>
<p>隐藏实现并非只是变量之间放上一个函数层那么简单。隐藏实现关乎抽象。类并不简单地用取值器和赋值器将变量推向外间，而是暴露抽象接口，以便用户无需了解数据的实现便能操作数据本体。</p>
<p>要以最好的方式呈现某个对象包含的数据，需要做严肃的思考。</p>
<p>过程式代码便于在不改动既有函数的前提下添加新类。</p>
<p>得墨耳律：模块不应了解它所操作对象的内部情形。</p>
<p>例如：类C的f方法只应调用以下对象的方法：</p>
<blockquote>
<p>C
由f创建的对象</p>
<p>由C的实体变量持有的对象</p>
</blockquote>
<p>即：方法不应调用由任何函数返回的对象的方法。</p>
<h2 id="%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86" tabindex="-1">第七章 错误处理</h2>
<p>使用异常而非返回码。
先写try、catch、finally语句</p>
<p>使用不可控异常</p>
<p>给出异常发生的环境说明。</p>
<blockquote>
<p>应创建信息充分的错误信息，并和异常一起传递出去。在消息中，包括失败的操作和失败的类型。如果你的应用程序由日志系统，传递足够的信息给catch块，并记录下来。</p>
</blockquote>
<p>依调用者需要定义异常类。</p>
<p>定义常规流程。</p>
<p>别返回null值。</p>
<p>别传递null值。</p>
<h2 id="%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" tabindex="-1">第九章 单元测试</h2>
<h3 id="tdd%E4%B8%89%E5%AE%9A%E5%BE%8B" tabindex="-1">TDD三定律</h3>
<blockquote>
<p>1、在编写不能通过的单元测试前，不可编写生产代码。</p>
<p>2、只可编写刚好无法通过的单元测试，不能编译也不算通过。</p>
<p>3、只可编写刚好足以通过当前失败测试的生产代码。</p>
</blockquote>
<p>保持测试整洁。</p>
<p>脏测试等同于没测试。</p>
<p>测试代码和生产代码一样重要。</p>
<p>整洁的测试三要素：可读性，可读性和可读性。</p>
<p>每个测试一个断言。</p>
<p>每个测试只测试一个概念。</p>
<h3 id="f.i.r.s.t." tabindex="-1">F.I.R.S.T.</h3>
<blockquote>
<p>Fast(快速)、Independent(独立)、Repeatable(可重复)、Self-Validating(自足验证)、Timely(及时)</p>
</blockquote>
<h2 id="%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B1%BB" tabindex="-1">第十章 类</h2>
<p>类应该短小。</p>
<p>用权责衡量类的大小。</p>
<p>如果无法为某个类命以精确的名称，这个类大概太长了。</p>
<p>SRP，单一权责原则，类或模块应有且只有一条加以修改的理由。</p>
<p>系统应该有许多短小的类而不是少量巨大的类组成。每个小雷封装一个权责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为。</p>
<p>内聚：如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。</p>
<h2 id="%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%B3%BB%E7%BB%9F" tabindex="-1">第十一章 系统</h2>
<p>将构造与使用分开的方法之一是将全部构造过程搬迁到main或被称之为main的模块中，设计系统的其他部分时，假设所有对象都已正确构造和设置。</p>
<p>使用工厂方法，让程序负责确定何时创建对象。</p>
<p>AOP 切面编程</p>
<h2 id="%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E8%BF%AD%E8%BF%9B" tabindex="-1">第十二章 迭进</h2>
<p>简单设计四条规则：</p>
<blockquote>
<p>运行所有测试；</p>
<p>不可重复；</p>
<p>表达了程序员的意图；</p>
<p>尽可能减少类和方法的数量。</p>
</blockquote>
<p>极其雷同的代码就是重复。</p>
<p>要想实现大规模复用，必须理解如何实现小规模复用。</p>
<p>模板方法模式是一种移除高层级重复的通用技巧</p>
<h2 id="%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B" tabindex="-1">第十三章 并发编程</h2>
<p>对象是过程的抽象，线程是调度的抽象。</p>
<p>并发是一种解耦策略，帮助我们把做什么（目的）和何时（时间）做分解开。</p>
<p>并发会在性能和编写额外代码上增加一些开销。</p>
<p>正确的并发是复杂的，即便对于简单的问题也是如此。</p>
<p>并发缺陷并非总能重现，所以常被看做偶发事件而忽略，未被当作真的缺陷对待。</p>
<p>并发常常需要对设计策略的根本性修改。</p>
<h3 id="%E5%B9%B6%E5%8F%91%E9%98%B2%E5%BE%A1%E5%8E%9F%E5%88%99%EF%BC%9A" tabindex="-1">并发防御原则：</h3>
<blockquote>
<p>1、SRP，分离并发相关代码和其他代码。</p>
<p>2、推论：限制数据作用域。</p>
<p>3、推论：使用数据复本，避免共享数据的好方法之一就是一开始就避免共享数据。</p>
<p>4、推论：线程应尽可能独立。尝试将数据分解到可独立线程（可能在不同处理器上）操作的独立子集。</p>
</blockquote>
<h3 id="%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B" tabindex="-1">并发执行模型</h3>
<blockquote>
<p>生产者－消费者</p>
<p>读者－作者</p>
<p>宴席哲学家</p>
</blockquote>
<p>学习这些基础算法，理解其解决方案。</p>
<p>在你认为自己完成某个函数之前，确认自己理解了它是怎么工作的。通过全部测试还不够好。你必须知道解决方案是正确的。获得这种知识和理解的最好途径，往往是重构函数，得到某种整洁而足具表达力、清楚呈示如何工作的东西。</p>
<p>用多态替代If/Else或Switch/Case</p>
<h2 id="%E6%80%BB%E7%BB%93" tabindex="-1">总结</h2>
<p>看了这本书，得到了很多新的指导，建议。这确实是一本好书，作者表达很清晰，说明白了该怎么做。虽然知道了，但是还是得要根据当中的理论多去实践才能体会当中的精髓。</p>

    </div>
    <hr />
      <div class="text-sm text-center">
        评论和交流请发送邮件到 hoohackhu@gmail.com
      </div>
      <hr />
    <div class="text-center">
</div>
    <footer class="text-sm py-12 text-gray-500 text-center">
  Hoohack's Blog since 2014
</footer>
  </div>

</div>



</body>
</html>