<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta property="og:title" content="【译】理解数组在PHP内部的实现（给PHP开发者的PHP源码-第四部分）" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://hoohack.me/blog/2016/2016-02-15-understanding-phps-internal-array-implementation-ch/" />
  <link rel="stylesheet" href="/styles/main.css">
  <link rel="me" href="https://mas.to/@djyde">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/themes/prism.min.css">
  
  <title>【译】理解数组在PHP内部的实现（给PHP开发者的PHP源码-第四部分） | Hoohack&#39;s Blog</title>
  
</head>
<body>
  
<div>
  <div class="container mx-auto prose py-12 sm:py-24 px-12 sm:px-0">
    <div class="mb-12">
      <a class="no-underline font-bold" href="/">Hoohack&#39;s Blog</a>
    </div>
    <h1>【译】理解数组在PHP内部的实现（给PHP开发者的PHP源码-第四部分）</h1>
    <div class="italic text-gray-500">
      2016/02/15
    </div>
    <div>
      <p>原文：<a href="https://nikic.github.io/2012/03/28/Understanding-PHPs-internal-array-implementation.html">https://nikic.github.io/2012/03/28/Understanding-PHPs-internal-array-implementation.html</a></p>
<p>欢迎来到&quot;给PHP开发者的PHP源码&quot;系列的第四部分，这一部分我们会谈论PHP数组在内部是如何表示和在代码库里使用的。</p>
<p>为了防止你错过了之前的文章，以下是链接：</p>
<p>第一部分：<a href="https://www.hoohack.me/2016/02/04/phps-source-code-for-php-developers-ch">给PHP开发者的PHP源码-源码结构</a></p>
<p>第二部分：<a href="https://www.hoohack.me/2016/02/10/understanding-phps-internal-function-definitions-ch">理解PHP内部函数的定义</a></p>
<p>第三部分：<a href="https://www.hoohack.me/2016/02/12/phps-source-code-for-php-developers-part3-variables-ch">PHP的变量实现</a></p>
<h2 id="%E6%89%80%E6%9C%89%E7%9A%84%E4%B8%9C%E8%A5%BF%E9%83%BD%E6%98%AF%E5%93%88%E5%B8%8C%E8%A1%A8" tabindex="-1">所有的东西都是哈希表</h2>
<p>基本上，PHP里面的所有东西都是哈希表。不仅仅是在下面的PHP数组实现中，它们还用来存储对象属性，方法，函数，变量还有几乎所有东西。</p>
<p>因为哈希表对PHP来说太基础了，因此非常值得深入研究它是如何工作的。</p>
<h2 id="%E9%82%A3%E4%B9%88%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%9F" tabindex="-1">那么，什么是哈希表？</h2>
<p>记住，在C里面，数组是内存块，你可以通过下标访问这些内存块。因此，在C里面的数组只能使用整数且有序的键值（那就是说，你不能在键值0之后使用1332423442的键值）。C里面没有关联数组这种东西。</p>
<p>哈希表是这样的东西：它们使用哈希函数转换字符串键值为正常的整型键值。哈希后的结果可以被作为正常的C数组的键值（又名为内存块）。现在的问题是，哈希函数会有冲突，那就是说，多个字符串键值可能会生成一样的哈希值。例如，在PHP，超过64个元素的数组里，字符串&quot;foo&quot;和&quot;oof&quot;拥有一样的哈希值。</p>
<p>这个问题可以通过存储可能冲突的值到链表中，而不是直接将值存储到生成的下标里。</p>
<h2 id="hashtable%E5%92%8Cbucket" tabindex="-1">HashTable和Bucket</h2>
<p>那么，现在哈希表的基本概念已经清晰了，让我们看看在PHP内部中实现的哈希表结构：</p>
<p>typedef struct _hashtable {
uint nTableSize;
uint nTableMask;
uint nNumOfElements;
ulong nNextFreeElement;
Bucket *pInternalPointer;
Bucket *pListHead;
Bucket *pListTail;
Bucket **arBuckets;
dtor_func_t pDestructor;
zend_bool persistent;
unsigned char nApplyCount;
zend_bool bApplyProtection;
#if ZEND_DEBUG
int inconsistent;
#endif
} HashTable;</p>
<h2 id="%E5%BF%AB%E9%80%9F%E8%BF%87%E4%B8%80%E4%B8%8B%EF%BC%9A" tabindex="-1">快速过一下：</h2>
<p><code>nNumOfElements</code>标识现在存储在数组里面的值的数量。这也是函数<code>count($array)</code>返回的值。</p>
<p><code>nTableSize</code>表示哈希表的容量。它通常是下一个大于等于<code>nNumOfElements</code>的2的幂值。比如，如果数组存储了32元素，那么哈希表也是32大小的容量。但如果再多一个元素添加进来，也就是说，数组现在有33个元素，那么哈希表的容量就被调整为64。
这是为了保持哈希表在空间和时间上始终有效。很明显，如果哈希表太小，那么将会有很多的冲突，而且性能也会降低。另一方面，如果哈希表太大，那么浪费内存。2的幂值是一个很好的折中方案。</p>
<p><code>nTableMask</code>是哈希表的容量减一。这个mask用来根据当前的表大小调整生成的哈希值。例如，&quot;foo&quot;真正的哈希值（使用DJBX33A哈希函数）是193491849。如果我们现在有64容量的哈希表，我们明显不能使用它作为数组的下标。取而代之的是通过应用哈希表的mask，然后只取哈希表的低位。</p>
<p>hash           |        193491849 |     0b1011100010000111001110001001
&amp; mask         | &amp;             63 | &amp;   0b0000000000000000000000111111
---------------------------------------------------------
= index        | = 9              | =   0b0000000000000000000000001001</p>
<p><code>nNextFreeElement</code>是下一个可以使用的数字键值，当你使用$array[] = xyz是被使用到。</p>
<p><code>pInternalPointer</code> 存储数组当前的位置。这个值在foreach遍历时可使用reset()，current()，key()，next()，prev()和end()函数访问。</p>
<p><code>pListHead</code>和<code>pListTail</code>标识了数组的第一个和最后一个元素的位置。记住：PHP的数组是有序集合。比如，['foo' =&gt; 'bar', 'bar' =&gt; 'foo']和['bar' =&gt; 'foo', 'foo' =&gt; 'bar']这两个数组包含了相同的元素，但却有不同的顺序。</p>
<p><code>arBuckets</code>是我们经常谈论的“哈希表（internal C array）”。它用Bucket **来定义，因此它可以被看作数组的bucket指针（我们会马上谈论Bucket是什么）。</p>
<p><code>pDestructor</code>是值的析构器。如果一个值从HT中移除，那么这个函数会被调用。常见的析构函数是zval_ptr_dtor。zval_ptr_dtor会减少zval的引用数量，而且，如果它遇到o，它会销毁和释放它。</p>
<p>最后的四个变量对我们来说不是那么重要。所以简单地说persistent标识哈希表可以在多个请求里存活，nApplyCount和bApplyProtection防止多次递归，inconsistent用来捕获在调试模式里哈希表的非法使用。</p>
<p>让我们继续第二个重要的结构：Bucket：</p>
<p>typedef struct bucket {
ulong h;
uint nKeyLength;
void *pData;
void *pDataPtr;
struct bucket *pListNext;
struct bucket *pListLast;
struct bucket *pNext;
struct bucket *pLast;
const char *arKey;
} Bucket;</p>
<p><code>h</code>是一个哈希值（没有应用mask值映射之前的值）。</p>
<p><code>arKey</code>用来保存字符串键值。<code>nKeyLength</code>是对应的长度。如果是数字键值，那么这两个变量都不会被使用。</p>
<p><code>pData</code>及<code>pDataPtr</code>被用来存储真正的值。对PHP数组来说，它的值是一个zval结构体（但它也在其他地方使用到）。不要纠结为什么有两个属性。它们两者的区别是谁负责释放值。</p>
<p><code>pListNext</code>和<code>pListLast</code>标识数组元素的下一个元素和上一个元素。如果PHP想顺序遍历数组它会从pListHead这个bucket开始（在HashTable结构里面），然后使用pListNext bucket作为遍历指针。在逆序也是一样，从pListTail指针开始，然后使用pListLast指针作为变量指针。（你可以在用户代码里调用end()然后调用prev()函数达到这个效果。）</p>
<p><code>pNext</code>和<code>pLast</code>生成我上面提到的“可能冲突的值链表”。arBucket数组存储第一个可能值的bucket。如果该bucket没有正确的键值，PHP会查找pNext指向的bucket。它会一直指向后面的bucket直到找到正确的bucket。pLast在逆序中也是一样的原理。</p>
<p>你可以看到，PHP的哈希表实现相当复杂。这是它使用超灵活的数组类型要付出的代价。</p>
<h2 id="%E5%93%88%E5%B8%8C%E8%A1%A8%E6%98%AF%E6%80%8E%E4%B9%88%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84%EF%BC%9F" tabindex="-1">哈希表是怎么被使用的？</h2>
<p>Zend Engine定义了大量的API函数供哈希表使用。低级的哈希表函数预览可以在<code>zend_hash.h</code>文件里面找到。另外Zend Engine在<code>zend_API.h</code>文件定义了稍微高级一些的API。</p>
<p>我们没有足够的时间去讲所有的函数，但是我们至少可以查看一些实例函数，看看它是如何工作的。我们将使用<code>array_fill_keys</code>作为实例函数。</p>
<p>使用第二部分提到的技巧你可以很容易地找到函数在<code>ext/standard/array.c</code>文件里面定义了。现在，让我们来快速查看这个函数。</p>
<p>跟大部分函数一样，函数的顶部有一堆变量的定义，然后调用<code>zend_parse_parameters</code>函数：</p>
<p>zval *keys, *val, **entry;
HashPosition pos;</p>
<p>if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;az&quot;, &amp;keys, &amp;val) == FAILURE) {
return;
}</p>
<p>很明显，<code>az</code>参数说明第一个参数类型是数组（即变量<code>keys</code>），第二个参数是任意的zval（即变量<code>val</code>）。</p>
<p>解析完参数后，返回数组就被初始化了：</p>
<p>/* Initialize return array */
array_init_size(return_value, zend_hash_num_elements(Z_ARRVAL_P(keys)));</p>
<p>这一行包含了array API里面存在的三步重要的部分：</p>
<p>1、Z_ARRVAL_P宏从zval里面提取值到哈希表。</p>
<p>2、zend_hash_num_elements提取哈希表元素的个数（nNumOfElements属性）。</p>
<p>3、array_init_size使用size变量初始化数组。</p>
<p>因此，这一行使用与键值数组一样大小来初始化数组到<code>return_value</code>变量里。</p>
<p>这里的size只是一种优化方案。函数也可以只调用<code>array_init(return_value)</code>，这样随着越来越多的元素添加到数组里，PHP就会多次重置数组的大小。通过指定特定的大小，PHP会在一开始就分配正确的内存空间。</p>
<p>数组被初始化并返回后，函数用跟下面大致相同的代码结构，使用while循环变量keys数组：</p>
<p>zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(keys), &amp;pos);
while (zend_hash_get_current_data_ex(Z_ARRVAL_P(keys), (void **)&amp;entry, &amp;pos) == SUCCESS) {
// some code</p>
<p>zend_hash_move_forward_ex(Z_ARRVAL_P(keys), &amp;pos);
}</p>
<p>这可以很容易地翻译成PHP代码：</p>
<p>reset($keys);
while (null !== $entry = current($keys)) {
// some code</p>
<p>next($keys);
}</p>
<p>跟下面的一样：</p>
<p>foreach ($keys as $entry) {
// some code
}</p>
<p>唯一不同的是，C的遍历并没有使用内部的数组指针，而使用它自己的pos变量来存储当前的位置。</p>
<p>在循环里面的代码分为两个分支：一个是给数字键值，另一个是其他键值。数字键值的分支只有下面的两行代码：</p>
<p>zval_add_ref(&amp;val);
zend_hash_index_update(Z_ARRVAL_P(return_value), Z_LVAL_PP(entry), &amp;val, sizeof(zval *), NULL);</p>
<p>这看起来太直接了：首先值的引用增加了（添加值到哈希表意味着增加另一个指向它的引用），然后值被插入到哈希表中。<code>zend_hash_index_update</code>宏的参数分别是，需要更新的哈希表<code>Z_ARRVAL_P(return_value)</code>，整型下标<code>Z_LVAL_PP(entry)</code>，值<code>&amp;val</code>，值的大小<code>sizeof(zval *)</code>以及目标指针(这个我们不关注，因此是<code>NULL</code>）。</p>
<p>非数字下标的分支就稍微复杂一点：</p>
<p>zval key, *key_ptr = *entry;</p>
<p>if (Z_TYPE_PP(entry) != IS_STRING) {
key = **entry;
zval_copy_ctor(&amp;key);
convert_to_string(&amp;key);
key_ptr = &amp;key;
}</p>
<p>zval_add_ref(&amp;val);
zend_symtable_update(Z_ARRVAL_P(return_value), Z_STRVAL_P(key_ptr), Z_STRLEN_P(key_ptr) + 1, &amp;val, sizeof(zval *),             NULL);</p>
<p>if (key_ptr != *entry) {
zval_dtor(&amp;key);
}</p>
<p>首先，使用<code>convert_to_string</code>将键值转换为字符串（除非它已经是字符串了）。在这之前，<code>entry</code>被复制到新的<code>key</code>变量。<code>key = **entry</code>这一行实现。另外，<code>zval_copy_ctor</code>函数会被调用，不然复杂的结构（比如字符串或数组）不会被正确地复制。</p>
<p>上面的复制操作非常有必要，因为要保证类型转换不会改变原来的数组。如果没有copy操作，强制转换不仅仅修改局部的变量，而且也修改了在键值数组中的值（显然，这对用户来说非常意外）。</p>
<p>显然，循环结束之后，复制操作需要再次被移除，<code>zval_dtor(&amp;key)</code>做的就是这个工作。<code>zval_ptr_dtor</code>和<code>zval_dtor</code>的不同是<code>zval_ptr_dtor</code>只会在<code>refcount</code>变量为0时销毁zval变量，而<code>zval_dtor</code>会马上销毁它，而不是依赖<code>refcount</code>的值。这就为什么你看到<code>zval_pte_dtor</code>使用&quot;normal&quot;变量而<code>zval_dtor</code>使用临时变量，这些临时变量不会在其他地方使用。而且，<code>zval_ptr_dtor</code>会在销毁之后释放zval的内容而<code>zval_dtor</code>不会。因为我们没有<code>malloc()</code>任何东西，因此我们也不需要<code>free()</code>，因此在这方面，<code>zval_dtor</code>做了正确的选择。</p>
<p>现在来看看剩下的两行（重要的两行^^）：</p>
<p>zval_add_ref(&amp;val);
zend_symtable_update(Z_ARRVAL_P(return_value), Z_STRVAL_P(key_ptr), Z_STRLEN_P(key_ptr) + 1, &amp;val, sizeof(zval *), NULL);</p>
<p>这跟数字键值分支完成后的操作非常相似。不同的是，现在调用的是<code>zend_symtable_update</code>而不是<code>zend_hash_index_update</code>，而传递的是键值字符串和它的长度。</p>
<h2 id="%E7%AC%A6%E5%8F%B7%E8%A1%A8" tabindex="-1">符号表</h2>
<p>&quot;正常的&quot;插入字符串键值到哈希表的函数是<code>zend_hash_update</code>，但这里却使用了<code>zend_symtable_update</code>。它们有什么不同呢？</p>
<p>符号表简单地说就是哈希表的特殊的类型，这种类型使用在数组里。它跟原始的哈希表不同的是他如何处理数字型的键值：在符号表里，&quot;123&quot;和123被看作是相同的。因此，如果你在$array[&quot;123&quot;]存储一个值，你可以在后面使用$array[123]获取它。</p>
<p>底层可以使用两种方式实现：要么使用&quot;123&quot;来保存123和&quot;123&quot;，要么使用123来保存这两种键值。显然PHP选择了后者（因为整型比字符串类型更快和占用更少的空间）。</p>
<p>如果你不小心使用&quot;123&quot;而不是强制转换为123后插入数据，你会发现符号表一些有趣的事情。一个利用数组到对象的强制转换如下：</p>
<p>$obj = new stdClass;
$obj-&gt;{123} = &quot;foo&quot;;
$arr = (array) $obj;
var_dump($arr[123]); // Undefined offset: 123
var_dump($arr[&quot;123&quot;]); // Undefined offset: 123</p>
<p>对象属性总是使用字符串键值来保存，尽管它们是数字。因此<code>$obj-&gt;{123} = 'foo'</code>这行代码实际上保存'foo'变量到&quot;123&quot;下标里。当使用数组强制转换的时候，这个值不会给改变。但当<code>$arr[123]</code>和<code>$arr[&quot;123&quot;]</code>都想访问123下标的值（不是已有的&quot;123&quot;下标）时，都抛出了错误。因此，恭喜，你创建了一个隐藏的数组元素。</p>
<p>下一部分
下一部分会再次在ircmaxell的博客发表。下一篇会介绍对象和类在内部是如何工作的。</p>

    </div>
    <hr />
      <div class="text-sm text-center">
        评论和交流请发送邮件到 hoohackhu@gmail.com
      </div>
      <hr />
    <div class="text-center">
<img class="w-64 inline-block" src="https://www.hoohack.me/assets/images/reward.jpeg" alt="" />
<div class="text-sm">
通过赞赏码赞助此文
</div>
</div>
    <footer class="text-sm py-12 text-gray-500 text-center">
  Hoohack's Blog since 2014
</footer>
  </div>

</div>



</body>
</html>