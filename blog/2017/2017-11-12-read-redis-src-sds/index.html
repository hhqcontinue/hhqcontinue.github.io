<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta property="og:title" content="［Redis源码阅读］sds字符串实现" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://hoohack.me/blog/2017/2017-11-12-read-redis-src-sds/" />
  <link rel="stylesheet" href="/styles/main.css">
  <link rel="me" href="https://mas.to/@djyde">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/themes/prism.min.css">
  
  <title>［Redis源码阅读］sds字符串实现 | Hoohack&#39;s Blog</title>
  
  <script async src="https://ana.hoohack.me/ana.js" data-website-id="380499a9-5e2b-4320-bb7d-fc6bb57fdf79"></script>
</head>
<body>
  
<div>
  <div class="container mx-auto prose py-12 sm:py-24 px-12 sm:px-0">
    <div class="mb-12">
      <a class="no-underline font-bold" href="/">Hoohack&#39;s Blog</a>
    </div>
    <h1>［Redis源码阅读］sds字符串实现</h1>
    <div class="italic text-gray-500">
      2017/11/12
    </div>
    <div>
      <h2 id="%E5%88%9D%E8%A1%B7" tabindex="-1">初衷</h2>
<p>从开始工作就开始使用Redis，也有一段时间了，但都只是停留在使用阶段，没有往更深的角度探索，每次想读源码都止步在阅读书籍上，因为看完书很快又忘了，这次逼自己先读代码。因为个人觉得写作需要阅读文字来增强灵感，那么写代码的，就阅读更多代码来增强灵感吧。</p>
<p>redis的实现原理，在《Redis设计与实现》一书中讲得很详细了，但是想通过结合代码的形式再深入探索，加深自己的理解，现在将自己探索的心得写在这儿。</p>
<h2 id="sds%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89" tabindex="-1">sds结构体的定义</h2>
<p>#define SDS_TYPE_5  0
#define SDS_TYPE_8  1
#define SDS_TYPE_16 2
#define SDS_TYPE_32 3
#define SDS_TYPE_64 4
#define SDS_TYPE_MASK 7</p>
<p>// sds结构体，使用不同的结构体来保存不同长度大小的字符串
typedef char *sds;</p>
<p>struct <strong>attribute</strong> ((<strong>packed</strong>)) sdshdr5 {
unsigned char flags; /* flags共8位，低三位保存类型标志，高5位保存字符串长度，小于32(2^5-1) <em>/
char buf[]; // 保存具体的字符串
};
struct <strong>attribute</strong> ((<strong>packed</strong>)) sdshdr8 {
uint8_t len; /</em> 字符串长度，buf已用的长度 <em>/
uint8_t alloc; /</em> 为buf分配的总长度，alloc-len就是sds结构体剩余的空间 <em>/
unsigned char flags; /</em> 低三位保存类型标志 <em>/
char buf[];
};
struct <strong>attribute</strong> ((<strong>packed</strong>)) sdshdr16 {
uint16_t len; /</em> used <em>/
uint16_t alloc; /</em> excluding the header and null terminator <em>/
unsigned char flags; /</em> 3 lsb of type, 5 unused bits <em>/
char buf[];
};
struct <strong>attribute</strong> ((<strong>packed</strong>)) sdshdr32 {
uint32_t len; /</em> used <em>/
uint32_t alloc; /</em> excluding the header and null terminator <em>/
unsigned char flags; /</em> 3 lsb of type, 5 unused bits <em>/
char buf[];
};
struct <strong>attribute</strong> ((<strong>packed</strong>)) sdshdr64 {
uint64_t len; /</em> used <em>/
uint64_t alloc; /</em> excluding the header and null terminator <em>/
unsigned char flags; /</em> 3 lsb of type, 5 unused bits */
char buf[];
};</p>
<p>sds结构体从4.0开始就使用了5种header定义，节省内存的使用，但是不会用到sdshdr5，我认为是因为sdshdr5能保存的大小较少，2^5=32，因此就不使用它。</p>
<p>其他的结构体保存了len、alloc、flags以及buf四个属性。各自的含义见代码的注释。</p>
<h2 id="sds%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E8%8E%B7%E5%8F%96" tabindex="-1">sds结构体的获取</h2>
<p>上面可以看到有5种结构体的定义，在使用的时候是通过一个宏来获取的：</p>
<p>#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))</p>
<p>**&quot;##&quot;**被称为连接符，它是一种预处理运算符， 用来把两个语言符号(Token)组合成单个语言符号。比如<code>SDS_HDR(8, s)</code>，根据宏定义展开是：</p>
<p>((struct sdshdr8 *)((s)-(sizeof(struct sdshdr8))))</p>
<p>而具体使用哪一个结构体，sds底层是通过flags属性与<code>SDS_TYPE_MASK</code>做与运算得出具体的类型（具体的实现可见下面的sdslen函数），然后再根据类型去获取具体的结构体。</p>
<h2 id="sds%E7%89%B9%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0" tabindex="-1">sds特性的实现</h2>
<p>在Redis设计与实现一书中讲到，相比C字符串而言，sds的特性如下：</p>
<blockquote>
<ul>
<li>常数复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少内存重新分配次数</li>
<li>二进制安全</li>
</ul>
</blockquote>
<p>那么，它是怎么做到的呢？看代码。</p>
<h3 id="%E5%B8%B8%E6%95%B0%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6" tabindex="-1">常数复杂度获取字符串长度</h3>
<p>因为sds将长度属性保存在结构体中，所以只需要读取这个属性就能获取到sds的长度，具体调用的函数时sdslen，实现如下：</p>
<p>static inline size_t sdslen(const sds s) {
unsigned char flags = s[-1];
switch(flags&amp;SDS_TYPE_MASK) {
case SDS_TYPE_5:
return SDS_TYPE_5_LEN(flags);
case SDS_TYPE_8:
return SDS_HDR(8,s)-&gt;len;
case SDS_TYPE_16:
return SDS_HDR(16,s)-&gt;len;
case SDS_TYPE_32:
return SDS_HDR(32,s)-&gt;len;
case SDS_TYPE_64:
return SDS_HDR(64,s)-&gt;len;
}
return 0;
}</p>
<p>可以看到，函数是根据类型调用SDS_HDR宏来获取具体的sds结构，然后直接返回结构体的len属性。</p>
<h3 id="%E6%9D%9C%E7%BB%9D%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA" tabindex="-1">杜绝缓冲区溢出</h3>
<p>对于C字符串的操作函数来说，如果在修改字符串的时候忘了为字符串分配足够的空间，就有可能出现缓冲区溢出的情况。而sds中的API就不会出现这种情况，因为它在修改sds之前，都会判断它是否有足够的空间完成接下来的操作。</p>
<p>拿书中举例的<code>sdscat</code>函数来看，如果<code>strcat</code>想在原来的&quot;Redis&quot;字符串的基础上进行字符串拼接的操作，但是没有检查空间是否满足，就有可能会修改了&quot;Redis&quot;字符串之后使用到的内存，可能是其他结构使用了，也有可能是一段没有被使用的空间，因此有可能会出现缓冲区溢出。但是<code>sdscat</code>就不会，如下面代码所示：</p>
<p>sds sdscatlen(sds s, const void *t, size_t len) {
size_t curlen = sdslen(s);</p>
<p>s = sdsMakeRoomFor(s,len);
if (s == NULL) return NULL;
memcpy(s+curlen, t, len);
sdssetlen(s, curlen+len);
s[curlen+len] = '\0';
return s;
}</p>
<p>sds sdscat(sds s, const char *t) {
return sdscatlen(s, t, strlen(t));
}</p>
<p>从代码中可以看到，在执行<code>memcpy</code>将字符串写入sds之前会调用<code>sdsMakeRoomFor</code>函数去检查sds字符串s是否有足够的空间，如果没有足够空间，就为其分配足够的空间，从而杜绝了缓冲区溢出。<code>sdsMakeRoomFor</code>函数的实现如下：</p>
<p>sds sdsMakeRoomFor(sds s, size_t addlen) {
void *sh, *newsh;
size_t avail = sdsavail(s);
size_t len, newlen;
char type, oldtype = s[-1] &amp; SDS_TYPE_MASK;
int hdrlen;</p>
<p>/* 只有有足够空间就马上返回，否则就继续执行分配空间的操作 */
if (avail &gt;= addlen) return s;</p>
<p>len = sdslen(s);
sh = (char*)s-sdsHdrSize(oldtype);
newlen = (len+addlen);
// SDS_MAX_PREALLOC == 1MB，如果修改后的长度小于1M，则分配的空间是原来的2倍，否则增加1MB的空间
if (newlen &lt; SDS_MAX_PREALLOC)
newlen *= 2;
else
newlen += SDS_MAX_PREALLOC;</p>
<p>type = sdsReqType(newlen);</p>
<p>if (type == SDS_TYPE_5) type = SDS_TYPE_8;</p>
<p>hdrlen = sdsHdrSize(type);
if (oldtype==type) {
newsh = s_realloc(sh, hdrlen+newlen+1);
if (newsh == NULL) return NULL;
s = (char*)newsh+hdrlen;
} else {
/* 新增空间后超过当前类型的长度，使用malloc，并把原字符串拷贝过去 <em>/
newsh = s_malloc(hdrlen+newlen+1);
if (newsh == NULL) return NULL;
memcpy((char</em>)newsh+hdrlen, s, len+1);
s_free(sh);
s = (char*)newsh+hdrlen;
s[-1] = type; // 给类型标志位赋值
sdssetlen(s, len);
}
sdssetalloc(s, newlen);
return s;
}</p>
<h3 id="%E5%87%8F%E5%B0%91%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%93%8D%E4%BD%9C" tabindex="-1">减少内存分配操作</h3>
<p>sds字符串的很多操作都涉及到修改字符串内容，比如<code>sdscat</code>拼接字符串、<code>sdscpy</code>拷贝字符串等等。这时候就需要内存的分配与释放，如果每次操作都分配刚刚好的大小，那么对程序的性能必定有影响，因为内存分配涉及到系统调用以及一些复杂的算法。</p>
<p>sds使用了空间预分配以及惰性空间释放的策略来减少内存分配操作。</p>
<h4 id="%E7%A9%BA%E9%97%B4%E9%A2%84%E5%88%86%E9%85%8D" tabindex="-1">空间预分配</h4>
<p>前面提到，每次涉及到字符串的修改时，都会调用<code>sdsMakeRoomFor</code>检查sds字符串，如果大小不够再进行大小的重新分配。<code>sdsMakeRoomFor</code>函数有下面这几行判断：</p>
<p>// SDS_MAX_PREALLOC == 1MB，如果修改后的长度小于1M，则分配的空间是原来的2倍，否则增加1MB的空间
if (newlen &lt; SDS_MAX_PREALLOC)
newlen *= 2;
else
newlen += SDS_MAX_PREALLOC;</p>
<p>函数判断字符串修改后的大小，如果修改后的长度小于1M，则分配给sds的空间是原来的2倍，否则增加1MB的空间。</p>
<h4 id="%E6%83%B0%E6%80%A7%E7%A9%BA%E9%97%B4%E9%87%8A%E6%94%BE" tabindex="-1">惰性空间释放</h4>
<p>如果操作后减少了字符串的大小，比如下面的<code>sdstrim</code>函数，只是在最后修改len属性，不会马上释放多余的空间，而是继续保留多余的空间，这样在下次需要增加sds字符串的大小时，就不需要再为其分配空间了。当然，如果之后检查到sds的大小实在太大，也会调用<code>sdsRemoveFreeSpac</code>e函数释放多余的空间。</p>
<p>sds sdstrim(sds s, const char *cset) {
char *start, *end, *sp, *ep;
size_t len;</p>
<p>sp = start = s;
ep = end = s+sdslen(s)-1;
/* 从头部和尾部逐个字符遍历往中间靠拢，如果字符在cest中，则继续前进 */
while(sp &lt;= end &amp;&amp; strchr(cset, *sp)) sp++;
while(ep &gt; sp &amp;&amp; strchr(cset, *ep)) ep--;
len = (sp &gt; ep) ? 0 : ((ep-sp)+1); // 全部被去除了，长度就是0
if (s != sp) memmove(s, sp, len); // 拷贝内容
s[len] = '\0';
sdssetlen(s,len);
return s;
}</p>
<h3 id="%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8" tabindex="-1">二进制安全</h3>
<p>二进制安全指的是只关心二进制化的字符串，不关心具体格式。只会严格的按照二进制的数据存取，不会妄图以某种特殊格式解析数据。比如遇到'\0'字符不会停止解析。</p>
<p>对于C字符串来说，<code>strlen</code>是判断遇到'\0'之前的字符数量。如果需要保存二进制的数据，就不能通过传统的C字符串来保存，因为获取不到它真实的长度。而sds字符串是通过len属性保存字符串的大小，所以它是二进制安全的。</p>
<h2 id="%E5%85%B6%E4%BB%96%E5%B0%8F%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0" tabindex="-1">其他小函数实现</h2>
<p>在阅读源码的过程中，也发现了两个个人比较感兴趣趣的函数：</p>
<blockquote>
<ul>
<li>sdsll2str（将long long类型的整型数字转成字符串）</li>
<li>sdstrim （去除头部和尾部的指定字符）</li>
</ul>
</blockquote>
<p>我这两个函数拉出来做了测试，在项目的<code>redis-4.0/tests</code>目录下。<code>sdstrim</code>函数的实现源码上面有列出，看看<code>sdsll2str</code>的实现：</p>
<p>int sdsll2str(char *s, long long value) {
char *p, aux;
unsigned long long v;
size_t l;</p>
<p>/* 通过取余数得到原字符串的逆转形式 */
v = (value &lt; 0) ? -value : value;
p = s;
do {
*p++ = '0'+(v%10);
v /= 10;
} while(v);
if (value &lt; 0) *p++ = '-';</p>
<p>/* Compute length and add null term. */
l = p-s;
*p = '\0';</p>
<p>/* 反转字符串 */
p--;
while(s &lt; p) {
aux = *s;
*s = *p;
*p = aux;
s++;
p--;
}
return l;
}</p>
<p>函数是通过不断取余数，得到原字符串的逆转形式，接着，通过从尾部开始将字符逐个放到字符串s中，看起来像是一个反转操作，从而实现了将整型转为字符串的操作。</p>
<p>觉得感兴趣是因为<code>sdsll2str</code>这个函数在之前学习C语言的时候经常能看到作为问题出现，能看到如此简洁的实现，表示眼前一亮。而在PHP开发时经常使用trim函数，所以想看看它们的区别。</p>
<h2 id="%E6%80%BB%E7%BB%93" tabindex="-1">总结</h2>
<p>通过详细地阅读sds的源码，不仅学习到sds的实现细节，还学习到了一些常用字符串操作函数的实现。如果只是仅仅看看数据结构的定义也可以初步了解，但是要深入了解的话还是需要详细的阅读具体函数的实现代码。还是那句，写代码的，需要阅读更多代码来增强灵感。</p>
<p>我在github有对Redis源码更详细的注解。感兴趣的可以围观一下，给个star。<a href="https://github.com/hoohack/read-redis-src">Redis4.0源码注解</a>。可以通过<a href="https://github.com/hoohack/read-redis-src/commits/master">commit记录</a>查看已添加的注解。</p>
<p>原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。</p>
<p>如果本文对你有帮助，请点个赞吧，谢谢^_^</p>

    </div>
    <hr />
      <div class="text-sm text-center">
        评论和交流请发送邮件到 hoohackhu@gmail.com
      </div>
      <hr />
    <div class="text-center">
<img class="w-64 inline-block" src="https://www.hoohack.me/assets/images/reward.jpeg" alt="" />
<div class="text-sm">
通过赞赏码赞助此文
</div>
</div>
    <footer class="text-sm py-12 text-gray-500 text-center">
  Hoohack's Blog since 2014
</footer>
  </div>

</div>



</body>
</html>