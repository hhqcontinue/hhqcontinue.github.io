<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hoohack&#39;s Blog</title>
  <subtitle>Hoohack is blogging about life, tech and reading.</subtitle>
  <link href="https://hoohack.me/rss.xml" rel="self"/>
  <link href="https://hoohack.me/"/>
  <updated>2020-09-19T00:00:00Z</updated>
  <id>https://hoohack.me/</id>
  <author>
    <name>Hoohack</name>
  </author>
  
  <entry>
    <title>你附近的人都有谁，这个功能是怎么实现的？</title>
    <link href="https://hoohack.me/blog/2020/2020-09-19-using-redis-geo-find-nearby/"/>
    <updated>2020-09-19T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2020/2020-09-19-using-redis-geo-find-nearby/</id>
    <content type="html">&lt;p&gt;手机上很多软件都有附近的人的功能，比如微信的“附近的人”，美团的“附近的餐厅”等等，那么这些功能可以怎么实现呢？&lt;/p&gt;
&lt;h2 id=&quot;redis%E4%B8%AD%E7%9A%84geo%E5%91%BD%E4%BB%A4&quot; tabindex=&quot;-1&quot;&gt;Redis中的Geo命令&lt;/h2&gt;
&lt;p&gt;在Redis在3.2版本新增了一个功能，就是GEO（地理位置），这个GEO功能总共有6个函数，分别为：&lt;/p&gt;
&lt;p&gt;GEOADD：添加指定的地理位置坐标值到指定的key中，可以同时添加多个。&lt;/p&gt;
&lt;p&gt;语法：&lt;code&gt;GEOADD location-set longitude latitude name [longitude latitude name ...]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;GEODIST：计算两个给定位置之间的距离，可指定距离的单位，默认是米。&lt;/p&gt;
&lt;p&gt;语法：&lt;code&gt;GEODIST location-set location-x location-y [unit]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;GEOHASH：获取地理位置的geohash值。&lt;/p&gt;
&lt;p&gt;语法：&lt;code&gt;GEOHASH key member [member …]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;GEOPOS：指定key和member，返回所有指定名称的位置&lt;/p&gt;
&lt;p&gt;语法：&lt;code&gt;GEOPOS location-set name [name ...]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;GEORADIUS：给定经纬度信息，以给定的经纬度为中心，查询与中心位置距离不超过给定最大距离(radius)的所有地理位置元素。&lt;/p&gt;
&lt;p&gt;语法：&lt;code&gt;GEORADIUS location-set longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [ASC|DESC] [COUNT count]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;GEORADIUSBYMEMBER：与&lt;code&gt;GEORADIUS&lt;/code&gt;命令类似，给定中心位置，查询附近的地理位置元素，与&lt;code&gt;GEORADIUS&lt;/code&gt;命令不同的是，这个命令的中心点是某个成员，是从用户的维度来查询。&lt;/p&gt;
&lt;p&gt;语法：&lt;code&gt;GEORADIUSBYMEMBER location-set location radius m|km|ft|mi [WITHCOORD] [WITHDIST] [ASC|DESC] [COUNT count]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;更详细的参数说明可参考&lt;a href=&quot;https://redis.io/commands#geo&quot;&gt;redis文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;实现附近的人等方法就是通过&lt;code&gt;GEOADD&lt;/code&gt;将多个用户的地理位置坐标保存到Redis，使用&lt;code&gt;GEORADIUS&lt;/code&gt;就可以获得某个中心点指定范围内附近的人的所有地理位置元素及距离等信息。&lt;/p&gt;
&lt;h2 id=&quot;%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B&quot; tabindex=&quot;-1&quot;&gt;使用示例&lt;/h2&gt;
&lt;p&gt;来看看具体是怎么使用的：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用GEOADD添加地理位置坐标&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/09/geoadd.jpg&quot; alt=&quot;geoadd&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用GEORADIUS查找附近的人&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/09/georadius.jpg&quot; alt=&quot;georadius&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用GEORADIUSBYMEMBER查找附近的人&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/09/georadiusbymember.jpg&quot; alt=&quot;georadiusbymember&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9&quot; tabindex=&quot;-1&quot;&gt;使用注意事项&lt;/h2&gt;
&lt;p&gt;1、异常&lt;/p&gt;
&lt;p&gt;注意在Java应用代码中调用georadius和georadiusbymember这两个指令，在没有数据的时候，会抛异常&lt;code&gt; redis.clients.jedis.exceptions.JedisDataException&lt;/code&gt;，所以在使用这个命令的时候，需要对方法进行try...catch...，或者自己封装一层，如果没有数据或者异常的时候返回空的数据。&lt;/p&gt;
&lt;p&gt;2、如何删除单个用户的位置数据&lt;/p&gt;
&lt;p&gt;Redis的Geo只提供了六个命令，没有提供删除地理位置的指令，而Redis-geo的底层数据结构是ZSET，因此可以通过ZREM命令来删除某个成员的位置元素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/09/zrem-geo.jpg&quot; alt=&quot;zrem-geo&quot; /&gt;&lt;/p&gt;
&lt;p&gt;3、单位&lt;/p&gt;
&lt;p&gt;查询出来的距离单位，就是查询时指定的单位，比如查询时指定了km，那么距离的单位就是km。&lt;/p&gt;
&lt;p&gt;4、经纬度1度的跨度是多少&lt;/p&gt;
&lt;p&gt;在经线上，纬度每差1度,实地距离大约为111千米&lt;/p&gt;
&lt;p&gt;在纬线上，经度每差1度,实际距离为111×cosθ千米。（其中θ表示该纬线的纬度.在不同纬线上,经度每差1度的实际距离是不相等的）。&lt;/p&gt;
&lt;p&gt;在生成测试数据时需要注意这一点，如果随便生成数据，在查询时可能会找不到。&lt;/p&gt;
&lt;p&gt;到这里为止，在Redis中使用geohash来实现附近功能的使用就介绍完了，使用起来就是这么简单，如果只是为了使用，看到这里就够了。如果你还想了解一下geohash的原理，那么请继续往下看。&lt;/p&gt;
&lt;h2 id=&quot;%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86&quot; tabindex=&quot;-1&quot;&gt;实现原理&lt;/h2&gt;
&lt;p&gt;Redis的Geo功能底层使用的数据结构是ZSET，算法是geohash算法。&lt;/p&gt;
&lt;h3 id=&quot;z%E9%98%B6%E6%9B%B2%E7%BA%BF&quot; tabindex=&quot;-1&quot;&gt;Z阶曲线&lt;/h3&gt;
&lt;p&gt;Z阶曲线如下所示，曲线看起来比较清晰，生成一个Z阶曲线只需要把每个Z的首尾相连即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/09/Z-line.jpg&quot; alt=&quot;Z-line&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;geohash%E6%8F%8F%E8%BF%B0&quot; tabindex=&quot;-1&quot;&gt;Geohash描述&lt;/h3&gt;
&lt;p&gt;Geohash是一种位置编码算法，它是基于&lt;a href=&quot;https://en.wikipedia.org/wiki/Z-order_curve&quot;&gt;Z阶曲线&lt;/a&gt;，把空间区域分割为多个网格/桶来存储，Geohash对地理位置编码后保存到字符串中。&lt;/p&gt;
&lt;p&gt;Geohash保证，如果编码得到的字符串的共同前缀长度越长，两点之间的距离就越近，但是反过来是不保证的，两个很接近的点，可以有不同的/很少的共同字符串前缀。嗯，这是一个充分不必要条件。&lt;/p&gt;
&lt;p&gt;简单的理解，Geohash就是将每一个经纬度的位置信息进行编码后得到编码字符串保存，而编码字符串相似的点，表示距离相近（也有特殊的情况），因此当根据某个中心点查找附近的人时，可以使用字符串前缀匹配算法来查找附近的人的位置信息。&lt;/p&gt;
&lt;h3 id=&quot;geohash%E7%89%B9%E7%82%B9%E4%B8%8E%E5%A5%BD%E5%A4%84&quot; tabindex=&quot;-1&quot;&gt;Geohash特点与好处&lt;/h3&gt;
&lt;p&gt;Geohash有两个特点：&lt;/p&gt;
&lt;p&gt;1、对于每一个位置，都有唯一的Geohash编码&lt;/p&gt;
&lt;p&gt;2、Geohash可以用来做地理标记&lt;/p&gt;
&lt;p&gt;在数据库中使用geohash编码保存位置信息还有两个好处：&lt;/p&gt;
&lt;p&gt;1、使用geohash来做索引，查询时会非常快&lt;/p&gt;
&lt;p&gt;2、geohash的索引可以实现非常快的临近点搜索，因为越接近的点，所在的索引范围越小&lt;/p&gt;
&lt;h3 id=&quot;geohassh%E7%BC%96%E7%A0%81&quot; tabindex=&quot;-1&quot;&gt;Geohassh编码&lt;/h3&gt;
&lt;p&gt;在进行编码时，geohash使用“二分逼近法”来得到经纬度的二进制，经度的范围是[-180,180]，纬度的范围是[-90,90]，编码过程如下：&lt;/p&gt;
&lt;p&gt;1、将区间以中位数一分为二得到左右区间，如果数值比中位数大，则落在右区间，得到编码1，否则落到左区间，得到编码0&lt;/p&gt;
&lt;p&gt;2、从第一步得到的新区间，继续将区间以中位数一分为二得到新的左右区间，继续判断数值的范围，如果数值比中位数大，则落在右区间，得到编码1，否则得到编码0&lt;/p&gt;
&lt;p&gt;3、递归执行上述的过程，不断逼近所求数值，直到得到所要的长度&lt;/p&gt;
&lt;p&gt;通过二分法不断逼近目标值获得0/1来得到某个数值的二进制编码，而编码的长度与要求的精度有关，长度与精度的对应关系见下表：&lt;/p&gt;
&lt;p&gt;| geohash length | 	lat bits	| lng bits	| lat error	| lng error	| km error |
| :----: |   :----:   |   :----:  |  :----:  |  :----:  |  :----:  |  :----:  |  :----:  |
| 1 | 2 | 3 | ±23 | ±23 | ±2500 |
| 2 | 5	| 5 | ±2.8 | ±5.6 | ±630 |
| 3	| 7	| 8 | ±0.70 | ±0.70 | ±78 |
| 4	| 10 | 10 | ±0.087 | ±0.18 | ±20 |
| 5	| 12 | 13 | ±0.022 | ±0.022 | ±2.4 |
| 6	| 15 | 15 | ±0.0027 | ±0.0055 | ±0.61 |
| 7	| 17 | 18 | ±0.00068 | ±0.00068 | ±0.076 |
| 8	| 20 | 20 | ±0.000085 | ±0.00017 | ±0.019 |&lt;/p&gt;
&lt;h3 id=&quot;%E7%BC%96%E7%A0%81%E8%BF%87%E7%A8%8B%E7%A4%BA%E4%BE%8B&quot; tabindex=&quot;-1&quot;&gt;编码过程示例&lt;/h3&gt;
&lt;p&gt;以经纬度(23.157 113.273)为例子，二进制编码长度取10位，编码过程如下：&lt;/p&gt;
&lt;p&gt;纬度：23.157&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;编码&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;左区间&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;中位数&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;右区间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-90&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;90&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;45&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;90&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;22.5&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;45&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;22.5&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;33.75&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;45&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;22.5&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;28.125&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;33.75&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;22.5&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;25.3125&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;28.125&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;22.5&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;23.90625&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;25.3125&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;22.5&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;23.203125&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;23.90625&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;22.5&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;22.8515625&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;23.203125&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;22.8515625&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;23.0273438&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;23.203125&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;得到编码序列：1010000011&lt;/p&gt;
&lt;p&gt;经度：113.273&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;编码&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;左区间&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;中位数&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;右区间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-180&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;180&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;90&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;180&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;90&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;135&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;180&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;90&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;112.5&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;135&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;112.5&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;123.75&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;135&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;112.5&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;118.125&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;123.75&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;112.5&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;115.3125&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;118.125&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;112.5&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;113.90625&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;115.3125&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;112.5&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;113.203125&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;113.90625&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;113.203125&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;113.554688&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;113.90625&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;得到编码序列：1101000001&lt;/p&gt;
&lt;h3 id=&quot;%E7%BC%96%E7%A0%81%E7%BB%84%E5%90%88&quot; tabindex=&quot;-1&quot;&gt;编码组合&lt;/h3&gt;
&lt;p&gt;经过计算，纬度的编码序列：1010000011，经度的编码序列：1101000001。&lt;/p&gt;
&lt;p&gt;编码后得到的经纬度二进制再进行重新组合，每一个经纬度都是一组数据，纬度放奇数位，经度保存在偶数位，从左到右，下标从0开始，组合后的编码序列：11100 11000 00000 00111，转化为十进制后，分别是28 24 0 13，根据Geohas使用的Base32编码，得到的编码字符串是ws0e。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/09/base32.png&quot; alt=&quot;base32&quot; /&gt;&lt;/p&gt;
&lt;p&gt;验证编码结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/09/geohash.jpg&quot; alt=&quot;geohash&quot; /&gt;&lt;/p&gt;
&lt;p&gt;至于为什么要把经纬度分别安排在奇数和偶数位，前面提到，Geohash是基于Z阶曲线实现的，如下图所示，Z阶曲线实现中，空间被划分为多个网格，x 轴就是纬度，y轴就是经度。经度放偶数位，纬度放奇数位就是这样而来的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/09/z-line-grid.jpg&quot; alt=&quot;z-line-grid&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;redis%E4%B8%AD%E6%9F%A5%E6%89%BE%E8%B7%9D%E7%A6%BB&quot; tabindex=&quot;-1&quot;&gt;Redis中查找距离&lt;/h2&gt;
&lt;p&gt;进行了编码和数据存储之后，就可以查询中心点附近的地理位置。&lt;/p&gt;
&lt;p&gt;在Redis中的实现代码这里不展开了，有兴趣的可参考这份代码注释：&lt;a href=&quot;https://blog.huangz.me/diary/2015/annotated-redis-geo-source.html&quot;&gt;https://blog.huangz.me/diary/2015/annotated-redis-geo-source.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单的说，是这样的：&lt;/p&gt;
&lt;p&gt;1、添加的地理位置数据底层使用跳跃表保存&lt;/p&gt;
&lt;p&gt;2、利用输入的中心点和输入半径确定待搜索的区域范围对象。这个范围对象包含了满足条件的经度以及对应的能覆盖目标区域的九宫格区域（目标是为了查询八个方向，四面八方）&lt;/p&gt;
&lt;p&gt;3、遍历九宫格，根据每个geohash网格的范围框选出位置对象，最终找到满足条件的对象&lt;/p&gt;
&lt;p&gt;以上，就是本次要介绍的内容，从实践和原理上分析了geohash算法实现距离查找的功能，了解了原理，使用起来就更加随心应手。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;https://en.wikipedia.org/wiki/Geohash&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://halfrost.com/go_spatial_search/&quot;&gt;https://halfrost.com/go_spatial_search/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/LBSer/p/3310455.html&quot;&gt;https://www.cnblogs.com/LBSer/p/3310455.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://redis.io/commands#geo&quot;&gt;https://redis.io/commands#geo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Z-order_curve&quot;&gt;https://en.wikipedia.org/wiki/Z-order_curve&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.huangz.me/diary/2015/annotated-redis-geo-source.html&quot;&gt;https://blog.huangz.me/diary/2015/annotated-redis-geo-source.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000020977911&quot;&gt;https://segmentfault.com/a/1190000020977911&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>你真的知道什么是线程安全吗？</title>
    <link href="https://hoohack.me/blog/2020/2020-09-01-what-is-thread-safe/"/>
    <updated>2020-09-01T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2020/2020-09-01-what-is-thread-safe/</id>
    <content type="html">&lt;p&gt;如果面试官问你，线程安全的类有哪些，究竟什么是线程安全？你怎么回答呢？我们整天说线程安全，但你真的知道什么是线程安全吗？&lt;/p&gt;
&lt;h2 id=&quot;%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B&quot; tabindex=&quot;-1&quot;&gt;什么是进程&lt;/h2&gt;
&lt;p&gt;从学术上理解，进程就是&lt;code&gt;包含上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另一个简单的理解，进程就是程序的一次执行，比如看看一下这个图，每一个运行中的程序就是一个独立的进程，进程是相互独立存在的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/09/mac-monitor.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B&quot; tabindex=&quot;-1&quot;&gt;什么是线程&lt;/h2&gt;
&lt;p&gt;线程就是CPU执行那一部分的一个个小段，线程是CPU的基本调度单位。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：平时大家说“因为Redis是单线程的，所以它是原子性的”，根本原因是，因为线程是CPU的最小调度单元，CPU每次只能执行成功或者失败才调度切换到下一个线程，所以Redis的操作都是原子的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。&lt;/p&gt;
&lt;h2 id=&quot;%E5%A0%86%E5%92%8C%E6%A0%88&quot; tabindex=&quot;-1&quot;&gt;堆和栈&lt;/h2&gt;
&lt;p&gt;进程与线程中比较重要的内存区域有堆和栈。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;堆&lt;/strong&gt;是进程和线程共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是用完了要还给操作系统，要不然就是内存泄漏。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在Java中，堆是Java虚拟机所管理的内存中最大的一块，是所有线程共享的一块内存区域，在虚拟机启动时创建。堆所存在的内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;栈&lt;/strong&gt;是每个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是线程安全的。操作系统在切换线程的时候会自动切换栈。栈空间不需要在高级语言里面显式的分配和释放。&lt;/p&gt;
&lt;h2 id=&quot;%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE&quot; tabindex=&quot;-1&quot;&gt;进程和线程中的数据&lt;/h2&gt;
&lt;p&gt;程序几乎都需要与数据打交道，读取数据（命令行参数，文件），写入数据（设置变量，写入文件）。这些数据是保存在进程所管理的内存里。&lt;/p&gt;
&lt;p&gt;为了保证数据的安全，比如一个进程中修改的数据不会影响到另一个进程的数据，每一个进程都会拥有操作系统分配给自己的内存空间，而不能访问其他进程的数据，这一点是由操作系统保证的。&lt;/p&gt;
&lt;p&gt;进程占有的资源：地址空间，全局变量，打开的文件，子进程，信号量，账户信息&lt;/p&gt;
&lt;p&gt;线程占有的资源：栈，寄存器，状态，程序计数器&lt;/p&gt;
&lt;p&gt;进程是操作系统进行资源分配和调度的一个独立单位，不会共享资源，通过进程间通信共享资源，而线程可以共享部分资源，独自占有的资源不共享。&lt;/p&gt;
&lt;p&gt;线程间共享的数据包括：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1、堆&lt;/li&gt;
&lt;li&gt;2、进程代码段&lt;/li&gt;
&lt;li&gt;3、进程的公有数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于线程间共享的内存区域，如果进程中的A线程操作了数据，切换到B线程执行，修改了同样的数据，回到A线程时，数据就不是A线程切换时候的样子，这样一来，数据就被污染了，我们就说这块数据在多线程环境下是不安全的，即线程不安全的。&lt;/p&gt;
&lt;p&gt;这就是线程安全这个概念产生的背景，笔者认为，谈论线程安全性，一定需要先介绍操作系统中进程与线程操作内存的过程，否则，说一个对象是安全的还是不安全的就显得有点突兀，而且相对于什么是安全的也不知道。&lt;/p&gt;
&lt;h2 id=&quot;%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7&quot; tabindex=&quot;-1&quot;&gt;线程安全性&lt;/h2&gt;
&lt;p&gt;《Java并发编程实战》给出的定义如下：
一个对象是否需要是线程安全的，取决于它是否被多个线程访问。这只和对象在程序中是以何种方式被使用的有关，和对象本身具体是做什么的无关。&lt;/p&gt;
&lt;p&gt;当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。&lt;/p&gt;
&lt;p&gt;线程安全的程序不一定是由线程安全的类组成，完全由线程安全类组成的程序也不一定是线程安全的。还需要一定的组合技巧才能保证线程安全。&lt;/p&gt;
&lt;p&gt;要编写线程安全的代码，其核心在于要对对象状态访问操作进行管理，特别是对共享的（Shared）和可变的（Mutable）状态的访问，即数据的访问，而数据是存储在内存中，也就是说，线程安全的本质不是代码在线程中的安全，而是线程中内存的安全。&lt;/p&gt;
&lt;p&gt;至此，线程安全的概念介绍完毕，&lt;strong&gt;最后的最后，你知道有哪些方法可以保证线程安全吗？&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;分享一个学习方法，带着问题去看书。有时候看一本书，从头到尾看完确实非常枯燥无味，且很容易就放弃了，最近想到一个方法就是带着问题去看，比如《Java并发编程实战》，据说是Java并发编程的神书，但是很枯燥，而且中文版也难懂，看了好多次之后没能进入状态，后来就想着，能不能去网上看看一些面试题，看看这本书究竟能给我解答什么疑惑，怀着这样的心情，就把前三章看完了。&lt;/p&gt;
&lt;p&gt;带着问题去看，目的性较强，更容易去理解，再通过自己的语言描述出来，印象就更深刻了。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Java项目如何分层</title>
    <link href="https://hoohack.me/blog/2020/2020-08-07-how-java-project-stratify/"/>
    <updated>2020-08-07T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2020/2020-08-07-how-java-project-stratify/</id>
    <content type="html">&lt;p&gt;在现在的Java项目中的项目分层，大多数都是简单的Controller、Service、Dao三层，看起来非常简单。&lt;/p&gt;
&lt;p&gt;但是，随着代码越写越多，写久了以后，渐渐发现其实并没有把他们真正的职责区分开来，大多数情况下，Controller只是简单的调用Service中的方法，然后就返回；Service之间组合起来处理业务逻辑，甚至有时候Service页只是Dao层的一次简单透传转发。在项目庞大，追求快速发展的情况下，往往不会过于在乎这些细节，所以大部分人都觉得无所谓了，能用就行，久而久之，层级关系逐渐混乱，维护起来就会觉得挺头疼，而且后续如果要扩展业务功能的时候也无法复用。&lt;/p&gt;
&lt;p&gt;在很多人眼里，分层这个都无所谓的，新建一个项目的时候都是从一个项目拷过来，反正能运行就行，大家都是这么写，我也这么写就好了，先跑起来再说。&lt;/p&gt;
&lt;p&gt;然而每个人的习惯都不一样，有的人习惯在Controller中写一大堆业务逻辑，有的人习惯在Controller里返回Service层的调用，去改别人代码的时候就会很纠结，究竟使用什么风格好呢？特别是一些其他语言转过来的新手往往会疑惑，究竟Controller、Service、Dao这些的区别是什么？应该怎么布局代码呢？当看到代码里的Service大部分都是Dao的封装，就会觉得在Controller里面调用各个Service的方法来处理业务逻辑也是没毛病的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本人不会觉得任何一种做法有任何问题的，以笔者自己亲身经历而言，项目要快速发展或者开发压力较大的情况下，绝对不会反对，也不会嘲笑任何一种做法，但是等到项目稍微稳定或者有时间停下来思考的时候，可以认真思考一下各个层之间的职责和关系，制定一个约定俗成的风格，大家遵循这种风格开发。个人认为风格是没有绝对的好与坏，只要团队里大家统一，那就可以了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;讲了那么多文字，先来点代码更实际一点。以笔者个人比较倾向使用的应用分层，通过以下代码示例来介绍一个好的分层应该是怎么样的。&lt;/p&gt;
&lt;h2 id=&quot;%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B&quot; tabindex=&quot;-1&quot;&gt;代码示例&lt;/h2&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@RestController&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UserController&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Autowired&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UserService&lt;/span&gt; userService&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HttpResult&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getUserInfo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Parameter&lt;/span&gt; parameter&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        parameter&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;validateArgs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; userService&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getUserInfo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;parameter&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getUserId&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Service&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UserService&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Autowired&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UserManager&lt;/span&gt; userManager&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UserInfoDTO&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getUserInfo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; userId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;userManager&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isExists&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;userId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; userManager&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getUserInfo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;userId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Component&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UserManager&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Autowired&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UserDao&lt;/span&gt; userDao&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UserInfoDTO&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getUserInfo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; userId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token class-name&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;UserDO&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; userDO &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;ofNullable&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;userDao&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;queryUserById&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;userId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; userDO&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;ifPresent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;v &lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UserInfoDTO&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;v&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;orElse&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Exception&lt;/span&gt; e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            log&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;exception, {}, &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; userId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getUserInfo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; userId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; userDao&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;countUser&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;userId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Exception&lt;/span&gt; e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            log&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;exception, {}, &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; userId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UserDao&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Select&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;SELECT count(*) FROM t_user WHERE userId = #{userId}&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;countUser&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Param&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;userId&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; userId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Select&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;SELECT * FROM t_user WHERE userId = #{userId}&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token class-name&quot;&gt;UserDO&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;queryUserById&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Param&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;userId&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; userId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;%E9%98%BF%E9%87%8C%E8%A7%84%E8%8C%83&quot; tabindex=&quot;-1&quot;&gt;阿里规范&lt;/h2&gt;
&lt;p&gt;在互联网里，阿里在Java领域还是比较权威，所以笔者参考的是阿里分层规范，规范如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/08/alibaba-project-stratify.jpg&quot; alt=&quot;阿里项目分层规范&quot; /&gt;&lt;/p&gt;
&lt;p&gt;开放接口层:可直接封装Service接口暴露成RPC接口;通过Web封装成http接口;网关控制层等。&lt;/p&gt;
&lt;p&gt;终端显示层:各个端的模板渲染并执行显示层。当前主要是velocity渲染，JS渲染，JSP渲染，移动端展示层等。&lt;/p&gt;
&lt;p&gt;Web层:主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。&lt;/p&gt;
&lt;p&gt;Service 层:相对具体的业务逻辑服务层。&lt;/p&gt;
&lt;p&gt;Manager 层:通用业务处理层，它有如下特征:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;对第三方平台封装的层，预处理返回结果及转化异常信息;&lt;/li&gt;
&lt;li&gt;对Service层通用能力的下沉，如缓存方案、中间件通用处理;&lt;/li&gt;
&lt;li&gt;与DAO层交互，对DAO的业务通用能力的封装。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;DAO 层:数据访问层，与底层 MySQL、Oracle、Hbase 进行数据交互。&lt;/p&gt;
&lt;p&gt;外部接口或第三方平台:包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。&lt;/p&gt;
&lt;p&gt;以上图文来自于阿里开发手册，而笔者个人的理解是这样的：&lt;/p&gt;
&lt;p&gt;Web层，就是Http的Controller/Thrift的TService层，主要是暴露给前端/内部部门的接口，里面做的是访问控制的转发，完成基本的参数校验，token校验等等，不做任何业务逻辑处理。&lt;/p&gt;
&lt;p&gt;Service层，处理具体的业务逻辑，通常是一个功能/接口对应一个Controller，Controller调用Service的业务方法。&lt;/p&gt;
&lt;p&gt;Manager层，对所有需要RPC调用的封装，包括但不限于内部接口调用、Dao调用、Redis调用，以及上述调用的异常封装、数据转换；这一层是最适合做复用逻辑抽象的，其他Service也可以调用封装好的Manager。&lt;/p&gt;
&lt;p&gt;Dao层，封装数据库层，映射到DB的表和实体类。&lt;/p&gt;
&lt;h2 id=&quot;%E5%88%86%E5%B1%82%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2&quot; tabindex=&quot;-1&quot;&gt;分层领域模型的转换&lt;/h2&gt;
&lt;p&gt;阿里规范文档还给了领域模型规范的参考：&lt;/p&gt;
&lt;p&gt;DO(Data Object):与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。&lt;/p&gt;
&lt;p&gt;DTO(Data Transfer Object):数据传输对象，Service 和 Manager 向外传输的对象。&lt;/p&gt;
&lt;p&gt;BO(Business Object):业务对象。可以由 Service 层输出的封装业务逻辑的对象。&lt;/p&gt;
&lt;p&gt;QUERY:数据查询对象，各层接收上层的查询请求。注:超过 2 个参数的查询封装，禁止 使用 Map 类来传输。&lt;/p&gt;
&lt;p&gt;VO(View Object):显示层对象，通常是 Web 向模板渲染引擎层传输的对象。&lt;/p&gt;
&lt;p&gt;规范并不一定是全对的，如果按照上面的数据模型操作，那么数据从数据库读取出来到真正展示到接口层，将经历3-4次的数据实体转换，而这些转换大多是重复的，甚至还会因为漏掉设置某个属性而出现意想不到的bug。所以还是具体情况具体分析，有一条基本原则就是&lt;strong&gt;Controller/TService与Dao的数据不能直接互传&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;以上就是本文要介绍的内容，对于业务发展比较稳定的团队，或者没有任何历史代码的团队，项目的分层还是很有必要的，对于之后代码的可维护性及复用性都有很大的帮助。&lt;/p&gt;
&lt;p&gt;另外，再次重申，所有的风格都没有绝对的好与坏，只要适合团队，统一使用，那就是好的风格。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Raft探索历程--Part2</title>
    <link href="https://hoohack.me/blog/2020/2020-07-04-exploring-raft-part-2/"/>
    <updated>2020-07-04T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2020/2020-07-04-exploring-raft-part-2/</id>
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;声明：本系列文章面向的读者需要看过Raft论文或者对Raft有一定的了解，如果没有看过论文或者不了解Raft，建议先去学习后再来看，否则会比较难懂。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;紧接着&lt;a href=&quot;https://www.hoohack.me/2020/06/21/exploring-raft-part-one&quot;&gt;上一篇&lt;/a&gt;的内容，继续探索Raft的leader选举、日志复制、安全性等等实现细节。&lt;/p&gt;
&lt;h2 id=&quot;raft%E5%9F%BA%E7%A1%80&quot; tabindex=&quot;-1&quot;&gt;Raft基础&lt;/h2&gt;
&lt;p&gt;一个Raft集群通常包含多个机器，比较普遍的Raft集群组成是2F+1，F代表的是可以发生失败的机器数量。比如集群有5台机器，那么Raft只能容忍两台服务失败，如果三台服务不能工作了，那么整个集群也就失败了。大多数Raft集群的机器数量都是5个。&lt;/p&gt;
&lt;p&gt;每台机器都有三个状态：leader、follower、candidate，如下图所示，就是三种状态之间的转换图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/07/raft-state-exchange.jpg&quot; alt=&quot;Raft三种状态转换图&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;leader接收所有的请求，如果client请求到了follower，那么follower会将请求转发到leader&lt;/li&gt;
&lt;li&gt;follower只是接收来自leader和candidate的请求，不会主动发起请求。如果follower没有收到任何通信或信号，转变为candidate，然后重新进行一轮新的选举&lt;/li&gt;
&lt;li&gt;candidate，是在选举新leader时出现的状态，如果candidate收到来自大多数机器的投票请求(RequestVote RPC，以下称为RequestVote请求)，就会转变为leader&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Raft把时间按照term划分，每个term以一次选举开始，如果某一个candidate成为新的leader后，就进入正常运行阶段，如果没有选举出新的leader，那么就再次进行一次新的选举，这时候又是一个新的term。简单地说，在Raft中，是以term做时间单位。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/07/raft-time-unit.jpg&quot; alt=&quot;Raft时间单位&quot; /&gt;&lt;/p&gt;
&lt;p&gt;每一个服务器都会保存当前的term序号，当前的term序号会在服务器通信之间传递。如果服务器收到的请求包含了旧的term，服务器会拒绝该请求。&lt;/p&gt;
&lt;h2 id=&quot;leader%E9%80%89%E4%B8%BE&quot; tabindex=&quot;-1&quot;&gt;leader选举&lt;/h2&gt;
&lt;p&gt;再来看看Raft是如何进行leader选举的，Raft使用心跳机制来触发leader选举。当服务器启动的时候，初始状态是follower，leader发送心跳的方式是发起一个不包含日志条目的AppendEntries RPC（以下称为Append请求）到所有的follower，follower收到来自leader的心跳请求包，说明leader还在&amp;quot;存活&amp;quot;着，如果长时间没有收到leader的心跳，那么follower就会认为当前没有leader，转为candidate，然后发起一次新的leader选举。&lt;/p&gt;
&lt;p&gt;当leader选举开始时，follower会将当前的term自增，随后马上进入candidate状态，并发起一次RequestVote请求到所有机器，请求其他机器对它进行投票。Raft集群中的服务器在一个term里，除了投给自己之外，只能投票给一个candidate。&lt;/p&gt;
&lt;p&gt;如果有以下三种情况发生，candidate的状态就会发生转变：
1、candidate获得大多数服务器的投票，成为leader，此时leader会马上发出心跳消息包，通知其他机器它成为了leader
2、candidate收到来自其他机器的心跳消息包，且该心跳包含的term大于当前candidate的term，说明已经有新的leader产生，candidate转为follwoer。（如果心跳包含的term小于当前candidate的term，candidate会直接忽略该心跳）。
3、所有的candidate在一段时间内都没能成功获得大多数投票，该次选举被认为超时，candidate会重新进行一次选举。但是如果没有其他的限制，多个follower同时成为candidate，candidate就会同时发出RequestVote请求，投票就会被分散到多个candidate上，因此没有candidate赢得选举，选举超时，再发起一次选举又是相同的结果，就会进入一个超时导致没有leader的死循环。&lt;/p&gt;
&lt;p&gt;为了解决第三种情况，Raft用了随机超时时间来确保投票分散的情况不会发生。随机超时时间的意思就是，Raft的超时时间是在一个区间（如150-300ms）里面选择，而不是固定的一个时间单位。这样一来，大部分情况下就只有一个服务器会超时。另外，在超时之后，Raft使用随机时间来启动一次新的选举，这样就不会出现所有的candidate同时开始重新选举而导致进入选举超时的死循环。&lt;/p&gt;
&lt;p&gt;这个随机超时时间机制简单且有效地解决这个死循环的问题。&lt;/p&gt;
&lt;h2 id=&quot;%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6&quot; tabindex=&quot;-1&quot;&gt;日志复制&lt;/h2&gt;
&lt;p&gt;Raft是保证分布式系统数据一致性的协议，主要的工作就是接收客户端的数据，并同步数据，保证所有节点的数据一致。&lt;/p&gt;
&lt;h3 id=&quot;%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B&quot; tabindex=&quot;-1&quot;&gt;日志复制流程&lt;/h3&gt;
&lt;p&gt;论文里面多次提到的log是RAFT系统中要同步的数据，称为日志条目，日志的格式如下图所示，每个日志包含要执行的指令、term和日志的下标，保存term的目的是为了及时发现日志之间的不一致性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/07/raft-log-structure.jpg&quot; alt=&quot;Raft日志格式&quot; /&gt;&lt;/p&gt;
&lt;p&gt;leader选举出来后，leader就开始正常工作，接受来自客户端的请求，客户端的请求包含了需要执行的指令，leader收到客户端的指令后，把指令作为日志条目(log entry)保存起来，同时发送Append请求到所有的follower，通知它们同步该日志条目，同步完成后，请求返回成功。如果大多数服务器都完成了日志的同步，leader认为这个指令是可以commit的，commit时会检查所有的日志，会将上一个term产生的可提交的日志一并提交（下面会提到），然后leader就会将可提交的日志里面的指令执行到状态机，并把返回结果给客户端。&lt;/p&gt;
&lt;p&gt;如果follower同步过程比较缓慢（比如超时、网络缓慢、响应丢失），leader会一直重试Append请求，直到所有的follower成功保存了所有的日志条目。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里要注意的是，即使leader已经给客户端响应了，leader还是会重试，这个是合理的，因为只要leader给客户端响应了，说明该日志条目是可提交的，剩下的工作就是保证日志同步到所有的follower。对于follower而言，一个日志条目被复制了，还是需要被执行，只有在follower意识到该条目是可提交的，才会将它真正执行到follower的状态机。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面描述的日志复制流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/07/raft-leader-log-replicate.jpg&quot; alt=&quot;Raft日志复制流程&quot; /&gt;&lt;/p&gt;
&lt;p&gt;1、client发起指令&lt;/p&gt;
&lt;p&gt;2、leader收到指令，发起Append请求到所有follower&lt;/p&gt;
&lt;p&gt;3、follower同步日志到本地&lt;/p&gt;
&lt;p&gt;4、follower操作完成，返回给leader&lt;/p&gt;
&lt;p&gt;5、如果大多数的follower完成同步，leader返回响应给client&lt;/p&gt;
&lt;h3 id=&quot;%E6%97%A5%E5%BF%97%E5%8C%B9%E9%85%8D%E7%89%B9%E6%80%A7&quot; tabindex=&quot;-1&quot;&gt;日志匹配特性&lt;/h3&gt;
&lt;p&gt;关于日志，Raft实现并维护了以下两个特性：&lt;/p&gt;
&lt;p&gt;1、如果两个日志条目有相同的下标和term，那么它们保存的指令是一样的&lt;/p&gt;
&lt;p&gt;2、如果两个日志条目有相同的下标和term，那么在它们之前的日志都是一样的&lt;/p&gt;
&lt;p&gt;这两个特性共同构成了Raft的日志匹配特性。如果两个日志条目有相同的下标和term，那么这些日志都是相同的。在Raft中，leader在某个term的某个下标最多只会创建一个日志条目，且它的下标不会发生变化。每一次Append请求时都会做一致性检查（follower在收到Append请求时，如果发现前一个日志条目的下标和term与请求包含prevLogIndex与prevLogTerm的不一致，follower会拒绝该请求）。Raft通过以上操作来维护日志匹配特性，从而保证了日志条目的一致性。&lt;/p&gt;
&lt;h3 id=&quot;%E6%97%A5%E5%BF%97%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7&quot; tabindex=&quot;-1&quot;&gt;日志的一致性&lt;/h3&gt;
&lt;p&gt;正常情况下，leader与follower的数据是保持一致的，但是如果leader突然挂了，可能会导致数据出现不一致。&lt;/p&gt;
&lt;p&gt;在Raft里面，leader通过强制follower直接复制leader的日志条目来解决数据不一致的问题，如果follower与leader的日志条目不一样，那么follower只认leader的数据，本地的数据会被leader的数据覆盖。&lt;/p&gt;
&lt;p&gt;leader为每个follower维护一个nextIndex（leader即将发给follower的下一个日志条目的下标），在Append请求执行时，如果发现follower的log与leader的不一致，follower会拒绝该请求，leader收到拒绝的响应，会将拒绝的follower的nextIndex减一，然后再发起一次Append请求，如果Append请求成功，leader和follower在该下标位置上的日志条目就一致了，且在接下来的任期里，这个日志会一直保持。&lt;/p&gt;
&lt;p&gt;有了日志复制的功能，leader不需要其他任何操作就能恢复数据的一致性，leader不会删除或覆盖自己的日志条目，只需要正常的执行，在Append请求失败时会自动检查一致性，最终达到一致。&lt;/p&gt;
&lt;p&gt;日志复制的机制也展示了Raft的特性：只要大多数机器都是正常运行的情况下，Raft会接收、复制和执行新的日志条目；正常情况下，经过一次RPC后新的日志条目都可以被复制到大多数机器；单个机器超时不会影响整体的性能。&lt;/p&gt;
&lt;h2 id=&quot;%E5%AE%89%E5%85%A8%E6%80%A7&quot; tabindex=&quot;-1&quot;&gt;安全性&lt;/h2&gt;
&lt;p&gt;前面介绍了leader的选举和日志的复制，但仅靠这两个机制还不能有效地保证每一台状态机使用相同的顺序执行相同的命令。比如在仅有这两种机制的前提下，遇到一些异常的情况，日志就会乱序或者被其他当选的leader覆盖，因此还需要一些其他的机制来保障数据的一致性。&lt;/p&gt;
&lt;h3 id=&quot;%E9%80%89%E4%B8%BE%E9%99%90%E5%88%B6&quot; tabindex=&quot;-1&quot;&gt;选举限制&lt;/h3&gt;
&lt;p&gt;在Raft里的第一个限制：限制日志的流向只能从leader到follower，且leader不会覆盖已经存在的日志条目。&lt;/p&gt;
&lt;p&gt;第二个限制，是选举leader时候的投票限制，candidate包含了所有已提交的日志条目才能被选上leader。&lt;/p&gt;
&lt;p&gt;每一次选举leader，candidate都会向其他机器发起请求，获得每个机器最新的日志条目信息，如果candidate的日志比大多数机器的版本还新，那么它就能被选上leader。&lt;/p&gt;
&lt;p&gt;日志版本是最新的定义为：如果两条日志最大下标的term不相同，那么term较大者胜出；如果两条日志最大下标相同，那么日志长度较大者胜出。可以用以下逻辑描述：&lt;/p&gt;
&lt;p&gt;有机器s1，s2，定义机器包含的日志log，log里面最新的日志下标为lastIndex，log的长度为log.length，通过以下的逻辑可以判断日志是否最新：&lt;/p&gt;
&lt;pre class=&quot;language-go&quot;&gt;&lt;code class=&quot;language-go&quot;&gt;	log1 &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; s1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;log&lt;br /&gt;	log2 &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; s2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;log&lt;br /&gt;&lt;br /&gt;	&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; log1&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;lastIndex&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;term &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; log2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;lastIndex&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;term &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; log1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;term &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; log2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;term &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt;&lt;br /&gt;		log1&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;lastIndex&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;term &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; log2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;lastIndex&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;term &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; log1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; log2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length &lt;br /&gt;	then&lt;br /&gt;		s1 win&lt;br /&gt;	&lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt;&lt;br /&gt;		s2 win&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;%E6%8F%90%E4%BA%A4%E4%B9%8B%E5%89%8Dterm%E7%9A%84%E6%97%A5%E5%BF%97%E6%9D%A1%E7%9B%AE&quot; tabindex=&quot;-1&quot;&gt;提交之前term的日志条目&lt;/h3&gt;
&lt;p&gt;前面提到，如果一个日志被复制到大多数机器，那么leader就认为该日志是可提交的，但是，如果leader提交该日志前崩溃了，就会出现意想不到的现象，举个例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/07/raft-leader-crash-before-commit.jpg&quot; alt=&quot;leader在提交前挂了&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如图所示的场景：
a、S1被选中leader，在index=2处复制日志进行到一半（只在S2进行了）
b、S1挂了，通过S3、S4和自己的投票，S5被选中leader，term=3，在index=2的地方接收了一个与S1不同的日志
c、S5挂了，S1重新启动，被选中为leader，term=4，但是会继续它上一次的复制，term=2，index=2的日志复制到S3，此时这条日志已经被复制到大多数机器，被认为可以提交的，此时准备进行提交&lt;/p&gt;
&lt;p&gt;以下两种是假设的情景：
如果
d、S1挂了，S5可以被选为leader，复制步骤b的数据，此时index=2的数据就被S5覆盖了&lt;/p&gt;
&lt;p&gt;如果
e、如果S1在挂了之前复制了当前term收到的日志数据（index=3，term=4）到大多数机器，而根据投票的限制，S5不能被选为leader，因为log5[3].term &amp;lt; log3[3].term。复制到大多数机器后，这条数据可以被提交，提交时它之前的日志条目也会被一并提交&lt;/p&gt;
&lt;p&gt;上面的d、e是假设的场景，为了避免上面描述的问题，Raft有另一个限制，&lt;em&gt;leader不会提交前一个term被认为可以提交的日志，只能提交当前term认为可以被提交的日志&lt;/em&gt;。由于日志匹配特性，Raft会在提交当前term的日志时，把之前term可提交的日志间接地一并提交（如果两个日志条目有相同的下标和term，那么在它们之前的日志都是一样的，所以leader必须把上一个可提交的日志提交了，否则就会出现leader或follower之间的数据不一致）。&lt;/p&gt;
&lt;p&gt;leader提交日志时的操作是：&lt;/p&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; entry in &lt;span class=&quot;token function&quot;&gt;GetEntries&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;lastCommited&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; newCommited&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;br /&gt;   entry&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;Commit&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过选举条件限制和leader只能提交当前term的日志的限制，就不会出现上面途中描述的问题。&lt;/p&gt;
&lt;p&gt;根据Raft算法的基础，可以论证leader完整性特性，可以进一步证明状态机，详细的论证过程就不翻译了，如果有兴趣的话可以翻阅论文。&lt;/p&gt;
&lt;h2 id=&quot;follower%E5%92%8Ccandidate%E5%B4%A9%E6%BA%83&quot; tabindex=&quot;-1&quot;&gt;follower和candidate崩溃&lt;/h2&gt;
&lt;p&gt;follower或candidate崩溃处理方式是一样的，如果follower/candidate崩溃了，那么后续的Append请求或者RequestVote请求就会失败。Raft的实现是不断重试这些请求，直到机器重新启动。（Raft的RPC请求是幂等的，所以重复的RPC不会影响系统。）&lt;/p&gt;
&lt;h2 id=&quot;%E6%97%B6%E9%97%B4%E5%92%8C%E5%8F%AF%E7%94%A8%E6%80%A7&quot; tabindex=&quot;-1&quot;&gt;时间和可用性&lt;/h2&gt;
&lt;p&gt;为了保证Raft系统的高可用，Raft要求安全性不会受执行时间的影响，即，系统不会由于机器的响应时间出现异常的结果。因为需要一个稳定的leader来保证Raft系统的正常运行。&lt;/p&gt;
&lt;p&gt;Raft有三个时间属性&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;broadcastTime: 服务器发出rpc到收到响应的时间，通常是0.5～20ms，因为rpc需要将数据持久化到本地&lt;/li&gt;
&lt;li&gt;electTimeout: 选举leader超时时间，10～500ms&lt;/li&gt;
&lt;li&gt;MTBF：机器平均故障时间，通用以月为单位&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过以下的时间表达式，Raft可以保证leader的稳定性：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;broadcastTime&amp;lt;=electionTimeout&amp;lt;=MTBF&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1、因为Raft需要依赖心跳包来维持一个leader，所以broadcastTime&amp;lt;=electionTimeout&lt;/p&gt;
&lt;p&gt;2、为了保持系统稳定，electionTimeout&amp;lt;=MTBF&lt;/p&gt;
&lt;h2 id=&quot;%E8%A7%A3%E7%AD%94q%26a&quot; tabindex=&quot;-1&quot;&gt;解答Q&amp;amp;A&lt;/h2&gt;
&lt;p&gt;上一次留下的一个问题：&lt;/p&gt;
&lt;p&gt;Q1：在leader选举过程中，candidate是怎么决定要投票给发起RequestVote Rpc的机器？是不是接收到请求就要投票？成为leader有没有什么要求？&lt;/p&gt;
&lt;p&gt;这个问题在选举限制部分讲到，一次选举leader，candidate都会向其他机器发起请求，获得每个机器最新的日志条目信息，如果candidate的日志比大多数机器的版本还新，那么它就能被选上leader。&lt;/p&gt;
&lt;p&gt;日志版本是最新的定义为：如果两条日志最大下标的term不相同，那么term较大者胜出；如果两条日志最大下标相同，那么日志长度较大者胜出。即：&lt;/p&gt;
&lt;pre class=&quot;language-go&quot;&gt;&lt;code class=&quot;language-go&quot;&gt;	log1 &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; s1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;log&lt;br /&gt;	log2 &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; s2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;log&lt;br /&gt;&lt;br /&gt;	&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; log1&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;lastIndex&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;term &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; log2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;lastIndex&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;term &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; log1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;term &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; log2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;term &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt;&lt;br /&gt;		log1&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;lastIndex&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;term &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; log2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;lastIndex&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;term &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; log1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; log2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length &lt;br /&gt;	then&lt;br /&gt;		s1 win&lt;br /&gt;	&lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt;&lt;br /&gt;		s2 win&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q2：日志匹配特性与leader提交时要提交上一个term可提交的日志有什么关联？&lt;/p&gt;
&lt;p&gt;回顾一下日志匹配特性：&lt;/p&gt;
&lt;p&gt;1、如果两个日志条目有相同的下标和term，那么它们保存的指令是一样的&lt;/p&gt;
&lt;p&gt;2、如果两个日志条目有相同的下标和term，那么在它们之前的日志都是一样的&lt;/p&gt;
&lt;p&gt;如果leader不提交了上一个term的日志，会出现数据不一致，无法维持日志匹配特性第二部分。&lt;/p&gt;
&lt;p&gt;举个例子，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/07/raft-log-match.jpg&quot; alt=&quot;Raft日志复制解释&quot; /&gt;&lt;/p&gt;
&lt;p&gt;假设有5台机器，如果在term2时，S1是leader，大多数机器都复制了下标2的日志，此时S4、S5并没有数据，提交之前S1挂了，然后term3时S3被选为leader，大多数机器都复制了下标3的日志，此时leader（S3）提交了下标3的日志，但是不提交下标2的数据。那么S4只能收到index=3，term=3的数据，那么就会出现S1、S4的index=3，term=3之前的日志数据不一致了。&lt;/p&gt;
&lt;p&gt;如果term3时把下标2到下标3之间的数据都提交了，leader在复制时发现日志不一致，就会强制使用leader的数据，就不会出现这个问题。就符合日志匹配特性了。&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;到这里为止，本次探索Raft的历程告一段落，这一次的探索，收获颇深，日志复制和leader应该算是Raft中最难的部分，反复阅读论文和上网查阅资料，终于搞懂了遇到的难题。&lt;/p&gt;
&lt;p&gt;Raft通过选举限制确保了成为leader的机器必须是拥有最新数据的，避免了数据被覆盖的情况；通过提交时提交之前term的日志满足日志匹配特性；通过数据的一致性检查保证了leader与follower之间的数据一致性。总的来说，Raft通过限制和规定，保证了系统的稳定运行和数据一致性，这也是协议的功能，使用该协议的系统必须遵从这些约定才能正常的运作。&lt;/p&gt;
&lt;p&gt;下一次再继续探索集群关系变化、日志压缩处理等等话题。&lt;/p&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://groups.google.com/forum/#!topic/raft-dev/d-3XQbyAg2Y&quot;&gt;Question about Committing entries from previous terms&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32052223&quot;&gt;Raft算法详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xybaby/p/10124083.html&quot;&gt;一文搞懂Raft算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Raft探索历程--Part1</title>
    <link href="https://hoohack.me/blog/2020/2020-06-21-exploring-raft-part-one/"/>
    <updated>2020-06-21T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2020/2020-06-21-exploring-raft-part-one/</id>
    <content type="html">&lt;h2 id=&quot;%E5%89%8D%E8%A8%80&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;Raft是一个保证分布式系统数据一致性的共识算法，诞生的目的就是为了探索一种更容易理解的共识算法，原因是上一个描述这个算法的协议--Paxos较难理解和在生产环境上使用。（注：笔者没有掌握Paxos算法，所以这里不会去作比较，后续如果学习到的话会做一个比较）&lt;/p&gt;
&lt;p&gt;笔者主要是通过阅读&lt;a href=&quot;https://raft.github.io/raft.pdf&quot;&gt;Raft论文&lt;/a&gt;和观看&lt;a href=&quot;https://www.bilibili.com/video/BV1R7411t71W?p=7&quot;&gt;MIT 6.824的教程视频&lt;/a&gt;学习的。&lt;/p&gt;
&lt;p&gt;论文原文是英文版的，里面的一些专用名词笔者打算尽量保留英文的描述，因为这些关键名词对于理解概念十分重要，但是翻译过来会比较拗口，也找不到合适的中文名词代替，所以打算保留英文的描述，当然，名词的含义还是有必要先解释一下。&lt;/p&gt;
&lt;h2 id=&quot;%E8%8B%B1%E6%96%87%E5%90%8D%E8%AF%8D%E5%A4%87%E6%B3%A8&quot; tabindex=&quot;-1&quot;&gt;英文名词备注&lt;/h2&gt;
&lt;p&gt;Consensus algorithms：共识算法，用来保证分布式系统一致性的方法。&lt;a href=&quot;https://en.wikipedia.org/wiki/Consensus_algorithm&quot;&gt;Consensus algorithm&lt;/a&gt;
leader：节点集群中的领导者，决策者，负责复制和提交客户端的日志。
term：任期，领导者的当任时间。
candidate：准备参与leader选举的候选机器
follower：追随者，选举结束后，没有成为leader的candidate就是跟随者，接收leader的指令
majority：大多数投票机制，指集群中大多数机器同意某个节点成为leader，这里的大多数机器不只是指正在运行的服务器，即使机器投票后挂了也是majority中的一部分&lt;/p&gt;
&lt;h2 id=&quot;raft%E7%AE%80%E4%BB%8B&quot; tabindex=&quot;-1&quot;&gt;Raft简介&lt;/h2&gt;
&lt;p&gt;在MIT 6.824视频中，在Raft之前讨论了Map Reduce、GFS、VMWare FT，这些现存容错系统的处理方式&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;MapReduce系统，只是复制计算，但是依赖单master&lt;/li&gt;
&lt;li&gt;GFS，复制副本数据，依赖master另外选主&lt;/li&gt;
&lt;li&gt;VMware FT复制服务依赖test-and-set选择master&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;单点master可以避免“脑裂”，但是master始终是单点，无法实现分布式存储。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Split-brain_(computing)&quot;&gt;脑裂&lt;/a&gt;，是指一个集群中出现了网络异常的情况导致有两个节点各自都认为它们都是主节点，于是一个集群被拆分为两个集群，解决脑裂问题的方式就是添加majority机制，而Paxos和Raft就是这类解决方案中的其中两种。&lt;/p&gt;
&lt;p&gt;由于Paxos的晦涩难懂导致难以理解以及实现起来的难度，经过不断的挣扎，学者们就发明了Raft。Raft的目标是为了设计一种更易于理解的共识算法。&lt;/p&gt;
&lt;p&gt;为了让共识算法更容易理解，Raft将共识算法中的核心内容拆分开来实现：leader选举，日志复制，安全性，以及通过实施一个更强级别的一致性来减少需要考虑的状态数量。&lt;/p&gt;
&lt;p&gt;Raft跟现存的共识算法很相似，但是它有新增一些独特的特性：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Strong Leader，比如日志只能由首领发送到其他的服务器&lt;/li&gt;
&lt;li&gt;Leader Election，Raft使用随机定时器进行选举，解决冲突时更简单快捷&lt;/li&gt;
&lt;li&gt;Membership changes，使用共同共识的方法来处理集群内成员变换的问题，这种方法处理时，处于调整过程中的两种不同配置的集群中的大多数机器会重叠。这样一来，集群在成员变换阶段依然能继续运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81%E6%9C%BA&quot; tabindex=&quot;-1&quot;&gt;复制状态机&lt;/h2&gt;
&lt;p&gt;Replicated state machine，状态复制机，共识算法是在复制状态机的背景下诞生的，复制状态机用于来解决分布式系统的各种容错问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/06/raft-RSM.jpg&quot; alt=&quot;RSM&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如图，复制状态机实现方式是使用复制日志，每份日志都使用相同顺序来保存相同的指令，服务器执行时是按照日志的顺序来执行，最终得到的结果都是一致的。&lt;/p&gt;
&lt;p&gt;共识算法在复制状态机的工作就是保证所有的复制日志都是一致的。共识实现模块（如Raft）接收来自客户端的请求后，添加到机器的日志里，使用共识模块进行通信，保证所有日志最终都包含相同顺序的请求。看到这里想起了&lt;a href=&quot;https://www.hoohack.me/2017/07/11/learning-mysql-replication-detail&quot;&gt;MySQL的主从复制原理&lt;/a&gt;，有点类似复制状态机的实现方式。&lt;/p&gt;
&lt;p&gt;共识算法在实际应用中的特性：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;安全性保证，绝不返回一个错误的结果，在错误情况下都能保证正确&lt;/li&gt;
&lt;li&gt;可用性，集群中只要有大多数的机器可运行且能够相互通信，就可以保证可用。&lt;/li&gt;
&lt;li&gt;不依赖时序保证一致性&lt;/li&gt;
&lt;li&gt;通常情况下，一条指令能在集群中大多数节点响应一次远程过程调用时完成。少部分较慢的节点不会影响系统整体的性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;paxos&quot; tabindex=&quot;-1&quot;&gt;Paxos&lt;/h2&gt;
&lt;p&gt;Paxos定义了一个能够达成单一决策共识的协议，比如单条的复制日志项。主要的两个缺点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原理很难理解，完整的解释不够透明。&lt;/li&gt;
&lt;li&gt;没有提供一个较好的基础来构建一个现实中的系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;注：笔者没有深入学习过Paxo，不能更多的评论，只能从论文和视频的角度做个小总结。&lt;/p&gt;
&lt;h2 id=&quot;%E5%88%9D%E8%A1%B7--%E6%9B%B4%E5%AE%B9%E6%98%93%E7%90%86%E8%A7%A3%E7%9A%84%E8%AE%BE%E8%AE%A1&quot; tabindex=&quot;-1&quot;&gt;初衷--更容易理解的设计&lt;/h2&gt;
&lt;p&gt;Raft有很多个设计的目标：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;提供一个完整构建系统的基础&lt;/li&gt;
&lt;li&gt;高效性&lt;/li&gt;
&lt;li&gt;安全性&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;而Raft最重要的目标，也是最大的挑战，就是让有一个更容易理解的设计。核心目标就是可理解性，必须是容易理解的，即使是普通开发者也能理解。&lt;/p&gt;
&lt;p&gt;Raft的学者们意识到要达到Raft的目标非常难，所以使用了&lt;strong&gt;问题分解&lt;/strong&gt;和&lt;em&gt;通过减少状态数量&lt;/em&gt;来达到这一目的。&lt;/p&gt;
&lt;p&gt;问题分解也是平常开发中用到的一个很重要的技能，如需求拆解、实现细节拆解，把大问题拆解为小问题，然后逐个击破，最后完成目标。&lt;/p&gt;
&lt;p&gt;在大多数情况下Raft都试图去消除不确定性，但也有一些情况下增加一些不确定性可以提升系统的可理解性。比如，随机化方法增加了不确定性，但通过使用相似的方法处理所有可能的选择，有利于减少状态空间数量。系统中使用随机化去简化Raft中领导选举算法。&lt;/p&gt;
&lt;p&gt;接下来要探索Raft的设计和实现原理，包含了数据结构和函数的定义，leader选举、日志复制、安全性等拆解功能的详细设计。&lt;/p&gt;
&lt;h2 id=&quot;raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95&quot; tabindex=&quot;-1&quot;&gt;Raft共识算法&lt;/h2&gt;
&lt;p&gt;Raft是一种用来管理复制日志的共识算法。&lt;/p&gt;
&lt;p&gt;通过选举一个唯一的leader，Raft给予leader完整的责任去管理复制日志来实现共识。leader会接受来自客户端的日志条目，复制这些条目到其他服务器，leader自己就可以决定将日志条目放到哪台服务器，数据流的方向只能从leader到其他服务器。&lt;/p&gt;
&lt;p&gt;一个集群里有且只能有一台leader，leader拥有最大的权利。如果某一台leader当机了，会马上选出下一台leader。&lt;/p&gt;
&lt;p&gt;如前面提到过的，Raft将整个共识算法拆分为三个独立的子问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;leader选举：当leader挂了，会选举出新的leader&lt;/li&gt;
&lt;li&gt;日志复制：日志条目只能从leader通知到集群的其他服务器，服务器只会认leader的数据&lt;/li&gt;
&lt;li&gt;安全性：Raft的核心安全性是状态机的安全，Raft通过在选举机制增加一些限制来保证提供的状态数据都是安全的&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;如图所示是Raft的数据结构和函数的定义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/06/raft-image-2.jpg&quot; alt=&quot;raft-condense&quot; /&gt;&lt;/p&gt;
&lt;p&gt;图里是Raft算法的实现概览，定义了一个集群中维护的状态以及两个方法。方法分别是复制日志条目和请求投票，复制日志条目是在客户端发送给服务端后，由leader复制到其他的follower时调用，可被用做leader的心跳包请求。请求投票时每一个leader的选举时，candidate向其他机器返发起的请求，如果机器被选中为leader，会马上发一个心跳包出去，其他candidate会成为follower，也意味着该次term的选举结束了。&lt;/p&gt;
&lt;p&gt;下图列举了Raft算法中的关键特性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/06/raft-image-3.jpg&quot; alt=&quot;raft-properties&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Raft通过以上这些特性来保证集群里leader选举和日志复制的正常运行，同时也保证了运行的安全性。&lt;/p&gt;
&lt;p&gt;接下来继续探索Raft的实现：包括leader选举、日志复制、安全性等等，全部写完的话，涉及的篇幅较长，篇幅太长的文章会影响阅读体验，也较难消化，所以笔者打算另外开一篇文章继续。&lt;/p&gt;
&lt;p&gt;到这里为止，第一次的探索历程就暂告一个段落了，笔者想留下一个在探索过程中困惑住的问题。&lt;/p&gt;
&lt;p&gt;Q1:在leader选举过程中，candidate是怎么决定要投票给发起RequestVote Rpc的机器？是不是接收到请求就要投票？成为leader有没有什么要求？&lt;/p&gt;
&lt;p&gt;这个问题，会在下一次探索历程中给出答案。如果你有任何问题，欢迎留言。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>使用拦截器统一处理异常</title>
    <link href="https://hoohack.me/blog/2020/2020-06-13-handle-exception-in-one-place/"/>
    <updated>2020-06-13T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2020/2020-06-13-handle-exception-in-one-place/</id>
    <content type="html">&lt;p&gt;作为一个业务仔，在业务接口代码中肯定会遇到处理异常的情况，比如有代码逻辑的异常，业务逻辑的异常等等。这些异常场景是非常非常多的，这么多异常逻辑要处理，就意味着要写很多重复的代码，作为一个有点追求的业务仔，不能只是懂得CURD，当然希望代码看起来简洁、舒服一点。&lt;/p&gt;
&lt;p&gt;本文打算分享笔者处理异常情况的演进过程，然后给出统一异常处理的示例。&lt;/p&gt;
&lt;p&gt;一开始的方法是定义一个业务异常类，当捕获到业务异常时，使用异常的错误码和错误信息，构造错误提示返回。&lt;/p&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/**&lt;br /&gt;* 错误码枚举类&lt;br /&gt;*/&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ResponseCode&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;SUCCESS&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;OK&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;SERVER_ERROR&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;server error&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; code&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; msg&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token class-name&quot;&gt;ResponseCode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; code&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; msg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;code &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; code&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;msg &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; msg&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getCode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; code&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ResponseCode&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;setCode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; code&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;code &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; code&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getMsg&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; msg&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ResponseCode&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;setMsg&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; msg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;msg &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; msg&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;/**&lt;br /&gt;* 自定义业务异常类&lt;br /&gt;*/&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BizException&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;RuntimeException&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; code&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BizException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ResponseCode&lt;/span&gt; errCode&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;errCode&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getMsg&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;code &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; errCode&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getCode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BizException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ResponseCode&lt;/span&gt; errCode&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; msg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;msg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;code &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; errCode&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getCode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BizException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; code&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; msg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;msg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;code &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; code&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getCode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;code&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;TestService&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;	&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;testAMethod&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;		&lt;span class=&quot;token comment&quot;&gt;// 业务异常代码&lt;/span&gt;&lt;br /&gt;		&lt;span class=&quot;token keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BizException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ResponseCode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;BIZ_CODE&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;/**&lt;br /&gt;* 接口返回的通用结构HttpResult&lt;br /&gt;* {&quot;code&quot;: 0, &quot;msg&quot;: &quot;OK&quot;}&lt;br /&gt;*/&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;TestController&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;	&lt;span class=&quot;token annotation punctuation&quot;&gt;@Autowired&lt;/span&gt;&lt;br /&gt;	&lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;TestService&lt;/span&gt; testService&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;	&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HttpResult&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;testA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;		&lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;			testService&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;testAMethod&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;		&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;BizException&lt;/span&gt; e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;			&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HttpResult&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;e&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getCode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; e&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getMsg&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;		&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Exception&lt;/span&gt; e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;			&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HttpResult&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ResponseCode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;SERVER_ERROR&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;		&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HttpResult&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ResponseCode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;SUCCESS&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后来发现需要进行一次优化，首先，随着业务代码越来越多，这些try...catch看起来就好臃肿了。&lt;/p&gt;
&lt;p&gt;其次，在底层代码有异常时也要在外层捕获住，然后一层一层地往外抛，直到业务接口返回处返回错误信息，如果是一个业务逻辑特别复杂的接口，这些异常处理的代码就会遍布整个系统，使得这些异常代码看起来十分不美观，代码可读性也较差。&lt;/p&gt;
&lt;p&gt;久而久之，就在想是否有一种跟&lt;a href=&quot;https://www.hoohack.me/2020/04/22/common-check-with-interceptor&quot;&gt;校验拦截器&lt;/a&gt;一样的方法，在某个地方统一处理这些判断，使得代码看起来比较美观。&lt;strong&gt;答案是有的&lt;/strong&gt;，就是使用&lt;code&gt;ExceptionHandler&lt;/code&gt;和&lt;code&gt;RestControllerAdvice&lt;/code&gt;注解。&lt;/p&gt;
&lt;p&gt;首先，定义一个类：&lt;code&gt;SpringMvcExceptionDemo&lt;/code&gt;，类加上&lt;code&gt;RestControllerAdvice&lt;/code&gt;注解，类里面定义一个方法exceptionHandler，方法前面加上&lt;code&gt;ExceptionHandler&lt;/code&gt;注解，然后就可以在方法里面写异常判断逻辑，对异常逻辑进行相应的处理。&lt;/p&gt;
&lt;p&gt;具体的实现代码示例如下：&lt;/p&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;br /&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@RestControllerAdvice&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SpringMvcExceptionDemo&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token annotation punctuation&quot;&gt;@ExceptionHandler&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;exceptionHandler&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Exception&lt;/span&gt; e&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HttpServletRequest&lt;/span&gt; request&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HttpServletResponse&lt;/span&gt; response&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;e &lt;span class=&quot;token keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BizException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token class-name&quot;&gt;BizException&lt;/span&gt; be &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;BizException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; e&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HttpResult&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;be&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getCode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; be&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getMessage&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;e &lt;span class=&quot;token keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HttpResult&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ResponseCode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;PARAM_ERROR&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getCode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; e&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getMessage&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HttpResult&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ResponseCode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;SERVER_ERR&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HttpResult&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;testA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;	testService&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;testAMethod&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;	&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HttpResult&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ResponseCode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;SUCCESS&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样一来，就只需要在该抛出业务异常的地方抛出异常，由拦截器统一处理异常即可，减少了很多重复代码，同时提高代码的可读性。&lt;/p&gt;
&lt;p&gt;RestControllerAdvice 和 ExceptionHandler&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RestControllerAdvice是Spring框架中的一个注解，这个注解包含了&lt;code&gt;ControllerAdvice&lt;/code&gt;和&lt;code&gt;ResponseBody&lt;/code&gt;，帮助我们通过加入一个横切点&lt;code&gt;ExceptionHandler&lt;/code&gt;来处理RestfulAPI中的异常。执行的时机是在&lt;code&gt;doDispatch&lt;/code&gt;中，调用&lt;code&gt;processDispatchResult&lt;/code&gt;方法，如果有异常，则会调用添加了&lt;code&gt;ExceptionHandler&lt;/code&gt;注解的方法去判断。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/06/exception-handler-progress.jpg&quot; alt=&quot;统一处理异常拦截器流程&quot; /&gt;&lt;/p&gt;
&lt;p&gt;核心处理代码：&lt;/p&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;HandlerExceptionResolver&lt;/span&gt; handlerExceptionResolver &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;handlerExceptionResolvers&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;	exMv &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; handlerExceptionResolver&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;resolveException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;request&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; response&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; handler&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ex&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;	&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;exMv &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;		&lt;span class=&quot;token keyword&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;代码和原理比较简单，统一处理异常的目的只是为了消除重复的代码块，写出更简洁的代码，现在写代码也是坚持这个想法，希望能探索出更多的技巧，有其他技巧的也欢迎一起讨论。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>为什么需要分布式系统</title>
    <link href="https://hoohack.me/blog/2020/2020-06-06-why-we-need-distributed-system/"/>
    <updated>2020-06-06T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2020/2020-06-06-why-we-need-distributed-system/</id>
    <content type="html">&lt;h2 id=&quot;%E5%89%8D%E8%A8%80&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近在学习MIT6.824的分布式系统课程，正在看Raft的论文，Raft是一种共识算法(&lt;strong&gt;Consensus algorithms&lt;/strong&gt;)，共识算法是用来保证分布式系统里数据的一致性的算法，所以也可以说是一个一致性算法。&lt;/p&gt;
&lt;p&gt;在学习这个课程的过程中，发现其实对分布式系统这个概念很模糊，好像知道是什么却又好像说不出来，不禁思考起来，究竟什么是分布式系统？为什么我们需要分布式系统？这个问题也许很简单，但是还是想通过自己的语言去表达，加深印象，希望我能阐述清楚。&lt;/p&gt;
&lt;h2 id=&quot;%E5%8D%95%E6%9C%BA%E7%B3%BB%E7%BB%9F%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98&quot; tabindex=&quot;-1&quot;&gt;单机系统遇到的问题&lt;/h2&gt;
&lt;p&gt;为什么我们需要分布式系统而不是单机系统呢？一个概念或者理论的出现，都是为了解决问题，单机系统遇到的问题是什么呢？分布式系统要解决的问题主要是单机系统中系统容量不足及提高系统可用性。&lt;/p&gt;
&lt;h3 id=&quot;%E6%8F%90%E9%AB%98%E7%B3%BB%E7%BB%9F%E5%AE%B9%E9%87%8F&quot; tabindex=&quot;-1&quot;&gt;提高系统容量&lt;/h3&gt;
&lt;p&gt;随着业务越来越复杂，服务也会变得越来越复杂，单台机器的CPU、内存已经无法满足部署一个庞大系统的性能要求。当然可以通过提高系统配置暂时解决问题，但是不管如何提高系统的配置，单台机器总会达到性能瓶颈的时候，所以需要多台机器才能应对这些扩张的功能。通过水平（加机器）和垂直（拆分为多个子系统）拆分系统，变成了一个分布式架构。&lt;/p&gt;
&lt;h3 id=&quot;%E8%A7%A3%E5%86%B3%E5%8D%95%E7%82%B9%E6%95%85%E9%9A%9C&quot; tabindex=&quot;-1&quot;&gt;解决单点故障&lt;/h3&gt;
&lt;p&gt;在单台机器上部署服务，如果机器出现故障导致服务挂了，那么整个系统就会崩溃了。因此就要提高系统的可用性，系统的高可用性意味着一群服务器运行时与单台机器运行时没区别。这意味着要解决系统架构中的单点故障问题，通过引入分布式架构来增加冗余，从而提高系统的可用性，即使单台机器挂了也能保证服务正常运作。&lt;/p&gt;
&lt;p&gt;基于上面两个原因，我们就需要分布式系统来解决系统容量不足和系统高可用问题。&lt;/p&gt;
&lt;h2 id=&quot;%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%98%AF%E4%BB%80%E4%B9%88&quot; tabindex=&quot;-1&quot;&gt;分布式系统是什么&lt;/h2&gt;
&lt;p&gt;看看维基百科上的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A distributed system is a system whose components are located on different networked computers, which communicate and coordinate their actions by passing messages to one another.[1] The components interact with one another in order to achieve a common goal. Three significant characteristics of distributed systems are: concurrency of components, lack of a global clock, and independent failure of components.[1] Examples of distributed systems vary from SOA-based systems to massively multiplayer online games to peer-to-peer applications.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在计算机科学里，分布式系统是一个组件/软件分布在网络中不同服务器，服务器之间通过传递信息来通信和协作的系统。&lt;/p&gt;
&lt;h3 id=&quot;%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84&quot; tabindex=&quot;-1&quot;&gt;分布式架构&lt;/h3&gt;
&lt;p&gt;举一个例子，来看看一个分布式系统架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/06/distributed-system-demo.jpg&quot; alt=&quot;理解Java8中的时间API&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如图所示，A、B、C三台机器，机器A部署了服务AA、BB，机器B部署了BB、CC，机器C部署了AA、CC，AA需要调用BB，BB需要调用CC，即AA与BB通信，BB与CC通信。&lt;/p&gt;
&lt;p&gt;一个接口rpcA调用AA，AA调用BB，BB调用CC，调用路径如图（1-&amp;gt;2-&amp;gt;3），每一个调用所到达的机器都有可能为服务部署的机器之一。&lt;/p&gt;
&lt;p&gt;图所表示的分布式系统架构有很多细节没有展示出来，但这是一个比较简单的分布式架构例子。&lt;/p&gt;
&lt;p&gt;分布式系统中，要实现调用服务能到达部署的机器之一，就要用到负载均衡，可以分发集中的流量。像例子中的rpcA接口，调用链路&lt;code&gt;rpcA-&amp;gt;AA-&amp;gt;BB-&amp;gt;CC&lt;/code&gt;，整个链路较长，可以把全部的调用都写到rpcA接口中，但是如果某一步失败了，整个接口就失败了，因此可以将流程拆分到多个小的服务，微服务化，提高系统性能。&lt;/p&gt;
&lt;p&gt;以上就是分布式系统的介绍及分布式系统诞生的原因，分布式系统的性价比很高、处理能力强、可靠性高、也有很好的扩展性，能为系统带来很好的性能和可用性。但是，分布式系统中还有很多不确定的问题存在。&lt;/p&gt;
&lt;h3 id=&quot;%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98&quot; tabindex=&quot;-1&quot;&gt;分布式系统遇到的问题&lt;/h3&gt;
&lt;p&gt;做了负载均衡和微服务，是不是就可以高枕无忧，安心等待下一步的扩容扩展服务？很遗憾，分布式系统中还有很多的不确定性，比如应用架构引入了分布式系统之后，还有可能带来下面这些问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;系统的吞吐量会变大，但是响应时间会变长。&lt;/li&gt;
&lt;li&gt;某个非核心服务出现故障，为了不影响主流程，要加入服务降级和熔断策略&lt;/li&gt;
&lt;li&gt;同一个请求可能被服务集群里面的多台机器处理，然后保证幂等性&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;这些问题都需要引入其他手段解决来提高系统的稳定性，而加入了这些技术之后，还会衍生出更多的子问题，这就需要我们不断地用各式各样的技术和手段来解决这些问题。这些问题会在后面文章再做介绍。&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;分布式系统领域里，还有一大片浩瀚的海洋可以探索，上面的例子只是从分布式应用角度介绍了这个概念，分布式系统里面还有分布式计算、分布式数据与存储等等领域。每一个领域都值得深入探索，这是一条漫长的学习之路。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，顺手点个赞吧，谢谢&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Mockito-提高单元测试效率利器</title>
    <link href="https://hoohack.me/blog/2020/2020-05-30-mockito-in-unit-test/"/>
    <updated>2020-05-30T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2020/2020-05-30-mockito-in-unit-test/</id>
    <content type="html">&lt;h2 id=&quot;%E5%89%8D%E8%A8%80&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;之前在开发进行到写单元测试阶段的时候，发现要测试的方法里面是包含依赖的：外部接口RPC调用、DB调用。在某些情况下，部分依赖不稳定或者无法在测试环境调用时，会导致用例偶尔执行失败。&lt;/p&gt;
&lt;p&gt;另外一点，很多用例都是在测试用例的开头写了&lt;code&gt;@SpringRunTest&lt;/code&gt;的注解，导致跑用例的时候会启动整个Spring容器，这样一来，运行测试用例就非常慢了。当在一些比较大的项目运行用例时，甚至达到了每次启动容器需要5-6分钟的时长，渐渐就有点受不了这种操作，每改一行代码心里都焦急，因为如果错了的话又要再等5-6分钟才能看到效果了。后来请教同事和上网搜索，找到了一种比较快且安全的方案，使用Mock框架--&lt;a href=&quot;https://site.mockito.org/&quot;&gt;Mockito&lt;/a&gt;，学习并实践了一段时间，总结一下使用方法。&lt;/p&gt;
&lt;h2 id=&quot;mockito&quot; tabindex=&quot;-1&quot;&gt;Mockito&lt;/h2&gt;
&lt;p&gt;Mockito是当前最流行的单元测试Mock框架。&lt;/p&gt;
&lt;h3 id=&quot;%E4%BB%80%E4%B9%88%E6%98%AFmock&quot; tabindex=&quot;-1&quot;&gt;什么是Mock&lt;/h3&gt;
&lt;p&gt;Mock的字面意思就是模仿，虚拟，在单元测试中，使用Mock可以虚拟出一个外部依赖对象。&lt;/p&gt;
&lt;p&gt;对于在单元测试中一些不容易构造或者不容易获取的对象（如外部服务），用一个Mock对象来创建，可以降低测试的复杂度，只关心当前单元测试的方法。&lt;/p&gt;
&lt;h3 id=&quot;%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8mock&quot; tabindex=&quot;-1&quot;&gt;为什么用Mock&lt;/h3&gt;
&lt;p&gt;单元测试的目的就是为了验证一个代码单元的正确性，真正要验证的只是某个输入对应的输出的正确与否。如果把外部依赖服务引入进来，就会增加原来单元的复杂度，且在该单元中隐形地掺杂了其他功能的内容。&lt;/p&gt;
&lt;p&gt;使用Mock对象进行单元测试，开发可以只关心要测试单元的代码。&lt;/p&gt;
&lt;h2 id=&quot;%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B&quot; tabindex=&quot;-1&quot;&gt;使用示例&lt;/h2&gt;
&lt;p&gt;先看看代码示例，假设有以下的场景：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;验证获取用户信息接口：包含用户ID、用户昵称、是否vip&lt;/li&gt;
&lt;li&gt;是否vip需要外部服务VIPService获取，通过RPC调用，测试环境如果机器性能较差或者网络不好会导致用例不稳定&lt;/li&gt;
&lt;li&gt;编写单元测试判断用户VIP信息返回是否正确&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;需求是判断获取用户信息接口返回的格式是否正确，与vip接口的返回值无关，只要透传vip接口返回的字段即可，测试代码如下：&lt;/p&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@RunWith&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;PowerMockRunner&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UserServiceTest&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token annotation punctuation&quot;&gt;@InjectMocks&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UserService&lt;/span&gt; userService&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Mock&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;VIPService&lt;/span&gt; vipService&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Test&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getUserInfo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token class-name&quot;&gt;Mockito&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;when&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;vipService&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isVip&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Mockito&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;anyString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;thenReturn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        &lt;span class=&quot;token class-name&quot;&gt;Result&lt;/span&gt; result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; userService&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getUserInfo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        &lt;span class=&quot;token class-name&quot;&gt;Assert&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;assertEquals&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; result&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getData&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;isVip&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解释下上面代码用到的几个注解&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@Mock&lt;/strong&gt;：创建一个Mock&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@InjectMocks&lt;/strong&gt;：Mock一个实例，其余用Mock注解创建的mock将被注入到该实例中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mockito.when(...).thenReturn(...)&lt;/strong&gt;：Mock方法，如果满足when里面的条件，返回thenReturn指定的结果。&lt;/p&gt;
&lt;p&gt;在这段代码里，使用&lt;code&gt;@Mock&lt;/code&gt;注解创建了一个VipService实例，使用&lt;code&gt;@InjectMock&lt;/code&gt;创建了UserService，Mock创建的vipService实例会被注入到UserService的实例中，在写测试用例的时候就可以模拟vipService的行为。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Mockito.when(vipService.isVip(Mockito.anyString())).thenReturn(true);&lt;/code&gt;
这段代码表示不管传任何参数给vipService.isVip方法，该方法都会返回true，这样，就不影响获取用户信息接口的正常测试，也可以使用断言验证返回的数据。&lt;/p&gt;
&lt;h2 id=&quot;%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84%E5%9C%BA%E6%99%AF&quot; tabindex=&quot;-1&quot;&gt;遇到过的场景&lt;/h2&gt;
&lt;p&gt;以上是使用Mockito实践最简单的示例，在生产环境使用过程中，会有各种各样的需求需要满足，下面列一下笔者遇到过的场景。&lt;/p&gt;
&lt;h3 id=&quot;mock%E5%BC%82%E5%B8%B8&quot; tabindex=&quot;-1&quot;&gt;mock异常&lt;/h3&gt;
&lt;p&gt;这种场景是，方法里面声明了可能会抛出A异常，而A异常有多种可能性，不同的异常对应不同的message，为了验证抛出某种A异常后的功能，就需要模拟方法抛出指定message的A异常。&lt;/p&gt;
&lt;p&gt;使用方式是定义一个&lt;code&gt;Rule&lt;/code&gt;注解的属性，在使用时，设置thrown抛出的异常类型和所带的message。简要代码如下：&lt;/p&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;AException&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;RuntimeException&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; code&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;AException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; code&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; msg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;msg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;code &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; code&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@RunWith&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;PowerMockRunner&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;MockExceptionTest&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Rule&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ExpectedException&lt;/span&gt; thrown &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ExpectedException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Test&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;mockException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        thrown&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;expect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;AException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        thrown&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;expectMessage&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;expected message&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        &lt;span class=&quot;token comment&quot;&gt;// test code&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;mock%E7%A9%BA%E6%96%B9%E6%B3%95&quot; tabindex=&quot;-1&quot;&gt;mock空方法&lt;/h3&gt;
&lt;p&gt;mock一个空方法，比较简单，就是调用&lt;code&gt;doNothing().when()...&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;mock%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95&quot; tabindex=&quot;-1&quot;&gt;mock静态方法&lt;/h3&gt;
&lt;p&gt;如果要Mock静态方法，首先在类的开头增加注解：&lt;code&gt;@PrepareForTest({ClassNameA.class})&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在需要Mock类方法的之前，增加代码：&lt;code&gt;PowerMockito.mockStatic(ClassNameA.class);&lt;/code&gt;，然后就可以愉快的Mock了。简要代码如下：&lt;/p&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ClassNameA&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;methodA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token comment&quot;&gt;// code&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; ret&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@RunWith&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;PowerMockRunner&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@PrepareForTest&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ClassNameA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;MockStaticClassTest&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Test&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;mockStaticMethod&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token class-name&quot;&gt;PowerMockito&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;mockStatic&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ClassNameA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        &lt;span class=&quot;token class-name&quot;&gt;Mockito&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;when&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ClassNameA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;methodA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;thenReturn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token comment&quot;&gt;// test code&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;%E9%83%A8%E5%88%86mock&quot; tabindex=&quot;-1&quot;&gt;部分mock&lt;/h3&gt;
&lt;p&gt;对于某些场景，在一个单元测试里，需要某个方法Mock，某个方法走正常逻辑，这种操作就一点要启动容器，目前还没找到合适的方法可以进行这种操作，如果有更好的方法麻烦指点指点。笔者目前的做法是将原来的方法再拆分，拆分为更小的单元，让各自可以进行Mock，在集成测试时才真正执行全部代码。&lt;/p&gt;
&lt;p&gt;以上是笔者在日常开发中遇到的场景&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;单元测试是针对代码逻辑最小单元进行正确性检验的校验工作，写好单元测试，对于发现代码bug、保障系统稳定性以及重构而言都是非常必要的一项工作，可以提前发现一些隐藏问题。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://howtodoinjava.com/best-practices/unit-testing-best-practices-junit-reference-guide&quot;&gt;JUnit最佳实践&lt;/a&gt;这篇文章提到，Mock所有外部服务和状态：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Mock out all external services and state
Otherwise, behavior in those external services overlaps multiple tests, and state data means that different unit tests can influence each other’s outcome. You’ve definitely taken a wrong turn if you have to run your tests in a specific order, or if they only work when your database or network connection is active.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Also, this is important because you would not love to debug the test cases which are actually failing due to bugs in some external system.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，还是尽可能使用Mock来进行有外部服务的单元测试。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点个赞吧，谢谢&lt;/p&gt;
&lt;p&gt;参考文章
&lt;a href=&quot;https://howtodoinjava.com/best-practices/unit-testing-best-practices-junit-reference-guide&quot;&gt;JUnit Best Practices Guide&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>理解Java8中的时间API</title>
    <link href="https://hoohack.me/blog/2020/2020-05-23-java-time-api/"/>
    <updated>2020-05-23T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2020/2020-05-23-java-time-api/</id>
    <content type="html">&lt;p&gt;在Java8之前，在Java开发过程中，如果要操作时间，是使用Date这个类，在Java8中新增了LocalTime、LocalDate和LocalDateTime，日期和时间的处理变得更加方便和容易。用了一段时间，刚开始每次用的时候都要上网查一波才能找到要的答案，后来认真看一下官网的API，发现也不是那么难理解，现在能够通过自己的理解找到自己想要的表达式，在这里做个小小的学习总结。&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E6%96%B0%E7%9A%84%E6%97%B6%E9%97%B4api&quot; tabindex=&quot;-1&quot;&gt;为什么要有新的时间API&lt;/h2&gt;
&lt;p&gt;既然Date类已经存在了那么多年，为什么要花那么大的精力去做这个改动？收益是什么呢？&lt;/p&gt;
&lt;p&gt;首先，因为Date类真的很难用，有很多过于Geek的设计，比如月份是从0开始，0是一月，11是十二月。好吧，我已经知道程序员是从0开始计数了，但是每次用的时候都要做各种转换，特别是跟其他输出端有交互的时候，改错一个地方就凌乱了。在新的API&lt;code&gt;java.time&lt;/code&gt;里，这些都用常量表示了，不会用错，代码看起来也更加清晰。&lt;/p&gt;
&lt;p&gt;在业务代码中，往往有很多种需求，获取某一天的0点，获取下一天的中午时间，将当前时间往前或者往后移动几天，等等这类的需求，这些功能使用Date类配合Calendar要写好多代码，代码简洁性也不够好。&lt;/p&gt;
&lt;p&gt;另外一个，Date里面的很多方法都弃用了，如果新的项目还敢用这些类，那就是给自己埋坑了，还是趁早改了为好。&lt;/p&gt;
&lt;p&gt;旧的时间类&lt;code&gt;java.util.Date&lt;/code&gt;和格式化类&lt;code&gt;SimpleDateFormatter&lt;/code&gt;都是可变类，不是线程安全的，在多线程环境下对共享变量Date进行操作时，需要自己保证线程安全。而新的时间API&lt;code&gt;LocalTime&lt;/code&gt;和&lt;code&gt;LocalDate&lt;/code&gt;和格式化类&lt;code&gt;DateTimeFormatter&lt;/code&gt;都是final类(不可变)且是线程安全的。&lt;/p&gt;
&lt;p&gt;基于上面的这些原因，就没有理由不使用新的时间API了。&lt;/p&gt;
&lt;p&gt;从一个用着习惯了很多年的工具切换到新的工具总是很不习惯，过程是痛苦的，但是结果是美好的。&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E6%96%B0%E7%9A%84%E6%97%B6%E9%97%B4api&quot; tabindex=&quot;-1&quot;&gt;怎么理解新的时间API&lt;/h2&gt;
&lt;p&gt;在新的时间API里，有&lt;code&gt;LocalTime&lt;/code&gt;、&lt;code&gt;LocalDate&lt;/code&gt;、&lt;code&gt;LocalDateTime&lt;/code&gt;三个类，&lt;code&gt;LocalTime&lt;/code&gt;只处理时间，无法包含日期，&lt;code&gt;LocalDate&lt;/code&gt;只处理日期，无法包含时间，只有&lt;code&gt;LocalDateTime&lt;/code&gt;能同时处理日期和时间。&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F&quot; tabindex=&quot;-1&quot;&gt;怎么使用？&lt;/h2&gt;
&lt;p&gt;如果理解了三个类的区别，那么在使用上，需要根据具体情况来处理，下面看看比较常遇到的场景。&lt;/p&gt;
&lt;h3 id=&quot;localdate&quot; tabindex=&quot;-1&quot;&gt;LocalDate&lt;/h3&gt;
&lt;p&gt;只取日期，年月日。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取今天的日期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LocalDate today = LocalDate.now();// 2020-05-20&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用年月日构造一个日期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LocalDate valentineDay = LocalDate.of(2020, 5, 20); // 月份和日期是从1开始&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指定对象，获取年、月、日、星期几&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; year &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; localDate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getYear&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token class-name&quot;&gt;Month&lt;/span&gt; month &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; localDate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getMonth&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; day &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; localDate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getDayOfMonth&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token class-name&quot;&gt;DayOfWeek&lt;/span&gt; dayOfWeek &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; localDate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getDayOfWeek&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; year &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; localDate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ChronoField&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;YEAR&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; month &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; localDate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ChronoField&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;MONTH_OF_YEAR&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; day &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; localDate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ChronoField&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;DAY_OF_MONTH&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; dayOfWeek &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; localDate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ChronoField&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;DAY_OF_WEEK&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;localtime&quot; tabindex=&quot;-1&quot;&gt;LocalTime&lt;/h3&gt;
&lt;p&gt;获取时间，只会取几点几分几秒。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;初始化时间对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LocalTime localTime = LocalTime.now();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用时分秒构造一个对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LocalTime localTime = LocalTime.of(12, 0, 0);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指定对象，获取时分秒&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token class-name&quot;&gt;LocalTime&lt;/span&gt; localTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;LocalTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; hour &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; localTime&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getHour&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; minute &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; localTime&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getMinute&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; second &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; localTime&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getSecond&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; hour &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; localTime&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ChronoField&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;HOUR_OF_DAY&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; minute &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; localTime&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ChronoField&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;MINUTE_OF_HOUR&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; second &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; localTime&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ChronoField&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;SECOND_OF_MINUTE&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;localdatetime&quot; tabindex=&quot;-1&quot;&gt;LocalDateTime&lt;/h3&gt;
&lt;p&gt;获取日期+时间，年月日+时分秒，含义等于LocalDate+LocalTime&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建时间对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LocalDateTime localDateTime = LocalDateTime.now();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用LocalDate结合LocalTime构造时间对象&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token class-name&quot;&gt;LocalDateTime&lt;/span&gt; localDateTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;LocalDateTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;localData&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; localTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token class-name&quot;&gt;LocalDateTime&lt;/span&gt; localDateTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; localDate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;atTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;localTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token class-name&quot;&gt;LocalDateTime&lt;/span&gt; localDateTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; localTime&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;atDate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;localDate&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;通过LocalDateTime获取LocalDate和LocalTime&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token class-name&quot;&gt;LocalDate&lt;/span&gt; localDate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; localDateTime&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toLocalDate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token class-name&quot;&gt;LocalTime&lt;/span&gt; localDate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; localDateTime&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toLocalTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;instant&quot; tabindex=&quot;-1&quot;&gt;Instant&lt;/h2&gt;
&lt;p&gt;这个类是表示时间轴上的某一个时刻的时间点。从&lt;strong&gt;1970-01-01&lt;/strong&gt;这个时间开始计算，主要用于获取时间戳，与&lt;code&gt;System.currentTimeMillis()&lt;/code&gt;（精确到毫秒）类似，但是Instant类可以精确到纳秒。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建Instant对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Instant instant = Instant.now();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用时间戳创建Instant对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Instant instant = Instant.ofEpochSecond(100, 100000);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取秒数和毫秒&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;instant&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getEpochSecond&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;instant&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getEpochMill&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;%E4%B8%BE%E4%BE%8B%E5%AD%90%E5%8A%A0%E6%B7%B1%E5%8D%B0%E8%B1%A1&quot; tabindex=&quot;-1&quot;&gt;举例子加深印象&lt;/h2&gt;
&lt;p&gt;介绍了这几个类的基本API后，再通过实现某些具体的需求来加深印象。&lt;/p&gt;
&lt;h3 id=&quot;%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E6%88%B3&quot; tabindex=&quot;-1&quot;&gt;获取当前时间戳&lt;/h3&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 获取当前时间对象-&gt;设置时-&gt;转换成时间戳&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getCurrentSeconds&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;	&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Instant&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;atZone&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ZoneOffset&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;+8&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toEpochSecond&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;%E8%8E%B7%E5%8F%96%E5%BD%93%E5%A4%A9%E9%9B%B6%E7%82%B9%2F%E7%BB%93%E6%9D%9F%E6%97%B6%E9%97%B4%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3&quot; tabindex=&quot;-1&quot;&gt;获取当天零点/结束时间的时间戳&lt;/h3&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 使用日期和时间构造日期时间对象-&gt;指定时区转换成时间戳&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getTodayStartTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;	&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;LocalDateTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;LocalDate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;LocalTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;MIN&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toEpochSecond&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ZoneOffset&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;+8&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getTodayEndTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;LocalDateTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;LocalDate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;LocalTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toEpochSecond&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ZoneOffset&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;+8&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;%E8%8E%B7%E5%8F%96%E5%89%8D%E4%B8%80%E5%A4%A9%E9%9B%B6%E7%82%B9&quot; tabindex=&quot;-1&quot;&gt;获取前一天零点&lt;/h3&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 使用日期和时间构造日期时间对象-&gt;修改日期-&gt;指定时区转换成时间戳&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getYesterdayStartTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;	&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;LocalDateTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;LocalDate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;LocalTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;MIN&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;minusDays&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toEpochSecond&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ZoneOffset&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;+8&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;%E6%A0%B9%E6%8D%AE%E6%97%B6%E9%97%B4%E6%88%B3%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4%E6%88%B3%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%97%B6%E9%97%B4%E5%BD%93%E5%A4%A90%E7%82%B9&quot; tabindex=&quot;-1&quot;&gt;根据时间戳获取时间戳表示的时间当天0点&lt;/h3&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 使用时间戳构造日期时间对象-&gt;修改日期-&gt;指定时区转换成时间戳&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getDayStartTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;	&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;LocalDateTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;LocalDate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;LocalTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;MIN&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;minusDays&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toEpochSecond&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ZoneOffset&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;+8&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%9C%88%E5%88%9D%E7%AC%AC%E4%B8%80%E5%A4%A9&quot; tabindex=&quot;-1&quot;&gt;判断是否月初第一天&lt;/h3&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;isFirstDayOfMonth&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; ymd&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token class-name&quot;&gt;LocalDate&lt;/span&gt; localDate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;LocalDate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ymd&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;DateTimeFormatter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;ofPattern&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;yyyyMMdd&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; localDate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;localDate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;withDayOfMonth&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/05/understand-java-8-time.png&quot; alt=&quot;理解Java8中的时间API&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Java新的时间API很强大，这里只能举几个自己遇到比较多的场景给大家介绍，所讲的只是最基础最皮毛的东西，要熟练的掌握所有的细节，还是需要去看看API或源码的实现，然后在平时具体的需求场景中慢慢积累。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点个赞吧，谢谢&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>【总结】从0到1的项目经历</title>
    <link href="https://hoohack.me/blog/2020/2020-05-16-summary-of-new-project/"/>
    <updated>2020-05-16T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2020/2020-05-16-summary-of-new-project/</id>
    <content type="html">&lt;p&gt;去年7月底，接到公司安排，需要在一个半月内完成全新app的上线，需求文档与开发并行，由于时间紧迫，以及人力有限，当然就是享受了一次996，经历了之后，发现真是的是一次痛并快乐着的体验。这段时间加班稍微少了一点，趁假期写下这段经历的收获。&lt;/p&gt;
&lt;p&gt;经历了这么一波疯狂加班后，我总结了一些经验，希望能对自己以后的快速且稳定的开发节奏起到辅助作用，也希望能够帮到正在读这篇文章的你。&lt;/p&gt;
&lt;p&gt;注意，以下的所有建议，都是针对于没有按照正常流程走的创新性项目，不一定适用于已经稳定下来，需要按照正常流程开发的项目，当然有一些是可以借鉴的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/05/work-overtime.jpg&quot; alt=&quot;Photo by Mitchell Luo on Unsplash&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E6%8F%90%E9%AB%98%E6%B2%9F%E9%80%9A%E6%95%88%E7%8E%87%E6%9C%80%E5%A5%BD%E7%9A%84%E5%8A%9E%E6%B3%95%EF%BC%8C%E5%BD%93%E9%9D%A2%E6%B2%9F%E9%80%9A&quot; tabindex=&quot;-1&quot;&gt;提高沟通效率最好的办法，当面沟通&lt;/h2&gt;
&lt;p&gt;做这种996的快速开发，每个人每天都在争分夺秒，所以时间非常宝贵，遇到不懂的东西，通过即时通讯工具沟通效率是非常非常低的，不管是私聊还是群聊，不能一直等待别人的回复，如果有个很重要的流程阻碍到自己的进度，那么最应该做的事情是拉上相关的人，把所有相关的人集中在会议室中，明确讨论的主题，最后在白板面前画下流程，让大家一起对流程更加熟悉，找出更好的解决方案。每次沟通好方案以后，都要有书面记录通知到每一个参与讨论的人，保证信息的同步。&lt;/p&gt;
&lt;h2 id=&quot;%E6%AF%8F%E5%A4%A9%E9%A2%84%E7%95%99%E4%B8%80%E7%82%B9%E6%97%B6%E9%97%B4%E6%80%BB%E7%BB%93%EF%BC%8C%E5%8F%8A%E6%97%B6mark%E4%B8%8Btodo%E9%A1%B9&quot; tabindex=&quot;-1&quot;&gt;每天预留一点时间总结，及时mark下TODO项&lt;/h2&gt;
&lt;p&gt;在这么紧凑的开发进度下工作，是非常非常容易忘记东西的，当时的做法是每天下班后再留下半小时梳理当天完成的内容，划掉已经完成的工作任务或者优先级不在第一个版本的工作任务，然后当天加了什么功能，发现什么功能遗漏了，都写下来，以便安排第二天需要完成的工作。&lt;/p&gt;
&lt;p&gt;如果实在太疲劳，做不到每天总结，至少每2天或者最低限度是一星期要做一次梳理总结，否则到最后关头才发现这也没做，那也漏了，那真的加班干到si都不能完成了。&lt;/p&gt;
&lt;p&gt;这个习惯现在仍然保持着，现在项目进度稍微没那么赶，每个需求都会这么做，对能按时交付需求已经没有大难度了。&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%8E%E4%BA%A7%E5%93%81%E6%B2%9F%E9%80%9A%EF%BC%8C%E5%81%9A%E5%A5%BD%E5%8F%96%E8%88%8D&quot; tabindex=&quot;-1&quot;&gt;与产品沟通，做好取舍&lt;/h2&gt;
&lt;p&gt;在需求文档还没出完的情况下，开发在加班，产品也在加班，开发进行到一半，产品完成了部分文档，突然来了一个大功能，那么要在短时间内完成全部肯定是不可能的，只能跟产品沟通，看功能是否很重要，如果没有该功能是否影响产品的使用，保下最重要的功能，其他非核心流程的功能，留在下一个版本再迭代。&lt;/p&gt;
&lt;p&gt;这一点最好应该在项目启动时进行，即使需求文档没有出完，但是可以梳理出最核心的功能，大家都朝着同样的目标去干。鱼与熊掌不可兼得，你不能什么都想要。&lt;/p&gt;
&lt;h2 id=&quot;%E5%B9%B3%E6%97%B6%E5%A4%9A%E7%A7%AF%E7%B4%AF%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%EF%BC%8C%E5%B9%B6%E5%8F%8A%E6%97%B6%E5%8D%87%E7%BA%A7&quot; tabindex=&quot;-1&quot;&gt;平时多积累项目的通用组件，并及时升级&lt;/h2&gt;
&lt;p&gt;在参与这些全新又紧急的项目，要想要马上就能写下第一行代码，平时一定要积累一些通用的组件、工具类，比如参数校验拦截器、时间函数、异常处理拦截器等等，有了这些，开发起来就如虎添翼了。&lt;/p&gt;
&lt;p&gt;有了自己的项目框架，就不需要重新搭建，只需要关心业务功能的实现，当然，最好是能自己写一个脚本，一键初始化项目。&lt;/p&gt;
&lt;h2 id=&quot;%E5%BF%AB%E7%9A%84%E5%90%8C%E6%97%B6%E5%B0%BD%E9%87%8F%E7%A8%B3&quot; tabindex=&quot;-1&quot;&gt;快的同时尽量稳&lt;/h2&gt;
&lt;p&gt;要求这么快交付的项目，bug多是肯定的，虽然可以允许少量的试错，但是关键的是要保证核心功能是没问题，且不允许出错的，核心功能无法使用对于用户以及产品来说，是无法接受的，会造成用户的流失，大大降低用户留存率。&lt;/p&gt;
&lt;h2 id=&quot;%E5%8F%8A%E6%97%B6%E4%BC%91%E6%81%AF&quot; tabindex=&quot;-1&quot;&gt;及时休息&lt;/h2&gt;
&lt;p&gt;结束了每一天的忙碌之后，早点休息吧，记得当时差不多周一到周六，每天是9点半开始开发，晚上1点才停止。连续3周之后，到了周日的时候就是一阵头疼，痛一整天，基本上一天都做不了什么，然后又开始新一轮的工作。甚至有一天半夜醒来了，疯狂出冷汗，全身虚弱，而且疯狂地出冷汗，持续了大约10分钟，那一次真的把我吓到了。所以休息好很重要，有时间就休息，不能疯狂工作忘了休息，身体才是奋斗的本钱。&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;经历了这一次的从无到有的项目开发，不可否认是很累，虽然中途也有很多挫败感，但也不可否认学到了很多东西，有了很大的成长，后续会慢慢分享这些学到的东西，可以说是自己工作以来成长最快的一段时间，感谢这一次的项目经历，也感谢帮助我的老大和每一个小伙伴。&lt;/p&gt;
&lt;p&gt;最后的最后，当然希望大家遇到的项目都是能按照正常排期进行的，这样的节奏才是正常的，你好我好大家都好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/05/work-life-balance.jpg&quot; alt=&quot;Photo by Jon Tyson on Unsplash&quot; /&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>使用拦截器统一处理通用检查</title>
    <link href="https://hoohack.me/blog/2020/2020-04-22-common-check-with-interceptor/"/>
    <updated>2020-04-22T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2020/2020-04-22-common-check-with-interceptor/</id>
    <content type="html">&lt;h2 id=&quot;%E7%B9%81%E7%90%90%E7%9A%84%E6%A3%80%E6%9F%A5&quot; tabindex=&quot;-1&quot;&gt;繁琐的检查&lt;/h2&gt;
&lt;p&gt;在平时的业务开发中，相信大家都有很多这样的代码：&lt;/p&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;login&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Parameter&lt;/span&gt; parameter&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;validateXXX&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;parameter&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BizException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ErrCode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;PAMRM_ERROR&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;  &lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;// 真正的逻辑代码&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么，如果代码还有其他通用的校验，而且每加一个接口都要加这些校验逻辑，久而久之，代码会显得较臃肿，看起来会有很多重复的代码，那么有没有办法精简这部分代码呢？有！&lt;/p&gt;
&lt;h2 id=&quot;spring%E7%9A%84handlerinterceptor&quot; tabindex=&quot;-1&quot;&gt;Spring的HandlerInterceptor&lt;/h2&gt;
&lt;p&gt;先上代码&lt;/p&gt;
&lt;h3 id=&quot;%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9A%E4%B9%89&quot; tabindex=&quot;-1&quot;&gt;拦截器定义&lt;/h3&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CheckXXXHandlerInterceptor&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HandlerInterceptorAdapter&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Method&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; methodCache &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;IdentityHashMap&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Override&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;preHandle&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;HttpServletRequest&lt;/span&gt; request&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HttpServletResponse&lt;/span&gt; response&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; handler&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        &lt;span class=&quot;token class-name&quot;&gt;HandlerMethod&lt;/span&gt; handlerMethod &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;HandlerMethod&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; handler&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        &lt;span class=&quot;token comment&quot;&gt;/**&lt;br /&gt;        这个是双重判断锁单例&lt;br /&gt;        外层的判断，为了避免在实例已经创建好的情况下再次加锁获取，影响性能；&lt;br /&gt;        里层的判断，考虑在多线程环境下，多个线程同时过掉外层判断，也就是都已经判断变量为空，如果不加一重判断，还是有可能重复创建。&lt;br /&gt;        */&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token class-name&quot;&gt;Method&lt;/span&gt; method &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; handlerMethod&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getMethod&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;methodCache&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;containsKey&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;method&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;methodCache&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;                &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;methodCache&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;containsKey&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;method&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;                    &lt;span class=&quot;token keyword&quot;&gt;boolean&lt;/span&gt; check &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;                    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;method&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isAnnotationPresent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;CheckXXX&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;                        check &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; method&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getAnnotation&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;CheckXXX&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;                    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;method&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getDeclaringClass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isAnnotationPresent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;CheckXXX&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;                        check &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; method&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getDeclaringClass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getAnnotation&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;CheckXXX&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;                    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;                    methodCache&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;method&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; check&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;                &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;methodCache&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;method&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token comment&quot;&gt;// do check&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;%E6%B3%A8%E8%A7%A3%E5%AE%9A%E4%B9%89&quot; tabindex=&quot;-1&quot;&gt;注解定义&lt;/h3&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Retention&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;RetentionPolicy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;RUNTIME&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Target&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ElementType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;TYPE&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ElementType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;METHOD&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token annotation punctuation&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CheckXXX&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8&quot; tabindex=&quot;-1&quot;&gt;注解使用&lt;/h3&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@CheckXXX&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;XXXController&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;login&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Parameter&lt;/span&gt; parameter&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token comment&quot;&gt;// 真正的逻辑代码&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，就能抽离出通用的逻辑，精简通用的代码。那么，这个拦截器是什么时候执行的呢？它的实现原理是什么？&lt;/p&gt;
&lt;h3 id=&quot;%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA&quot; tabindex=&quot;-1&quot;&gt;执行时机&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/04/Interceptor_UML.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;通过查看自定义拦截器的UML类图关系，可以看出来，其实是实现了HandlerInterceptor的preHandle方法，通过追踪HandlerInterceptor的调用链路，最终是在请求进入分发器，执行&lt;code&gt;doDispatch&lt;/code&gt;方法用的，而处理器是在初始化的时候就加载好。&lt;/p&gt;
&lt;p&gt;整体的流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/04/Interceptor_Procedure.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;核心代码：&lt;/p&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;mappedHandler&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;applyPreHandle&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;processedRequest&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; response&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;applyPreHandle&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;HttpServletRequest&lt;/span&gt; request&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HttpServletResponse&lt;/span&gt; response&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token class-name&quot;&gt;HandlerInterceptor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; interceptors &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getInterceptors&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ObjectUtils&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;interceptors&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; interceptors&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token class-name&quot;&gt;HandlerInterceptor&lt;/span&gt; interceptor &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; interceptors&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;interceptor&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;preHandle&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;request&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; response&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;handler&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;                &lt;span class=&quot;token function&quot;&gt;triggerAfterCompletion&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;request&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; response&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;                &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;interceptorIndex &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;拦截器数组interceptors是在Spring容器启动的时候初始化好的，实现原理比较简单，就是取出请求处理器的map，遍历调用注册好的拦截器。&lt;/p&gt;
&lt;h2 id=&quot;%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86&quot; tabindex=&quot;-1&quot;&gt;实现原理&lt;/h2&gt;
&lt;p&gt;通过拦截器处理通用检查，背后的编程思想其实是AOP，&lt;a href=&quot;https://zh.wikipedia.org/zh-cn/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1&quot;&gt;面向切面编程&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用切面的优点：首先，现在每个关注点都集中于一个地 方，而不是分散到多处代码中;其次，服务模块更简洁，因为它们只包含主要关注点(或核 心功能)的代码，而次要关注点的代码被转移到切面中了。----摘自《Spring实战》&lt;/p&gt;
&lt;p&gt;关于AOP，网上有很多资料解释，看维基百科的描述也很清晰，，笔者就不多赘述了。&lt;/p&gt;
&lt;p&gt;在这个例子里面，每个接口的核心功能是响应为业务功能提供服务，但是每个接口需要的参数检查、安全检查，都统一交给切面完成。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/04/Interceptor_AOP.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;代码和原理比较简单，但是里面包含的知识点却不少，通过追朔源码，能了解细节之余，还能掌握某一类问题的实现方案。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点个赞吧，谢谢^_^&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>[总结]MIT-6.824分布式课程-Mapduce实验</title>
    <link href="https://hoohack.me/blog/2020/2020-04-16-summary-about-mapduce-lab/"/>
    <updated>2020-04-16T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2020/2020-04-16-summary-about-mapduce-lab/</id>
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://pdos.csail.mit.edu/6.824/index.html&quot;&gt;MIT 6.824分布式系统课程&lt;/a&gt;，是一门著名的讲解分布式系统设计原理的课程。通过课程讲解和实验结合来学习分布式系统设计原理，实验和课程安排见&lt;a href=&quot;http://nil.csail.mit.edu/6.824/2020/schedule.html&quot;&gt;课程表&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;%E5%89%8D%E8%A8%80&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;我为什么要学习这个课程？之所以会接触到这门课程，是之前在表示对分布式系统感兴趣时一位基友介绍的，由于种种原因并没有开始学。直到最近，开始研究分布式缓存系统的设计才重新开始。有读过笔者之前的文章可能知道，笔者对redis的研究内容比较感兴趣，后面对redis如何做分布式缓存比较感兴趣，于是开始查资料，后来发现&lt;a href=&quot;https://etcd.io/&quot;&gt;etcd&lt;/a&gt;在这方面也很强，在学习etcd过程中又了解到了到了&lt;a href=&quot;https://zh.wikipedia.org/wiki/Raft&quot;&gt;raft协议&lt;/a&gt;，接着就查到了这门课程中有介绍Raft协议的论文以及相关的实验，刚好得知2020年春季的课程有官方版的视频且被热心网友分享到&lt;a href=&quot;https://www.bilibili.com/video/BV1R7411t71W?p=2&quot;&gt;B站&lt;/a&gt;了，再加上完成实验需要用go语言来实现，基于学习分布式系统设计原理和实践go语言的目的，于是就开始学习这门课程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实际上，etcd和redis是完全不一样概念的东西，etcd主要用于分布式锁以及集群核心配置，核心特性是高可用；而Redis是内存型数据库，目的是做分布式缓存，保存数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E5%87%86%E5%A4%87%E8%B5%84%E6%96%99&quot; tabindex=&quot;-1&quot;&gt;准备资料&lt;/h2&gt;
&lt;p&gt;学习这门课程，是先阅读了&lt;a href=&quot;http://nil.csail.mit.edu/6.824/2020/index.html&quot;&gt;课程主页&lt;/a&gt;的介绍，接着根据课程表去学习，课程表里说明了先阅读论文后再去上课（或者看视频），要先看论文后再去看视频，否则看视频时教授在讲什么都不知道。&lt;/p&gt;
&lt;p&gt;上课步骤就是：读论文-&amp;gt;看视频-&amp;gt;做实验。&lt;/p&gt;
&lt;h2 id=&quot;mapreduce%E7%AE%80%E4%BB%8B&quot; tabindex=&quot;-1&quot;&gt;MapReduce简介&lt;/h2&gt;
&lt;p&gt;通过学习论文、课程视频以及完成了实验，对MapReduce有了个初步的认识，在这里总结一下我的理解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MapReduce&lt;/strong&gt;，本质就是一种编程模型，也是一个处理大规模数据集的相关实现。之所以会有这个模型，目的是为了隐藏“并行计算、容错处理、数据分发、负载均衡”，从而实现大数据计算的一种抽象。&lt;/p&gt;
&lt;p&gt;MapReduce的编程模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;map：接收一组输入的key/value键值对，处理后生成一组被称为中间值的key/value键值对集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;reduce：输入是map生成的key/value键值对集合，合并中间值集合中相同key的值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整个处理过程的抽象过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/04/MapReduce_Abstract.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在分布式系统中，除了程序以外还有很多需要考虑的问题，比如并发、容错处理等等，对于分布式的MapReduce，执行概览看下面这幅经典的流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/04/MapReduce_Overview.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;从图里可以看到，Map和Reduce程序分布在多台机器，取出分片数据来处理，数据可以被多台机器并行地处理，而如何分发数据及程序的管理由Worker和Master组成。执行的流程大致如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;系统会启动一个或多个Master，需要执行任务的机器启动Worker来处理任务。Master主要职责是分配任务给Worker，Master可以随机选择空闲的Worker来分配任务，或者Worker主动向Master请求任务；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获得map任务的Worker，读取数据分片，生成一组key/value键值对的中间值集合，并将数据写到本地文件，这里每个map任务数据分为R份(Master创建reduce任务的数量)，通过用户定义的分区函数(如hash(key) mod R)决定将key存在哪个文件；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获得reduce任务的Worker，通过远程调用请求数据，数据加载完毕后，对数据进行排序，之后遍历数据，将相同key的数据进行合并，最终输出结果；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当所有的map和reduce任务完成了，整个MapReduce程序就处理完毕了，Worker得到处理后的数据，通常会保存在不同的小文件中，合并这些文件之后就是最重要的结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上就是我对MapReduce论文的理解总结，还有其他的本地化、任务粒度、合并和排序程序、性能等等话题，因为在实验里还没很深的印象，所以这里暂不进行说明。&lt;/p&gt;
&lt;p&gt;另外要重点关注的是容错处理，如果Master中断、Worker程序崩溃，这些情况要怎么处理？论文里提到的解决方案是将处理结果保存在临时文件中，等到任务真正处理完才写到待输出文件里。&lt;/p&gt;
&lt;h2 id=&quot;%E5%AE%9E%E9%AA%8C%E5%AE%8C%E6%88%90%E4%B9%8B%E8%B7%AF&quot; tabindex=&quot;-1&quot;&gt;实验完成之路&lt;/h2&gt;
&lt;h3 id=&quot;%E6%97%A0%E6%B3%95%E5%85%A5%E6%89%8B&quot; tabindex=&quot;-1&quot;&gt;无法入手&lt;/h3&gt;
&lt;p&gt;读完MapReduce论文后，去看课程的前两节视频，听懂了大部分，然后兴致勃勃开始做实验。代码拉下来之后，发现根本没法下手，对着实验题和代码苦恼了一个晚上，只知道实验1就是要实现一个分布式的MapReduce，但是看代码已经有了map和reduce函数，根本不知道要做什么，感觉还没开始就要结束了。&lt;/p&gt;
&lt;h3 id=&quot;%E5%8F%8D%E5%A4%8D%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99&quot; tabindex=&quot;-1&quot;&gt;反复学习资料&lt;/h3&gt;
&lt;p&gt;第一次开始做实验失败之后，花了几个晚上将论文反复看了两遍，再回去看视频，在第二次的学习里，印象更加深刻了，再反复看题目的说明，说明里提到每次修改完程序后，&lt;a href=&quot;http://xn--test-mr-yx7nn24yiscfw3a.sh/&quot;&gt;都要执行test-mr.sh&lt;/a&gt;，里面包含了很多测试用例，只要通过了所有测试用例，那么实验就算完成了。于是去看测试用例文件，再结合题目描述，终于知道要做什么了。&lt;/p&gt;
&lt;p&gt;测试先行，阅读test-mr.sh可以发现，里面主要包含了5个测试用例：单词计数mapreduce、索引mapreduce、并行map、并行reduce、程序崩溃。比如单词计数，检查的步骤是先运行mrsequential.go输出一个文件mr-correct-wc.txt，接着启动mrmaster和mrworker，得到结果后合并为mr-wc-all文件，比较两个文件内容一样就说明通过该用例了。那么要完成实验要，可以先看看mrsequential.go里面做了什么，写一个分布式程序去实现mrsequential.go的功能。&lt;/p&gt;
&lt;p&gt;只要完成了以上的5个测试用例，实验就算完成了，而实际上map和reduce程序已经实现好了，那么需要做的是实现论文里提到的master和worker：&lt;/p&gt;
&lt;p&gt;1、如何分配任务？map和reduce任务如何分配？（用例1、用例2）&lt;/p&gt;
&lt;p&gt;2、如何实现并行处理？（用例3、用例4）&lt;/p&gt;
&lt;p&gt;3、怎么判断Worker崩了？Worker失败后，如何恢复，如何处理正在处理中的任务？（用例5）&lt;/p&gt;
&lt;p&gt;4、任务处理完成后，结果如何处理？&lt;/p&gt;
&lt;p&gt;5、Worker和Master之间的通信通过rpc通信，如何维持两者间的状态？&lt;/p&gt;
&lt;p&gt;理清了需求是要做什么以后，接下来就是设计和编码了。&lt;/p&gt;
&lt;h2 id=&quot;%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1&quot; tabindex=&quot;-1&quot;&gt;系统设计&lt;/h2&gt;
&lt;p&gt;只要是程序，设计起来都不外乎数据结构和算法，对于这个实验而言，也是如此。&lt;/p&gt;
&lt;h3 id=&quot;%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&quot; tabindex=&quot;-1&quot;&gt;数据结构&lt;/h3&gt;
&lt;p&gt;定义Master和Task的数据结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Master struct {
	nReduce             int
	nMap                int
	mapTasks            []Task
	reduceTasks         []Task
	state               int // MASTER_INIT;MAP_FINISHED;REDUCE_FINISHED
	mapTaskFinishNum    int
	reduceTaskFinishNum int
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;type Task struct {
	State          int // TASK_INIT;TASK_PROCESSING;TASK_DONE
	InputFileName  string
	Id             int
	OutputFileName string
	TaskType       int // MAP_TASK;REDUCE_TASK
	NReduce        int
	NMap           int
	StartTime      int64
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B%E5%9B%BE&quot; tabindex=&quot;-1&quot;&gt;实现流程图&lt;/h3&gt;
&lt;p&gt;根据对论文以及实验题目的理解后，设计Master和Task两个结构体，要实现的功能如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/04/MapReduce_Procedure.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;1、启动Master后，Master状态为INIT，并根据启动参数初始化map任务&lt;/p&gt;
&lt;p&gt;2、启动Worker，请求Master分配一个任务，然后处理任务(map/reduce)&lt;/p&gt;
&lt;p&gt;3、处理完成后通知Master更新任务状态为完成；每次有任务完成时，检查Map/Reduce任务是否全部完成，根据完成进度更新Master状态&lt;/p&gt;
&lt;p&gt;4、所有任务完成后，Master状态为REDUCE_FINISHED&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;崩溃处理&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于处理worker崩溃，实验提示里提到，Master不能明显区分出Worker是处理超时还是崩溃了，所以需要设计一个超时时间(如10秒)，如果任务超时了，就认为任务未完成，下一次再重新分配。实现是在Master分配一个任务时，初始化一个开始时间，Master分配任务时，检查进行中任务，如果任务还未完成且超时了，就重新分配该任务给Worker。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;all-pass&quot; tabindex=&quot;-1&quot;&gt;ALL PASS&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/04/MapReduce_AllPass.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;所有测试用例都通过的那一刻，内心有一份小小的激动，仿佛上大学时通过了一道实验题那种感觉。&lt;/p&gt;
&lt;h2 id=&quot;q%26a&quot; tabindex=&quot;-1&quot;&gt;Q&amp;amp;A&lt;/h2&gt;
&lt;p&gt;分享几点学习中遇到的问题：&lt;/p&gt;
&lt;p&gt;1、学习这个有什么用？&lt;/p&gt;
&lt;p&gt;这个问题比较尖锐了，我的理解就是，如果对分布式系统感兴趣，想通过实践来强化对分布式系统的理解，那么学习这个课程会有帮助。如果不感兴趣的话，那么这篇文章对你没有什么用。&lt;/p&gt;
&lt;p&gt;2、如何开始学习？&lt;/p&gt;
&lt;p&gt;看&lt;a href=&quot;https://pdos.csail.mit.edu/6.824/index.html&quot;&gt;课程主页&lt;/a&gt;，根据课程表安排，先看论文，在看视频，理解个大概后开始做实验，然后再看论文和视频加深理解。&lt;/p&gt;
&lt;p&gt;3、看完了视频，实验程序怎么跑起来？怎么开始写下第一行代码？&lt;/p&gt;
&lt;p&gt;准备一点Go语言的基础，开始做时多看题目的提示，比如提示的第一点说到，让代码跑起来的第一步就是修改mr/worker.go的Worker函数，发一个RPC请求到Master，请求一个任务数据。&lt;/p&gt;
&lt;p&gt;4、论文、课程和题目都是英文版的，看不懂怎么办？&lt;/p&gt;
&lt;p&gt;硬着头皮看，不懂的就去翻译，当然可以看中文版，网上有很多资源。&lt;a href=&quot;https://www.bilibili.com/video/BV1R7411t71W?p=2&quot;&gt;课程视频&lt;/a&gt;有热心网友做了个中文字幕，可以看中文字幕。&lt;/p&gt;
&lt;p&gt;另外，多说一句，还是推荐尽量看英文版的，并没有崇洋媚外的意思，只不过对于程序开发而言，英文能力还是一个必备技能，因为平时查问题的时候都是英文资料比较多，而且读一手的资料是最好的，这篇文章也只不过是我消化完的知识分享，有可能论文和课程里还有很多我看不到但是你看得到的东西。&lt;/p&gt;
&lt;p&gt;5、有代码链接吗？&lt;/p&gt;
&lt;p&gt;程序员名言：talk is cheep, show me the code.但是由于课程强调了尽量不要看别人的实现，也有人放到Github被MIT要求删除过，所以笔者就不共享全部代码了，如果有需要可私下交流。&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过学习前两课，完成MapReduce这个实验，对分布式系统有了一个最表面的认识，还谈不上掌握，这只是一个最简单的实验，更重点的课程和实验还在后面，路漫漫其修远兮。&lt;/p&gt;
&lt;p&gt;如果你也在学习，希望这篇文章对你有帮助。欢迎有兴趣的同学来一起学习讨论。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点个赞吧，谢谢^_^&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>聊聊服务灾备</title>
    <link href="https://hoohack.me/blog/2020/2020-02-06-talk-about-disaster-recovery/"/>
    <updated>2020-02-06T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2020/2020-02-06-talk-about-disaster-recovery/</id>
    <content type="html">&lt;p&gt;2018年，有半年的时间在做服务灾备，由于当时对这一块的知识掌握得比较零碎，直接上手实践，没有较系统地学习，在后续的工作中，通过不断实践+学习补充这一块的知识，以及反思当时的实践，逐渐明白了要做灾备的原因和这么做的理由。在此写下自己的小小总结。&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E7%81%BE%E5%A4%87%EF%BC%9F&quot; tabindex=&quot;-1&quot;&gt;为什么要做灾备？&lt;/h2&gt;
&lt;p&gt;当时开始要做灾备的原因，是因为有一次机房A故障了，当时大部分的服务都不可以用：时长上涨、接口失败，原因是：&lt;/p&gt;
&lt;p&gt;1、很多服务都部署到A机房了，导致大部分服务不可用&lt;/p&gt;
&lt;p&gt;2、服务依赖的数据服务（MySQL、Redis）是单点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/02/SinglePointDeploy.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;出现的问题表现是：时长上涨和接口失败，导致了页面不可用、服务受损。&lt;/p&gt;
&lt;p&gt;这个问题的根本原因是出现服务单点的情况，没有备用的服务可以切换，导致请求/服务上游一直等待，等待一定时间后，就失败了。&lt;/p&gt;
&lt;p&gt;知道问题的根本原因后，解决问题的核心方向就是解决单点问题，解决单点问题的方案有：服务冗余（多一份可用的服务），做灾备。&lt;/p&gt;
&lt;h2 id=&quot;%E4%BB%80%E4%B9%88%E6%98%AF%E7%81%BE%E5%A4%87&quot; tabindex=&quot;-1&quot;&gt;什么是灾备&lt;/h2&gt;
&lt;p&gt;灾备，简单点说，就是生产环境上部署的服务，假如有一个服务（集群）挂了，有另一个地方的同一个服务（集群）可以继续使用。&lt;/p&gt;
&lt;p&gt;灾备分主备和双活两种部署。假设有两个机房A、B。&lt;/p&gt;
&lt;p&gt;主备：大部分流量都会到主集群A上，当A挂了，备点B能承担主集群的角色；&lt;/p&gt;
&lt;p&gt;双活：流量会平均分配到A、B两个机房，两个机房都能正常对外服务。&lt;/p&gt;
&lt;h2 id=&quot;%E5%A6%82%E4%BD%95%E5%81%9A%E4%B8%80%E4%B8%AA%E5%90%88%E7%90%86%E7%9A%84%E7%81%BE%E5%A4%87&quot; tabindex=&quot;-1&quot;&gt;如何做一个合理的灾备&lt;/h2&gt;
&lt;p&gt;怎么去做一个合理的灾备呢？&lt;/p&gt;
&lt;p&gt;笔者结合自己的工作经历及理论知识，觉得做灾备主要是以下的几点，如果还有其他遗漏的，还望各位指正。&lt;/p&gt;
&lt;h3 id=&quot;%E4%B8%80%E3%80%81%E4%B8%9A%E5%8A%A1%E6%A2%B3%E7%90%86&quot; tabindex=&quot;-1&quot;&gt;一、业务梳理&lt;/h3&gt;
&lt;p&gt;个人觉得，对于业务方来说，做一个应用的灾备最重要的一点就是业务梳理。理由如下：&lt;/p&gt;
&lt;p&gt;1、达到需要做灾备的业务，通常都是存活了有一定时间的业务，这些业务都会由于各种因素而有一些在做灾备时觉得不合理的设计，简称历史原因。这些历史原因有：依赖的服务单点；依赖的数据存储系统单点；依赖的服务无法做灾备等等。这些原因，如果没有解决完，那么业务方也无法完成灾备。&lt;/p&gt;
&lt;p&gt;2、不熟悉业务，对里面的逻辑不清楚，就不知道如果服务异常会导致什么问题发生，贸然去做灾备，等到真正有异常时，可能会发现没有达到预期的效果。&lt;/p&gt;
&lt;p&gt;业务梳理，需要检查以下几个要点：&lt;/p&gt;
&lt;p&gt;1、业务有多少个依赖服务？依赖服务是否还有其他的依赖？&lt;/p&gt;
&lt;p&gt;2、依赖服务的灾备情况如何？双活还是单点？&lt;/p&gt;
&lt;p&gt;3、依赖服务是否支持重试？重试失败怎么处理？&lt;/p&gt;
&lt;p&gt;4、业务使用了什么数据存储系统？部署情况如何？纯DB还是有Redis？主从还是多主？是否支持自动切换主库？&lt;/p&gt;
&lt;p&gt;5、业务用到的数据存储系统的灾备情况如何？是否满足灾备？是否支持分布式？&lt;/p&gt;
&lt;p&gt;6、依赖的服务是否可降级？降级是否可以返回默认值？返回默认值对业务是否有损？&lt;/p&gt;
&lt;p&gt;7、依赖服务多次重试依然失败，是否可以熔断？熔断对业务是否有损？&lt;/p&gt;
&lt;p&gt;业务梳理完成之后，再根据对应不满足的点去完成，直到所有情况都考虑完成了或者使用折中的方案来解决。&lt;/p&gt;
&lt;h3 id=&quot;%E4%BA%8C%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1&quot; tabindex=&quot;-1&quot;&gt;二、&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1&quot;&gt;负载均衡&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;负载均衡的意思是将流量负载分布到多台服务器，从而提高程序的性能和可靠性。通过负载均衡技术，可以分发集中的流量，可以解决两种情况：&lt;/p&gt;
&lt;p&gt;1、流量暴涨，所有流量到一台机器，将应用拖垮&lt;/p&gt;
&lt;p&gt;2、其中一个集群的所有应用挂了，可以将流量转发到另一个集群&lt;/p&gt;
&lt;p&gt;注：在笔者实践负载均衡的经历中，使用到最多的就是nginx的负载均衡配置，将多个集群的机器添加到nginx配置的upstream中，nginx会根据配置文件中指定的策略来分发流量。&lt;/p&gt;
&lt;h3 id=&quot;%E4%B8%89%E3%80%81%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7&quot; tabindex=&quot;-1&quot;&gt;三、服务降级&lt;/h3&gt;
&lt;p&gt;服务降级：简单地说，就是如果服务异常，停掉不重要的服务，只返回部分数据。&lt;/p&gt;
&lt;p&gt;比如说，一个用户信息接口，包含以下三个字段：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;id&amp;quot;: 111,
    &amp;quot;nickName&amp;quot;: &amp;quot;hhq&amp;quot;,
    &amp;quot;userLogo&amp;quot;: &amp;quot;https://www.test.com/test.jpg&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果头像暂时获取失败，如果返回默认头像用户可以接受，那么就降级返回默认的头像，这样既不会使得整个接口失败导致无法进行后续的操作，也不会影响用户体验。&lt;/p&gt;
&lt;h3 id=&quot;%E5%9B%9B%E3%80%81%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD&quot; tabindex=&quot;-1&quot;&gt;四、服务熔断&lt;/h3&gt;
&lt;p&gt;熔断：这个概念参考电路的保险丝，如果电力负载过高，达到保险丝熔断，保险丝就会自身熔断切断电源，保护电路安全运行。而互联网中的服务熔断，是指依赖服务由于各种因素变得不可用或者响应过慢，业务方为了整个服务的稳定性，不再继续调用目标服务，直接返回，如果依赖服务恢复了，则恢复调用。&lt;/p&gt;
&lt;p&gt;注意，熔断和降级看似很相似，但却是不一样的概念，应该理解为从属关系：&lt;/p&gt;
&lt;p&gt;1、服务降级有多种降级方式，如限流降级、熔断降级&lt;/p&gt;
&lt;p&gt;2、熔断是降级的其中一种方式&lt;/p&gt;
&lt;p&gt;在熔断降级的实践中，笔者用到最多的是&lt;a href=&quot;https://github.com/Netflix/Hystrix&quot;&gt;Hystrix&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;%E4%BA%94%E3%80%81%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0&quot; tabindex=&quot;-1&quot;&gt;五、&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0&quot;&gt;服务发现&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;服务发现：自动检测一个计算机网络内的设备机器提供的服务。&lt;/p&gt;
&lt;p&gt;服务发现有一个服务中间者维护服务与业务方之间的关系，服务将地址注册到服务中间者，业务方从服务中介中查找需要调用的服务的地址。&lt;/p&gt;
&lt;p&gt;上面提到，最初开始做灾备是通过nginx的负载均衡来实现，这种方式在服务部署和扩容时需要修改配置文件，需要自己维护网络中的机器，一旦不小心配置错误，整个服务就崩了。如果使用服务发现，由服务发现的中介维护服务地址，配置时只需要知道服务发现的域名和服务名称即可，不需要关心具体的机器是哪一些。&lt;/p&gt;
&lt;p&gt;实践过程中，用到的服务发现组件有：Zuul和spring-cloud。&lt;/p&gt;
&lt;h3 id=&quot;%E5%85%AD%E3%80%81%E6%BC%94%E7%BB%83&quot; tabindex=&quot;-1&quot;&gt;六、演练&lt;/h3&gt;
&lt;p&gt;如果以上的步骤都完成了，那么就完成灾备了吗？并不是的。&lt;/p&gt;
&lt;p&gt;现实情况下，很多时候是因为出现了单点故障，才会想到要去做灾备。或者其他服务出现了故障，自身的服务也要检查并完成灾备。那么怎么检查自己的服务已经完成灾备了呢？总不可能等待下次的故障到来才去验证。这种情况下，需要多做服务的灾备演练，根据已做的灾备要点，逐步演练，如果发现遗漏点，重新梳理，继续业务灾备，重新演练。不断循环，直到随时演练都能快速恢复并最小地影响业务或者业务完全无感知才算完成了灾备。&lt;/p&gt;
&lt;h2 id=&quot;%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91&quot; tabindex=&quot;-1&quot;&gt;踩过的坑&lt;/h2&gt;
&lt;p&gt;以上的这些理论是多次反复实践得出的总结，以笔者自己做灾备的经历，给大家分享我遇到过的两个比较大的坑。&lt;/p&gt;
&lt;h3 id=&quot;%E7%9C%9F%E7%9A%84%E5%8F%AA%E6%98%AF%E9%87%8D%E8%AF%95%E5%B0%B1%E5%AE%8C%E4%BA%86%E5%90%97%EF%BC%9F%E6%B5%81%E9%87%8F%E6%9A%B4%E6%B6%A8%EF%BC%8C%E6%8B%96%E5%9E%AE%E6%9C%8D%E5%8A%A1&quot; tabindex=&quot;-1&quot;&gt;真的只是重试就完了吗？流量暴涨，拖垮服务&lt;/h3&gt;
&lt;p&gt;接口A，依赖服务B，B依赖服务C，部署情况如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/02/MultiRetryDeploy.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;当时做了双活+网关重试+负载均衡的部署，出现的情况是B-&amp;gt;C超时，导致A接口响应太慢，这里B-&amp;gt;C有两次重试，A-&amp;gt;B也有两次重试，接口超时时间太长，网关判断接口失败，于是也做了两次重试，最终的结果是，同一个接口，有&lt;code&gt;2*2*2=8&lt;/code&gt;倍的流量，导致服务C的请求量暴涨，于是将服务C的进程池耗尽，服务499了，最终接口A一直都是失败，直到B-&amp;gt;C之间的网络恢复才正常。&lt;/p&gt;
&lt;p&gt;这次的故障得出的结论是：&lt;/p&gt;
&lt;p&gt;1、重试不能单纯加上就完事了，需要看下游的依赖是否满足重试&lt;/p&gt;
&lt;p&gt;2、重试多次失败后就需要加熔断降级&lt;/p&gt;
&lt;p&gt;3、重要的接口，除了重试以外，还可以做部分数据降级提高接口高可用性&lt;/p&gt;
&lt;h3 id=&quot;%E6%9C%BA%E6%88%BF%E6%9C%8D%E5%8A%A1%E2%80%9C%E5%AD%A4%E5%B2%9B%E2%80%9D&quot; tabindex=&quot;-1&quot;&gt;机房服务“孤岛”&lt;/h3&gt;
&lt;p&gt;有接口A，B、C两个服务，A-B之间通过外网相连，B-C之间通过内网相连。异常情况是B-C之间网络不通，外网流量通过接口A进入到B，B依赖C，但是B-C之间不通，B调用C会不断重试，直到全部重试都失败了，才会返回网络错误。这样一来，接口A并不知道B服务失败，用户侧体验是一直等待，然后显示失败。理想的做法是希望能在B-C网络不通的情况下将后续到来的流量拒绝掉，快速响应失败的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2020/02/IsolatedIsland.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;要做到这一点，就需要让服务B“自杀”，如果应用侧发现B-C之间的网络出现异常，就让B返回失败错误码，不再进行重试。&lt;/p&gt;
&lt;h2 id=&quot;%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9&quot; tabindex=&quot;-1&quot;&gt;需要注意的点&lt;/h2&gt;
&lt;h3 id=&quot;%E4%B8%8D%E8%83%BD%E8%84%B1%E7%A6%BB%E4%B8%9A%E5%8A%A1&quot; tabindex=&quot;-1&quot;&gt;不能脱离业务&lt;/h3&gt;
&lt;p&gt;众所周知，开发大部分的时间都需要赶需求，一方面需求多到无法挤出时间完成灾备的任务，另一方面灾备工作如果不完成，出现故障之后就会影响业务了。因此通常会将这类需求当作技术需求来完成，业务开发人员没有时间完成灾备工作时，就会让一些负责技术需求的开发来直接完成灾备。上面提到，完成灾备最重要的一点就是需要梳理业务，如果由一个完成不懂该业务的开发去完成灾备，那么至少需要花1-2天去阅读代码，理清业务逻辑和列出可能出现的坑才能完成这份工作。但是笔者觉得这样做的效率是比较低的。首先，人无完人，虽然代码大家都能看懂，但是由一个未参与过业务的开发重新梳理，难免会有遗漏的地方（即使问相应的业务开发，也有可能会遗漏）；其次，重新熟悉业务也需要投入一定的时间。&lt;/p&gt;
&lt;p&gt;所以，做灾备是不能脱离业务的，应该给业务开发匀出相应的时间完成服务灾备，提高服务稳定性，这对业务而言，出现故障时不影响用户的使用，用户无感知，就是提高用户的体验。&lt;/p&gt;
&lt;h3 id=&quot;%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4&quot; tabindex=&quot;-1&quot;&gt;自动化运维&lt;/h3&gt;
&lt;p&gt;在笔者的灾备经历中，如果机器出现故障/机房故障/流量暴涨，都需要运维和相应的业务开发人工介入判断是否需要扩容或摘除机器。但是人的判读是主观的，对是否需要扩容以及机器的选择可能会有判断出错的时候，灾备的工作，如果能结合现在较成熟k8s进行自动化运维，那么将达到事半功倍的效果。&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;灾备，对于服务稳定性而言十分重要，但是也不是一朝一夕能完成的。个人觉得核心要点就是尽最大努力消除单点故障：服务单点、数据系统单点等等。&lt;/p&gt;
&lt;p&gt;以上的文字理论仅仅是笔者经历过的小小总结，也许仍未做到最好的灾备级别，还需要日后不断实践来提升这部分的知识，如果有说错的地方，还望各位指正。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点个赞吧，谢谢^_^&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>理解Redis的内存回收机制</title>
    <link href="https://hoohack.me/blog/2019/2019-06-24-redis-expire-strategy/"/>
    <updated>2019-06-24T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2019/2019-06-24-redis-expire-strategy/</id>
    <content type="html">&lt;p&gt;之前看到过一道面试题：Redis的过期策略都有哪些？内存淘汰机制都有哪些？手写一下LRU代码实现？笔者结合在工作上遇到的问题学习分析，希望看完这篇文章能对大家有所帮助。&lt;/p&gt;
&lt;h2 id=&quot;%E4%BB%8E%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%8F%AF%E6%8F%8F%E8%BF%B0%E7%9A%84%E6%95%85%E9%9A%9C%E8%AF%B4%E8%B5%B7&quot; tabindex=&quot;-1&quot;&gt;从一次不可描述的故障说起&lt;/h2&gt;
&lt;p&gt;问题描述：一个依赖于定时器任务的生成的接口列表数据，时而有，时而没有。&lt;/p&gt;
&lt;h3 id=&quot;%E6%80%80%E7%96%91%E6%98%AFredis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5&quot; tabindex=&quot;-1&quot;&gt;怀疑是Redis过期删除策略&lt;/h3&gt;
&lt;p&gt;排查过程长，因为手动执行定时器，set数据没有报错，但是set数据之后不生效。&lt;/p&gt;
&lt;p&gt;set没报错，但是set完再查的情况下没数据，开始怀疑Redis的过期删除策略（准确来说应该是Redis的内存回收机制中的数据淘汰策略触发内存上限淘汰数据。），导致新加入Redis的数据都被丢弃了。最终发现故障的原因是因为配置错了，导致数据写错地方，并不是Redis的内存回收机制引起。&lt;/p&gt;
&lt;p&gt;通过这次故障后思考总结，如果下一次遇到类似的问题，在怀疑Redis的内存回收之后，如何有效地证明它的正确性？如何快速证明猜测的正确与否？以及什么情况下怀疑内存回收才是合理的呢？下一次如果再次遇到类似问题，就能够更快更准地定位问题的原因。另外，Redis的内存回收机制原理也需要掌握，明白是什么，为什么。&lt;/p&gt;
&lt;p&gt;花了点时间查阅资料研究Redis的内存回收机制，并阅读了内存回收的实现代码，通过代码结合理论，给大家分享一下Redis的内存回收机制。&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%EF%BC%9F&quot; tabindex=&quot;-1&quot;&gt;为什么需要内存回收？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1、在Redis中，set指令可以指定key的过期时间，当过期时间到达以后，key就失效了；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2、Redis是基于内存操作的，所有的数据都是保存在内存中，一台机器的内存是有限且很宝贵的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于以上两点，为了保证Redis能继续提供可靠的服务，Redis需要一种机制清理掉不常用的、无效的、多余的数据，失效后的数据需要及时清理，这就需要内存回收了。&lt;/p&gt;
&lt;h2 id=&quot;redis%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6&quot; tabindex=&quot;-1&quot;&gt;Redis的内存回收机制&lt;/h2&gt;
&lt;p&gt;Redis的内存回收主要分为过期删除策略和内存淘汰策略两部分。&lt;/p&gt;
&lt;h3 id=&quot;%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5&quot; tabindex=&quot;-1&quot;&gt;过期删除策略&lt;/h3&gt;
&lt;p&gt;删除达到过期时间的key。&lt;/p&gt;
&lt;h4 id=&quot;1%E3%80%81%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4&quot; tabindex=&quot;-1&quot;&gt;1、定时删除&lt;/h4&gt;
&lt;p&gt;对于每一个设置了过期时间的key都会创建一个定时器，一旦到达过期时间就立即删除。该策略可以立即清除过期的数据，对内存较友好，但是缺点是占用了大量的CPU资源去处理过期的数据，会影响Redis的吞吐量和响应时间。&lt;/p&gt;
&lt;h4 id=&quot;2%E3%80%81%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4&quot; tabindex=&quot;-1&quot;&gt;2、惰性删除&lt;/h4&gt;
&lt;p&gt;当访问一个key时，才判断该key是否过期，过期则删除。该策略能最大限度地节省CPU资源，但是对内存却十分不友好。有一种极端的情况是可能出现大量的过期key没有被再次访问，因此不会被清除，导致占用了大量的内存。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在计算机科学中，懒惰删除（英文：lazy deletion）指的是从一个散列表（也称哈希表）中删除元素的一种方法。在这个方法中，删除仅仅是指标记一个元素被删除，而不是整个清除它。被删除的位点在插入时被当作空元素，在搜索之时被当作已占据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;3%E3%80%81%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4&quot; tabindex=&quot;-1&quot;&gt;3、定期删除&lt;/h4&gt;
&lt;p&gt;每隔一段时间，扫描Redis中过期key字典，并清除部分过期的key。该策略是前两者的一个折中方案，还可以通过调整定时扫描的时间间隔和每次扫描的限定耗时，在不同情况下使得CPU和内存资源达到最优的平衡效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在Redis中，同时使用了定期删除和惰性删除。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E5%8E%9F%E7%90%86&quot; tabindex=&quot;-1&quot;&gt;过期删除策略原理&lt;/h3&gt;
&lt;p&gt;为了大家听起来不会觉得疑惑，在正式介绍过期删除策略原理之前，先给大家介绍一点可能会用到的相关Redis基础知识。&lt;/p&gt;
&lt;h4 id=&quot;redisdb%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89&quot; tabindex=&quot;-1&quot;&gt;redisDb结构体定义&lt;/h4&gt;
&lt;p&gt;我们知道，Redis是一个键值对数据库，对于每一个redis数据库，redis使用一个redisDb的结构体来保存，它的结构如下：&lt;/p&gt;
&lt;p&gt;typedef struct redisDb {
dict &lt;em&gt;dict;                 /&lt;/em&gt; 数据库的键空间，保存数据库中的所有键值对 */
dict &lt;em&gt;expires;              /&lt;/em&gt; 保存所有过期的键 &lt;em&gt;/
dict &lt;em&gt;blocking_keys;        /&lt;/em&gt; Keys with clients waiting for data (BLPOP)&lt;/em&gt;/
dict &lt;em&gt;ready_keys;           /&lt;/em&gt; Blocked keys that received a PUSH */
dict &lt;em&gt;watched_keys;         /&lt;/em&gt; WATCHED keys for MULTI/EXEC CAS &lt;em&gt;/
int id;                     /&lt;/em&gt; 数据库ID字段，代表不同的数据库 &lt;em&gt;/
long long avg_ttl;          /&lt;/em&gt; Average TTL, just for stats */
} redisDb;&lt;/p&gt;
&lt;p&gt;从结构定义中我们可以发现，对于每一个Redis数据库，都会使用一个字典的数据结构来保存每一个键值对，dict的结构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2019/06/redis_dict_struct.png&quot; alt=&quot;dict struct&quot; /&gt;&lt;/p&gt;
&lt;p&gt;以上就是过期策略实现时用到比较核心的数据结构。程序=数据结构+算法，介绍完数据结构以后，接下来继续看看处理的算法是怎样的。&lt;/p&gt;
&lt;h4 id=&quot;expires%E5%B1%9E%E6%80%A7&quot; tabindex=&quot;-1&quot;&gt;expires属性&lt;/h4&gt;
&lt;p&gt;redisDb定义的第二个属性是expires，它的类型也是字典，Redis会把所有过期的键值对加入到expires，之后再通过定期删除来清理expires里面的值。加入expires的场景有：&lt;/p&gt;
&lt;p&gt;1、set指定过期时间expire&lt;/p&gt;
&lt;p&gt;如果设置key的时候指定了过期时间，Redis会将这个key直接加入到expires字典中，并将超时时间设置到该字典元素。&lt;/p&gt;
&lt;p&gt;2、调用expire命令&lt;/p&gt;
&lt;p&gt;显式指定某个key的过期时间&lt;/p&gt;
&lt;p&gt;3、恢复或修改数据&lt;/p&gt;
&lt;p&gt;从Redis持久化文件中恢复文件或者修改key，如果数据中的key已经设置了过期时间，就将这个key加入到expires字典中&lt;/p&gt;
&lt;p&gt;以上这些操作都会将过期的key保存到expires。redis会定期从expires字典中清理过期的key。&lt;/p&gt;
&lt;h4 id=&quot;redis%E6%B8%85%E7%90%86%E8%BF%87%E6%9C%9Fkey%E7%9A%84%E6%97%B6%E6%9C%BA&quot; tabindex=&quot;-1&quot;&gt;Redis清理过期key的时机&lt;/h4&gt;
&lt;p&gt;1、Redis在启动的时候，会注册两种事件，一种是时间事件，另一种是文件事件。（可参考&lt;a href=&quot;https://www.hoohack.me/2018/05/26/read-redis-src-how-server-start&quot;&gt;启动Redis的时候，Redis做了什么&lt;/a&gt;）时间事件主要是Redis处理后台操作的一类事件，比如客户端超时、删除过期key；文件事件是处理请求。&lt;/p&gt;
&lt;p&gt;在时间事件中，redis注册的回调函数是serverCron，在定时任务回调函数中，通过调用databasesCron清理部分过期key。（这是定期删除的实现。）&lt;/p&gt;
&lt;p&gt;int serverCron(struct aeEventLoop *eventLoop, long long id, void &lt;em&gt;clientData)
{
…
/&lt;/em&gt; Handle background operations on Redis databases. */
databasesCron();
...
}&lt;/p&gt;
&lt;p&gt;2、每次访问key的时候，都会调用expireIfNeeded函数判断key是否过期，如果是，清理key。（这是惰性删除的实现。）&lt;/p&gt;
&lt;p&gt;robj *lookupKeyRead(redisDb *db, robj *key) {
robj *val;
expireIfNeeded(db,key);
val = lookupKey(db,key);
...
return val;
}&lt;/p&gt;
&lt;p&gt;3、每次事件循环执行时，主动清理部分过期key。（这也是惰性删除的实现。）&lt;/p&gt;
&lt;p&gt;void aeMain(aeEventLoop *eventLoop) {
eventLoop-&amp;gt;stop = 0;
while (!eventLoop-&amp;gt;stop) {
if (eventLoop-&amp;gt;beforesleep != NULL)
eventLoop-&amp;gt;beforesleep(eventLoop);
aeProcessEvents(eventLoop, AE_ALL_EVENTS);
}
}&lt;/p&gt;
&lt;p&gt;void beforeSleep(struct aeEventLoop &lt;em&gt;eventLoop) {
...
/&lt;/em&gt; Run a fast expire cycle (the called function will return
- ASAP if a fast cycle is not needed). */
if (server.active_expire_enabled &amp;amp;&amp;amp; server.masterhost == NULL)
activeExpireCycle(ACTIVE_EXPIRE_CYCLE_FAST);
...
}&lt;/p&gt;
&lt;h4 id=&quot;%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E7%9A%84%E5%AE%9E%E7%8E%B0&quot; tabindex=&quot;-1&quot;&gt;过期策略的实现&lt;/h4&gt;
&lt;p&gt;我们知道，Redis是以单线程运行的，在清理key是不能占用过多的时间和CPU，需要在尽量不影响正常的服务情况下，进行过期key的清理。过期清理的算法如下：&lt;/p&gt;
&lt;p&gt;1、server.hz配置了serverCron任务的执行周期，默认是10，即CPU空闲时每秒执行十次。
2、每次清理过期key的时间不能超过CPU时间的25%：timelimit = 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100;
比如，如果hz=1，一次清理的最大时间为250ms，hz=10，一次清理的最大时间为25ms。
3、如果是快速清理模式（在beforeSleep函数调用），则一次清理的最大时间是1ms。
4、依次遍历所有的DB。
5、从db的过期列表中随机取20个key，判断是否过期，如果过期，则清理。
6、如果有5个以上的key过期，则重复步骤5，否则继续处理下一个db
7、在清理过程中，如果达到CPU的25%时间，退出清理过程。&lt;/p&gt;
&lt;p&gt;从实现的算法中可以看出，这只是基于概率的简单算法，且是随机的抽取，因此是无法删除所有的过期key，通过调高hz参数可以提升清理的频率，过期key可以更及时的被删除，但hz太高会增加CPU时间的消耗。&lt;/p&gt;
&lt;h4 id=&quot;%E5%88%A0%E9%99%A4key&quot; tabindex=&quot;-1&quot;&gt;删除key&lt;/h4&gt;
&lt;p&gt;Redis4.0以前，删除指令是del，del会直接释放对象的内存，大部分情况下，这个指令非常快，没有任何延迟的感觉。但是，如果删除的key是一个非常大的对象，比如一个包含了千万元素的hash，那么删除操作就会导致单线程卡顿，Redis的响应就慢了。为了解决这个问题，在Redis4.0版本引入了unlink指令，能对删除操作进行“懒”处理，将删除操作丢给后台线程，由后台线程来异步回收内存。&lt;/p&gt;
&lt;p&gt;实际上，在判断key需要过期之后，真正删除key的过程是先广播expire事件到从库和AOF文件中，然后在根据redis的配置决定立即删除还是异步删除。&lt;/p&gt;
&lt;p&gt;如果是立即删除，Redis会立即释放key和value占用的内存空间，否则，Redis会在另一个bio线程中释放需要延迟删除的空间。&lt;/p&gt;
&lt;h4 id=&quot;%E5%B0%8F%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;小结&lt;/h4&gt;
&lt;p&gt;总的来说，Redis的过期删除策略是在启动时注册了serverCron函数，每一个时间时钟周期，都会抽取expires字典中的部分key进行清理，从而实现定期删除。另外，Redis会在访问key时判断key是否过期，如果过期了，就删除，以及每一次Redis访问事件到来时，beforeSleep都会调用activeExpireCycle函数，在1ms时间内主动清理部分key，这是惰性删除的实现。&lt;/p&gt;
&lt;p&gt;Redis结合了定期删除和惰性删除，基本上能很好的处理过期数据的清理，但是实际上还是有点问题的，如果过期key较多，定期删除漏掉了一部分，而且也没有及时去查，即没有走惰性删除，那么就会有大量的过期key堆积在内存中，导致redis内存耗尽，当内存耗尽之后，有新的key到来会发生什么事呢？是直接抛弃还是其他措施呢？有什么办法可以接受更多的key？&lt;/p&gt;
&lt;h3 id=&quot;%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5&quot; tabindex=&quot;-1&quot;&gt;内存淘汰策略&lt;/h3&gt;
&lt;p&gt;Redis的内存淘汰策略，是指内存达到maxmemory极限时，使用某种算法来决定清理掉哪些数据，以保证新数据的存入。&lt;/p&gt;
&lt;h4 id=&quot;redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6&quot; tabindex=&quot;-1&quot;&gt;Redis的内存淘汰机制&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错。&lt;/li&gt;
&lt;li&gt;allkeys-lru：当内存不足以容纳新写入数据时，在键空间（&lt;code&gt;server.db[i].dict&lt;/code&gt;）中，移除最近最少使用的 key（这个是最常用的）。&lt;/li&gt;
&lt;li&gt;allkeys-random：当内存不足以容纳新写入数据时，在键空间（&lt;code&gt;server.db[i].dict&lt;/code&gt;）中，随机移除某个 key。&lt;/li&gt;
&lt;li&gt;volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（&lt;code&gt;server.db[i].expires&lt;/code&gt;）中，移除最近最少使用的 key。&lt;/li&gt;
&lt;li&gt;volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（&lt;code&gt;server.db[i].expires&lt;/code&gt;）中，随机移除某个 key。&lt;/li&gt;
&lt;li&gt;volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（&lt;code&gt;server.db[i].expires&lt;/code&gt;）中，有更早过期时间的 key 优先移除。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在配置文件中，通过maxmemory-policy可以配置要使用哪一个淘汰机制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%BF%9B%E8%A1%8C%E6%B7%98%E6%B1%B0%EF%BC%9F&quot; tabindex=&quot;-1&quot;&gt;什么时候会进行淘汰？&lt;/h4&gt;
&lt;p&gt;Redis会在每一次处理命令的时候（processCommand函数调用freeMemoryIfNeeded）判断当前redis是否达到了内存的最大限制，如果达到限制，则使用对应的算法去处理需要删除的key。伪代码如下：&lt;/p&gt;
&lt;p&gt;int processCommand(client *c)
{
...
if (server.maxmemory) {
int retval = freeMemoryIfNeeded();&lt;br /&gt;
}
...
}&lt;/p&gt;
&lt;h4 id=&quot;lru%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86&quot; tabindex=&quot;-1&quot;&gt;LRU实现原理&lt;/h4&gt;
&lt;p&gt;在淘汰key时，Redis默认最常用的是LRU算法（Latest Recently Used）。Redis通过在每一个redisObject保存lru属性来保存key最近的访问时间，在实现LRU算法时直接读取key的lru属性。&lt;/p&gt;
&lt;p&gt;具体实现时，Redis遍历每一个db，从每一个db中随机抽取一批样本key，默认是3个key，再从这3个key中，删除最近最少使用的key。实现伪代码如下：&lt;/p&gt;
&lt;p&gt;keys = getSomeKeys(dict, sample)
key = findSmallestIdle(keys)
remove(key)&lt;/p&gt;
&lt;p&gt;3这个数字是配置文件中的maxmeory-samples字段，也是可以可以设置采样的大小，如果设置为10，那么效果会更好，不过也会耗费更多的CPU资源。&lt;/p&gt;
&lt;p&gt;以上就是Redis内存回收机制的原理介绍，了解了上面的原理介绍后，回到一开始的问题，在怀疑Redis内存回收机制的时候能不能及时判断故障是不是因为Redis的内存回收机制导致的呢？&lt;/p&gt;
&lt;h2 id=&quot;%E5%9B%9E%E5%88%B0%E9%97%AE%E9%A2%98%E5%8E%9F%E7%82%B9&quot; tabindex=&quot;-1&quot;&gt;回到问题原点&lt;/h2&gt;
&lt;p&gt;如何证明故障是不是由内存回收机制引起的？&lt;/p&gt;
&lt;p&gt;根据前面分析的内容，如果set没有报错，但是不生效，只有两种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、设置的过期时间过短，比如，1s？&lt;/li&gt;
&lt;li&gt;2、内存超过了最大限制，且设置的是noeviction或者allkeys-random。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，在遇到这种情况，首先看set的时候是否加了过期时间，且过期时间是否合理，如果过期时间较短，那么应该检查一下设计是否合理。&lt;/p&gt;
&lt;p&gt;如果过期时间没问题，那就需要查看Redis的内存使用率，查看Redis的配置文件或者在Redis中使用info命令查看Redis的状态，maxmemory属性查看最大内存值。如果是0，则没有限制，此时是通过total_system_memory限制，对比used_memory与Redis最大内存，查看内存使用率。&lt;/p&gt;
&lt;p&gt;如果当前的内存使用率较大，那么就需要查看是否有配置最大内存，如果有且内存超了，那么就可以初步判定是内存回收机制导致key设置不成功，还需要查看内存淘汰算法是否noeviction或者allkeys-random，如果是，则可以确认是redis的内存回收机制导致。如果内存没有超，或者内存淘汰算法不是上面的两者，则还需要看看key是否已经过期，通过ttl查看key的存活时间。如果运行了程序，set没有报错，则ttl应该马上更新，否则说明set失败，如果set失败了那么就应该查看操作的程序代码是否正确了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2019/06/trouble_process.png&quot; alt=&quot;trouble_process&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;Redis对于内存的回收有两种方式，一种是过期key的回收，另一种是超过redis的最大内存后的内存释放。&lt;/p&gt;
&lt;p&gt;对于第一种情况，Redis会在：&lt;/p&gt;
&lt;p&gt;1、每一次访问的时候判断key的过期时间是否到达，如果到达，就删除key&lt;/p&gt;
&lt;p&gt;2、redis启动时会创建一个定时事件，会定期清理部分过期的key，默认是每秒执行十次检查，每次过期key清理的时间不超过CPU时间的25%，即若hz=1，则一次清理时间最大为250ms，若hz=10，则一次清理时间最大为25ms。&lt;/p&gt;
&lt;p&gt;对于第二种情况，redis会在每次处理redis命令的时候判断当前redis是否达到了内存的最大限制，如果达到限制，则使用对应的算法去处理需要删除的key。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2019/06/understanding-redis-recall.png&quot; alt=&quot;理解Redis内存回收机制&quot; /&gt;&lt;/p&gt;
&lt;p&gt;看完这篇文章后，你能回答文章开头的面试题了吗？&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%9D%E8%80%83&quot; tabindex=&quot;-1&quot;&gt;思考&lt;/h2&gt;
&lt;p&gt;留下一道思考题，我们知道，Redis是单线程的，单线程的redis还包含了这么多的任务每一次处理命令的线程都包含：处理命令、清理过期key、处理内存回收这些任务，为什么还能这么快？里面做了什么优化？后续再探索这个问题，敬请关注。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点个赞吧，谢谢^_^&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>从不可描述的服务雪崩到初探Hystrix</title>
    <link href="https://hoohack.me/blog/2019/2019-03-11-service-crash-and-hystrix/"/>
    <updated>2019-03-11T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2019/2019-03-11-service-crash-and-hystrix/</id>
    <content type="html">&lt;p&gt;什么是服务雪崩？什么是服务保护？服务保护的措施有哪些？熔断怎么做？限流怎么做？服务隔离怎么做？降级怎么做？&lt;/p&gt;
&lt;h2 id=&quot;%E7%9C%9F%E5%AE%9E%E6%A1%88%E4%BE%8B&quot; tabindex=&quot;-1&quot;&gt;真实案例&lt;/h2&gt;
&lt;p&gt;举一个自己遇到的真实的例子。
接口A依赖了服务B，接口A的部署情况是有两个机房部署，服务B的部署情况也是两个机房部署。用户请求接口失败会重试，部署架构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2019/03/ServiceStructure.png&quot; alt=&quot;服务部署架构&quot; /&gt;&lt;/p&gt;
&lt;p&gt;说明：服务部署用到的是&lt;code&gt;Linux+Nginx+PHP&lt;/code&gt;技术栈。&lt;/p&gt;
&lt;p&gt;当时遇到的情况是服务B所在的机房挂了，导致接口A调用服务B超时，超时返回之后nginx重试到A的另一个节点，继续调用服务B，A的所有节点都失败后，返回给客户端失败结果，客户端进行重试，于是再进行一次刚刚的步骤，这些超时的请求占用了PHP的进程没有释放，同时用户侧体验感知到缓慢，于是不断刷新重试，导致流量暴涨，PHP的进程池被耗尽了，于是接口A就无法访问了，其他依赖接口A的功能也无法使用，导致整个站点雪崩。&lt;/p&gt;
&lt;p&gt;这是典型的服务没有进行隔离导致功能雪崩的例子，那么问题来了，如果要对这次的故障进行改进，为接口和服务之间加入一层服务保护，那么要怎么做呢？&lt;/p&gt;
&lt;p&gt;业界比较常见的服务保护主要有以下这些：&lt;/p&gt;
&lt;p&gt;1、限流&lt;/p&gt;
&lt;p&gt;当发现服务失败数量达到某个阈值，拒绝访问，限制更多流量的到来，防止过多失败的请求将资源耗尽。&lt;/p&gt;
&lt;p&gt;2、服务隔离&lt;/p&gt;
&lt;p&gt;将不同类型的接口隔离部署，单个类型接口的失败甚至进程池被耗尽不会影响其他接口的正常访问，比如在资讯平台中，如果发布和阅读的接口分开部署了，那么即使发布功能失效，阅读功能还能继续使用。&lt;/p&gt;
&lt;p&gt;3、熔断&lt;/p&gt;
&lt;p&gt;从接口请求连接就拒绝访问，类似家里用的保险丝，使用的电器总和超过了电压就熔断保险丝，整个电路短了，保护整个区域的电路防止更多的损失。&lt;/p&gt;
&lt;p&gt;4、降级&lt;/p&gt;
&lt;p&gt;对于简单的展示功能，如果有失败的请求，返回默认值。对于整个站点或客户端，如果服务器负载过高，将其他非核心业务停止，以让出更多资源给其他服务使用。&lt;/p&gt;
&lt;p&gt;以上是笔者所知道服务出现雪崩的情况以及保护服务的措施，在Java领域中，业界用得比较多的是Hystrix，那么就来看看它是怎么实现上面这些措施。&lt;/p&gt;
&lt;h2 id=&quot;hystrix%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F&quot; tabindex=&quot;-1&quot;&gt;Hystrix是什么？&lt;/h2&gt;
&lt;p&gt;Hystrix是一个通过增加延迟容错和容错逻辑来控制分布式服务之间交互的一个库。Hystrix通过线程隔离，防止错误级联传递，导致服务雪崩，从而提高服务稳定性。&lt;/p&gt;
&lt;h3 id=&quot;hystrix%E7%9A%84%E4%B8%BB%E8%A6%81%E7%9B%AE%E6%A0%87&quot; tabindex=&quot;-1&quot;&gt;Hystrix的主要目标&lt;/h3&gt;
&lt;p&gt;1、通过隔离第三方客户端库访问依赖关系，防止和控制延迟和故障；&lt;/p&gt;
&lt;p&gt;2、防止复杂分布式系统的级联失败；&lt;/p&gt;
&lt;p&gt;3、快速响应失败并迅速恢复；&lt;/p&gt;
&lt;p&gt;4、提供回滚以及友好降级；&lt;/p&gt;
&lt;p&gt;5、实现近实时监控，告警和操作控制&lt;/p&gt;
&lt;h3 id=&quot;hystrix%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99&quot; tabindex=&quot;-1&quot;&gt;Hystrix设计原则&lt;/h3&gt;
&lt;p&gt;1、防止单个依赖耗尽了服务容器的用户线程&lt;/p&gt;
&lt;p&gt;2、降低负载以及快速失败，而不是排队&lt;/p&gt;
&lt;p&gt;3、当可以阻止服务的失败时提供回退策略&lt;/p&gt;
&lt;p&gt;4、使用隔离技术减少任意依赖的影响&lt;/p&gt;
&lt;p&gt;5、通过近实时指标、监控和告警优化发现时间&lt;/p&gt;
&lt;p&gt;6、在Hystrix的大多数方面，通过配置更改的低延迟和对动态属性更改的支持，使得可以在低延迟的情况下进行实时修改操作，从而优化恢复时间&lt;/p&gt;
&lt;p&gt;7、防止整个依赖关系客户端执行中的故障，而不仅仅是网络流量&lt;/p&gt;
&lt;h3 id=&quot;hystrix%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E4%B8%8A%E9%9D%A2%E7%9A%84%E7%9B%AE%E6%A0%87&quot; tabindex=&quot;-1&quot;&gt;Hystrix如何做到上面的目标&lt;/h3&gt;
&lt;p&gt;1、所有外部的调用都封装到HystrixCommand或HystrixObservableCommand对象，这些对象通常在单独的线程下执行。&lt;/p&gt;
&lt;p&gt;2、超时调用的时间，超过定义的阈值。有一个默认值，但是对于大多数的依赖，你可以自定义该属性使得略高于每个依赖测量的99.5%的性能。&lt;/p&gt;
&lt;p&gt;3、为每一个依赖项维护一个线程池（或者信号），如果依赖项的线程池满了，新的依赖请求不会继续排队等待，而是马上被拒绝访问。&lt;/p&gt;
&lt;p&gt;4、计算成功、失败、超时和线程拒绝的数量。&lt;/p&gt;
&lt;p&gt;5、如果依赖服务的失败百分比超过阈值，则手动或自动启动断路器，在一段时间内停止对指定服务的所有请求。&lt;/p&gt;
&lt;p&gt;6、为请求失败、被拒绝、超时或短路情况提供回退逻辑。&lt;/p&gt;
&lt;p&gt;7、近乎实时地监控指标和配置更改。&lt;/p&gt;
&lt;h3 id=&quot;%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81demo&quot; tabindex=&quot;-1&quot;&gt;一段代码demo&lt;/h3&gt;
&lt;p&gt;讲完这么多，还是看看代码更实在，从Hystrix官网上截取了一段代码如下：&lt;/p&gt;
&lt;p&gt;public class Order {&lt;/p&gt;
&lt;p&gt;private final int orderId;
private UserAccount user;&lt;/p&gt;
&lt;p&gt;public Order(int orderId) {
this.orderId = orderId;&lt;/p&gt;
&lt;p&gt;user = new GetUserAccountCommand(new HttpCookie(&amp;quot;mockKey&amp;quot;, &amp;quot;mockValueFromHttpRequest&amp;quot;)).execute();
}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;更多代码内容：&lt;a href=&quot;https://github.com/Netflix/Hystrix/tree/master/hystrix-examples/src/main/java/com/netflix/hystrix/examples/demo&quot;&gt;https://github.com/Netflix/Hystrix/tree/master/hystrix-examples/src/main/java/com/netflix/hystrix/examples/demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上面就是Hystrix使用的实例，在实际代码中，就是new一个Command，然后调用execute方法获取结果，那么这一个过程中Hystrix做了什么呢？&lt;/p&gt;
&lt;h3 id=&quot;hystrix%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B&quot; tabindex=&quot;-1&quot;&gt;Hystrix的工作流程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2019/03/HystrixWorkFlow.png&quot; alt=&quot;服务部署架构&quot; /&gt;&lt;/p&gt;
&lt;p&gt;上面这个图是从Hystrix的官方文档中找到的，能看懂这个文档几乎就能看懂Hystrix是怎么执行的了。通过图中的顺序来解读Hystrix的执行流程。&lt;/p&gt;
&lt;p&gt;1、初始化，有两种方式初始化一个Hystrix命令，通过new HystrixCommand或者new HystrixObservableCommand创建，使用服务实例和请求服务需要的参数来构造一个Hystrix命令。&lt;/p&gt;
&lt;p&gt;2、成功创建Hystrix后，有四种方法执行实际的命令并得到返回结果。这里Hystrix还使用了响应式编程来设计，这个主题比较大，一时半会解释不出，之后再深入探索。&lt;/p&gt;
&lt;p&gt;对于使用HystrixCommand创建命令的实例，执行execute或者queue；而对于使用HystrixObservableCommand创建命令的实例，执行observe或者toObservable方法，可以请求服务然后得到执行结果。这四个方法的特性是：&lt;/p&gt;
&lt;p&gt;execute - 会阻塞，然后返回依赖服务的结果
queue - 返回一个Future，然后可以通过get方法获得依赖服务的结果。
observe - 订阅包含依赖服务响应结果的订阅器，当有结果时返回一个订阅器。
toObservable - 返回一个订阅器，当订阅它时，会知晓Hystrix命令并返回结果。&lt;/p&gt;
&lt;p&gt;execute的源码如下：&lt;/p&gt;
&lt;p&gt;public R execute() {
try {
return queue().get();
} catch (Exception e) {
throw Exceptions.sneakyThrow(decomposeException(e));
}
}&lt;/p&gt;
&lt;p&gt;public Future&amp;lt;R&amp;gt; queue() {
/*
* The Future returned by Observable.toBlocking().toFuture() does not implement the
* interruption of the execution thread when the &amp;quot;mayInterrupt&amp;quot; flag of Future.cancel(boolean) is set to true;
* thus, to comply with the contract of Future, we must wrap around it.
*/
final Future&amp;lt;R&amp;gt; delegate = toObservable().toBlocking().toFuture();
// 其他定义
}&lt;/p&gt;
&lt;p&gt;从源码看到，execute方法会调用queue().get()方法，queue()会调用toObservable().toBlocking().toFuture()，说明每一个Hystrix命令最终都回到Observable对象的实现，即使是为了返回一个简单的值。&lt;/p&gt;
&lt;p&gt;3、判断Hystrix是否启用缓存且对应请求有缓存值，则返回缓存的结果。&lt;/p&gt;
&lt;p&gt;4、如果3没有缓存，Hystrix会检查它的熔断器，如果此时熔断器开启了，那么Hystrix不会执行命令，直接返回降级结果。&lt;/p&gt;
&lt;p&gt;5、如果信号或者线程池拒绝请求，返回降级结果。&lt;/p&gt;
&lt;p&gt;6、Hystrix通过调用HystrixCommand.run()或者HystrixObservableCommand.construct()方法来触发调用外部服务的操作，如果超时或者失败，返回降级结果。
如果run或者construct方法超过了命令定义的超时值，线程会抛出TimeoutException，此时Hystrix捕捉到异常，就会忽略run或construct方法的返回值，进入fallback。&lt;/p&gt;
&lt;p&gt;注意：没有任何方式可以阻止延迟的线程停止工作，在JVM中，Hystrix可以做到最好的就是抛出一个InterruptedException，如果Hystrix封装的服务没有捕获InterruptedException，Hystrix线程池中的线程会继续它的工作。&lt;/p&gt;
&lt;p&gt;7、不管请求如何进行：成功、失败、超时、熔断，Hystrix都会上报健康状态到熔断器，记录服务状态，用于判断是否启动／半启动熔断器。&lt;/p&gt;
&lt;p&gt;8、fallback，进行降级操作，会触发回退操作的条件：
construct或者run方法抛出异常
熔断器开启
线程池以及队列或者信号容量不足
Hystrix命令超时&lt;/p&gt;
&lt;p&gt;对于每一个Hystrix命令，都需要覆盖getFallback方法，在fallback函数中实现降级的方案，如果需要在fallback中使用网络调用，那么需要通过另一个HystrixCommand或者HystrixObservableCommand。在HystrixCommand中是实现getFallback方法，在HystrixObservableCommand中，是实现sumeWithFallback方法。&lt;/p&gt;
&lt;p&gt;如果没有实现fallback方法，或者fallback方法抛出了异常，Hystrix还是会返回一个Observerable，但是不会返回内容并通过一个onError通知来马上终止。通过onError通知，发生异常的会被返回Hystrix的调用者。尽量不要写出可能会抛出异常的fallback实现。&lt;/p&gt;
&lt;p&gt;9、如果一切正常，那么Hystrix会发送成功的结果到Observable，程序再去获取。&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;以上就是Hystrix的执行流程，因为最近想了解在PHP中如何实现服务熔断，于是在学习Java中做的比较好的Hystrix是怎么实现的。接下来会继续深入学习Hystrix的熔断器实现，下次再分享Hystrix熔断器的实现原理。&lt;/p&gt;
&lt;p&gt;了解一个库的执行流程，除了有助于开发时排查遇到的较棘手的问题，还可以学习一个库的设计理念，从这些库中吸收一些框架设计优点，之后如果需要实现相关功能时，就可以作为参考。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点个赞吧，谢谢^_^&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>聊聊Hystrix中的命令模式</title>
    <link href="https://hoohack.me/blog/2019/2019-03-01-hystrix-command-pattern/"/>
    <updated>2019-03-02T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2019/2019-03-01-hystrix-command-pattern/</id>
    <content type="html">&lt;p&gt;最近在实践服务熔断时用到了Hystrix这个框架，觉得里面的设计思想挺值得学习，决定深入研究一番。在学习过程中，发现很多名词还是不太熟悉，还是需要有一些技术准备才能继续深入，第一个遇到的是设计模式中的命令模式，命令模式这个设计模式之前也学过，但是由于没有实践机会，所以很快就忘记，现在有机会来实战一次，温故而知新。&lt;/p&gt;
&lt;h2 id=&quot;%E5%AE%9A%E4%B9%89&quot; tabindex=&quot;-1&quot;&gt;定义&lt;/h2&gt;
&lt;p&gt;直接看维基百科上的定义，Command Pattern（命令模式）&lt;/p&gt;
&lt;p&gt;在面对对象编程中，命令模式是一种行为模式，其中对象用于封装执行动作或稍后触发事件所需的所有信息。这些信息包括方法名称，拥有该方法的对象以及方法参数的值。（来自维基百科）&lt;/p&gt;
&lt;p&gt;看概念直接解释名词还是比较模糊，先来看看一个具体的实例，然后再继续解释其中的名词模式的定义。&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90&quot; tabindex=&quot;-1&quot;&gt;举个例子&lt;/h2&gt;
&lt;p&gt;需求：为一个电器遥控器编程功能实现，一共开灯、关灯、开风扇、关风扇、风扇调高档、风扇调低档等6按钮。&lt;/p&gt;
&lt;p&gt;如果不用命令模式，实现可能会是在按下按钮时，传递具体的指令给遥控对象，遥控对象根据具体的指令实例化对象，并调用对应的操作。&lt;/p&gt;
&lt;p&gt;遥控器的实现代码如下所示：&lt;/p&gt;
&lt;p&gt;public class RemoteControl {&lt;/p&gt;
&lt;p&gt;private Light light;&lt;/p&gt;
&lt;p&gt;private Fan fan;&lt;/p&gt;
&lt;p&gt;public RemoteControl() {
light = new Light();
fan = new Fan();
}&lt;/p&gt;
&lt;p&gt;public void buttonPressed(String buttonName) {
if (buttonName.equals(light.getButtonTurnOnName())) {
light.on();
} else if (buttonName.equals(light.getButtonTurnOffName())) {
light.off();
} else if (buttonName.equals(fan.getButtonTurnOnName())) {
fan.on();
} else if (buttonName.equals(fan.getButtonTurnOffName())) {
fan.off();
} else if (buttonName.equals(fan.getButtonSetSpeedUpName())) {
fan.speedUp();
} else if (buttonName.equals(fan.getButtonSetSpeedDownName())) {
fan.speedDown();
}
}
}&lt;/p&gt;
&lt;p&gt;这里有个比较繁琐的一点是遥控器对象需要根据指令来调用对象的方法，如果需要为遥控器新增功能，比如对灯增加调节档数的功能，那么就需要在遥控器里增加判断，判断是否属于灯光调档的指令，然后才能完成工作。这样的缺点是遥控器始终要关注需要调用的外部服务，如果新增服务时需要改动代码，这样违背了面向接口编程的原则，同时代码也较难维护。&lt;/p&gt;
&lt;p&gt;改为使用命令模式，实现的方式是将服务的实现封装到一个对象委托出去，由命令对象来实现具体的调用。只需要将具体的执行指令遥控器，按下按钮后就会开始执行相应的指令，无需入侵业务代码。具体实现代码如下：&lt;/p&gt;
&lt;p&gt;public class RemoteControl {&lt;/p&gt;
&lt;p&gt;private Command command;&lt;/p&gt;
&lt;p&gt;public void command(Command command) {
this.command = command;
}&lt;/p&gt;
&lt;p&gt;public void buttonPressed() {
this.command.execute();
}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;public class RemoteControlRun {&lt;/p&gt;
&lt;p&gt;public static void main(String[] args) {
Light light = new Light();&lt;/p&gt;
&lt;p&gt;RemoteControl remoteControl = new RemoteControl();
remoteControl.command(new LightOnCommand(light));
remoteControl.buttonPressed();&lt;/p&gt;
&lt;p&gt;remoteControl.command(new LightOffCommand(light));
remoteControl.buttonPressed();
}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;使用命令模式实现此次代码的UML图如下，结合UML图及代码可以看出，这样一来，遥控器只需要实现的是发送执行指令就可以，执行什么指令，就由命令对象去关注这一点，具体要怎么执行，交给接收者去决定。当需要新增指令时，只需要新增命令对象，不需要对遥控器对象进行修改，实现了面向接口编程。同时也可以看到，请求者与接收者通过封装命令对象进行了解耦，当增加指令时，只需要增加命令对象，设置到遥控器，即可实现增加指令的需求，这就是命令模式中可以使用不同请求参数化对象的意思。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2019/03/LightOnCommandUML.png&quot; alt=&quot;遥控实现UML图&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E7%90%86%E8%A7%A3%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F&quot; tabindex=&quot;-1&quot;&gt;理解命令模式&lt;/h2&gt;
&lt;p&gt;在命令模式中，有四种角色：命令、接收者、调用者以及客户端。&lt;/p&gt;
&lt;p&gt;命令知道具体接收者，也是接收者具体方法的调用方。接收者方法参数的值保存在命令。&lt;/p&gt;
&lt;p&gt;执行具体方法的接收者对象通过组合的方式保存在命令对象中。&lt;/p&gt;
&lt;p&gt;接收者执行具体的调用当命令实例调用“执行”方法时。&lt;/p&gt;
&lt;p&gt;调用者对象知道如何执行命令，很有可能还会记录下执行的命令，但是调用者对具体要执行什么命令一无所知，仅仅知道的是要调用的是一个命令接口。&lt;/p&gt;
&lt;p&gt;调用者对象、命令对象、接收者对象，通通由客户端持有，客户端决定它要分配给命令对象的接收者对象，以及要分配给调用者的命令对象。&lt;/p&gt;
&lt;p&gt;客户端决定什么时候执行命令，客户端通过传递命令对象给调用者对象来执行命令。&lt;/p&gt;
&lt;p&gt;使用命令对象，使得更容易构建一些在无需知道方法的类和方法参数的情况下，需要在选择时委托、排序或执行方法调用的通用组件。&lt;/p&gt;
&lt;p&gt;使用调用者对象，允许方便地实现命令执行的簿记，以及实现由调用者对象管理的命令的不同模式，而不需要客户端知道簿记或模式的存在。&lt;/p&gt;
&lt;h3 id=&quot;%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98&quot; tabindex=&quot;-1&quot;&gt;命令模式解决的问题&lt;/h3&gt;
&lt;p&gt;**可以使用请求配置对象（调用者）。**使代码可扩展，当需要增加实现时，只需继承/实现&amp;quot;命令”，然后将具体执行的代码封装为对象，设置到调用者即可。即使用封装好的请求来配置调用者对象，无需入侵调用者的代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解耦请求者和实现者&lt;/strong&gt;，请求者不需要知道关于具体的实现者的信息以及如何实现，只需要知道的是要执行某个命令，由具体的命令去关心实现者是谁，如何调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用命令封装了请求&lt;/strong&gt;，比如开灯命令。&lt;/p&gt;
&lt;p&gt;命令模式描述的实现：
定义分开的命令对象来封装请求。
类将请求委托给命令对象而不是直接实现请求。&lt;/p&gt;
&lt;p&gt;命令模式中使用不同请求参数化对象的意思是：命令已经被封装为一个对象了，因此可以将命令设置到其他对象的属性中，这样其他对象就拥有更丰富的功能了。比如一个按钮可以是开灯的，但也可以改造内部的线路让按钮是控制音量的。&lt;/p&gt;
&lt;h3 id=&quot;%E7%BC%BA%E7%82%B9&quot; tabindex=&quot;-1&quot;&gt;缺点&lt;/h3&gt;
&lt;p&gt;命令模式的缺点就是类的数量太多，因为每一个命令都需要新建一个类。&lt;/p&gt;
&lt;h3 id=&quot;%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE&quot; tabindex=&quot;-1&quot;&gt;模式结构图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2019/03/CommandUML.png&quot; alt=&quot;命令模式UML图&quot; /&gt;&lt;/p&gt;
&lt;p&gt;当要调用外部服务时，往往不知道具体的外部服务是谁，也不知道具体做了什么操作，要做的只是指定具体的外部服务，具体要做什么时候怎么执行该操作，由接受者决定，发送者只是知道发出请求就可以。&lt;/p&gt;
&lt;h2 id=&quot;hystrix%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F&quot; tabindex=&quot;-1&quot;&gt;Hystrix中的命令模式&lt;/h2&gt;
&lt;p&gt;Hystrix使用了命令模式，以Hystrix为例，再介绍一个使用示例。
应用依赖两个服务，每个服务都提供了获取单个数据和数据列表的接口，如果需要对服务进行熔断控制，不使用命令模式的情况下的代码如下：&lt;/p&gt;
&lt;p&gt;public class SimpleHystrix {&lt;/p&gt;
&lt;p&gt;private AService aService;&lt;/p&gt;
&lt;p&gt;private BService bService;&lt;/p&gt;
&lt;p&gt;public SimpleHystrix() {
this.aService = new AService();
this.bService = new BService();
}&lt;/p&gt;
&lt;p&gt;public void call(String callName, int param) {
if (callName.equals(&amp;quot;aServiceGetSingleData&amp;quot;)) {
try {
aService.getSingleData(param);
} catch (Exception e) {
System.out.println(&amp;quot;aService getSingleData exception&amp;quot;);
}
} else if (callName.equals(&amp;quot;aServiceGetList&amp;quot;)) {
try {
aService.getList();
} catch (Exception e) {
System.out.println(&amp;quot;aService getList exception&amp;quot;);
}
} else if (callName.equals(&amp;quot;bServiceGetSingleData&amp;quot;)) {
try {
bService.getSingleData(param);
} catch (Exception e) {
System.out.println(&amp;quot;bService getSingleData exception&amp;quot;);
}
} else if (callName.equals(&amp;quot;bServiceGetList&amp;quot;)) {
try {
bService.getList();
} catch (Exception e) {
System.out.println(&amp;quot;bService getList exception&amp;quot;);
}
}
}
}&lt;/p&gt;
&lt;p&gt;很明显，如果还要添加一个服务的话，则需要多加一个服务，使用命令模式封装后的代码如下：&lt;/p&gt;
&lt;p&gt;public class SimpleHystrix {&lt;/p&gt;
&lt;p&gt;private SimpleHystrixCommand simpleHystrixCommand;&lt;/p&gt;
&lt;p&gt;public void setSimpleHystrixCommand(SimpleHystrixCommand simpleHystrixCommand) {
this.simpleHystrixCommand = simpleHystrixCommand;
}&lt;/p&gt;
&lt;p&gt;public void call() {
simpleHystrixCommand.execute();
}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;代码结构非常清晰，需要增加服务也很简单，无需入侵业务代码，只需要增加一个继承Command的类，然后在execute方法实现对应服务的调用以及其他操作即可。&lt;/p&gt;
&lt;p&gt;本次用到的demo代码可以在我的github上找到：
&lt;a href=&quot;https://github.com/hoohack/DesignPattern/tree/master/Command/Java&quot;&gt;https://github.com/hoohack/DesignPattern/tree/master/Command/Java&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;以上就是命令模式的介绍，个人觉得，想要看懂Java实现的框架或者库的源码，就先要了解设计模式，毕竟Java是一门封装性较强的语言，在很多框架和库，都是通过设计模式来提升代码的优雅性和可维护性，但是单纯地学习设计模式也较难好好掌握，甚至会经常遗忘核心原理，在需要的时候带着目的去学习是较好的掌握方式。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点个赞吧，谢谢^_^&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>GO语言泛型编程实践</title>
    <link href="https://hoohack.me/blog/2018/2018-11-19-go-generic-program-practice/"/>
    <updated>2018-11-19T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2018/2018-11-19-go-generic-program-practice/</id>
    <content type="html">&lt;p&gt;紧接着上次说到的RDB文件解析功能，数据解析步骤完成后，下一个问题就是如何保存解析出来的数据，Redis有多种数据类型，string、hash、list、zset、set，一开始想到的方案是为每一种数据定义一种数据结构，根据不同的数据类型，将数据保存到不同的数据结构，但是这样的做法带来了比较多的冗余代码，以string和hash为例，一开始的代码是这样的：&lt;/p&gt;
&lt;p&gt;type Rdb struct {
… // 其他属性
strObj      map[string]string
hashObj     map[string]map[string]string
…// 其他结构体定义
}&lt;/p&gt;
&lt;p&gt;// 保存string的函数
func (r *Rdb) saveStrObj(redisKey string, redisVal string) {
r.strObj[redisKey] = redisVal
}&lt;/p&gt;
&lt;p&gt;// 保存hash的函数
func (r *Rdb) saveHashObj(redisKey string, hashField string, hashVal string) {
item, ok := r.hashObj[redisKey]&lt;/p&gt;
&lt;p&gt;if !ok {
item = make(map[string]string)
r.hashObj[redisKey] = item
}&lt;/p&gt;
&lt;p&gt;item[hashField] = hashVal
}&lt;/p&gt;
&lt;p&gt;这种方式有比较多的冗余代码，比如保存字符串和保存哈希结构需要编写两套相似代码了，且在初始化Rdb结构体的时候，还需要初始化所有结构体之后，再传递到Rdb的初始化函数中，比如：&lt;/p&gt;
&lt;p&gt;strObj := make(map[string]string)
hashObj := make(map[string]map[string]string)
rdb := &amp;amp;Rdb{…, strObj, hashObj}&lt;/p&gt;
&lt;p&gt;这样的代码写起来比较繁琐，且不好维护，如果在更多数据类型的项目中，这样的代码看起来简直令人发指。比如在这次的实践中，redis的数据都是键值对，键的类型是固定的-字符串，但是值的类型就有map、string等等各种类型，于是乎就想到是否有泛型这种技术可以协助实现想要的功能。&lt;/p&gt;
&lt;p&gt;泛型编程&lt;/p&gt;
&lt;p&gt;泛型程序设计（generic programming）是程序设计语言的一种风格或范式。泛型允许程序员在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型。（摘自维基百科）&lt;/p&gt;
&lt;p&gt;简单地理解，泛型编程指的是不针对某一种特定的类型进行编程，一个方法不是针对了某几种特定的数据类型，而是对大部分数据类型都有效。&lt;/p&gt;
&lt;p&gt;比如开发一个加法功能，不只是支持整型做加法，浮点型、字符串、数组等等类型的加法，都可以实现。&lt;/p&gt;
&lt;p&gt;在开始介绍Go语言的泛型编程实现之前，我想先聊一聊C语言的泛型实现，还是那句话，最喜欢C语言。&lt;/p&gt;
&lt;p&gt;C语言的泛型实现&lt;/p&gt;
&lt;p&gt;以交换变量的函数为例子，在C语言的实现，是通过无类型指针void *来实现，看下面的代码：&lt;/p&gt;
&lt;p&gt;// 交换函数，泛型实现版本
void swap(void *p1, void *p2)
{
size_t size = (sizeof(p1) == sizeof(p2)) ? sizeof(p1) : -1;
char temp[size];
memcpy(temp, p1, sizeof(p1));
memcpy(p1, p2, sizeof(p2));
memcpy(p2, temp, sizeof(temp));
}&lt;/p&gt;
&lt;p&gt;那么，有了泛型版本的交换函数后，通过执行整型、浮点数和字符串的交换验证一下：&lt;/p&gt;
&lt;p&gt;int main()
{
int a = 1;
int b = 42767;
swap(&amp;amp;a, &amp;amp;b);&lt;/p&gt;
&lt;p&gt;float f1 = 1.234;
float f2 = 2.345;
swap(&amp;amp;f1, &amp;amp;f2);&lt;/p&gt;
&lt;p&gt;char str1[6] = &amp;quot;hello&amp;quot;;
char str2[10] = &amp;quot;world ooo&amp;quot;;
swap(str1, str2);&lt;/p&gt;
&lt;p&gt;printf(&amp;quot;a: %d, b: %d&#92;n&amp;quot;, a, b);
printf(&amp;quot;f1: %f, f2: %f&#92;n&amp;quot;, f1, f2);
printf(&amp;quot;str1: %s, str2: %s&#92;n&amp;quot;, str1, str2);
}&lt;/p&gt;
&lt;p&gt;编译执行后结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/11/20/1672eea18fa6c4e3?w=325&amp;amp;h=72&amp;amp;f=png&amp;amp;s=3730&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;泛型版本的交换函数实现的关键是void *和memcpy函数，是拷贝内存的操作，因为数据在内存中都是保存二进制，只要操作交换的类型是一致的，那么通过memcpy会拷贝类型占用字节大小的数据，从而实现同类型的数据交换。需要注意一点的是，C语言下的泛型编程是不安全的，比如在这个交换函数中，如果操作了不同类型数据的交换，比如short和int的交换：&lt;/p&gt;
&lt;p&gt;short a = 1;
int b = 5;
swap(&amp;amp;a, &amp;amp;b);&lt;/p&gt;
&lt;p&gt;这个调用时不会报错，且可运行的，但是交换的结果依赖于系统的字节序，这种交换是没有意义的，需要程序员去做更多的检查和特殊判断。&lt;/p&gt;
&lt;p&gt;Go语言的泛型&lt;/p&gt;
&lt;p&gt;在Go语言里面，没有真正的泛型，它的泛型是通过利用interface{}的特性来实现，因为interface{}也是一种类型， 只要实现了interface{}里面的方法就可以归属为同一种类型，空的interface{}没有任何方法，那么任何类型都可以作为同一类（这一点有点类似Java的Object，所有类的超类）。&lt;/p&gt;
&lt;p&gt;interface{}&lt;/p&gt;
&lt;p&gt;interface{}是Go语言的一种类型，可以类比理解为Java的接口类型，在Go语言里，interface{}定义了一个方法集合，只要实现了interface{}里面的方法集，那就可以说是实现了该接口。Go语言的interface{}类型是一种静态的数据类型，在编译时会检查，但是它也算是一种动态的数据类型，因为它可以用来保存多种类型的数据。&lt;/p&gt;
&lt;p&gt;Go语言的interface{}提供了一种鸭子类型（duck typing）的用法，用起来就好像是PHP中的动态数据类型一样，但是如果企图使用一个有其他方法声明的interface{}来保存int，编译器还是会报错的。&lt;/p&gt;
&lt;p&gt;以开头的代码为例，改为使用interface{}后，代码是怎么样呢？&lt;/p&gt;
&lt;p&gt;定义保持Redis对象的RedisObject结构体，保存对象的类型、占用长度，对象值，值使用了空interface{}类型：&lt;/p&gt;
&lt;p&gt;type RedisObject struct {
objType int
objLen  int
objVal  interface{}
}&lt;/p&gt;
&lt;p&gt;当保存值时，只需要将值直接赋值给RedisObject即可：&lt;/p&gt;
&lt;p&gt;func (r *Rdb) saveStrObj(redisKey string, strVal string) {
redisObj := NewRedisObject(RDB_TYPE_STRING, r.loadingLen, strVal)
r.mapObj[redisKey] = redisObj
}&lt;/p&gt;
&lt;p&gt;func (r *Rdb) saveHash(hashKey string, hashField string, hashValue string) {
item, ok := r.mapObj[hashKey]
if !ok {
tmpMap := make(map[string]string)
item = NewRedisObject(RDB_TYPE_HASH, 0, tmpMap)
r.mapObj[hashKey] = item
}&lt;/p&gt;
&lt;p&gt;item.objVal.(map[string]string)[hashField] = hashValue
}&lt;/p&gt;
&lt;p&gt;对于字符串类型而言，它的值就是简单的字符串，使用语句r.mapObj[redisKey] = redisObj赋值即可，而哈希对象相对复杂一些，首先检查保存键hashKey的是否为有效对象，如果不是，则需要新建一个哈希对象，在保存时，需要将objVal(interface{}类型)解析为键值对对象，然后再进行赋值，具体代码是objVal.(map[string]string)，意思是将类型为interface{}的objVal解析为map[string][string]类型的值。&lt;/p&gt;
&lt;p&gt;类型断言&lt;/p&gt;
&lt;p&gt;上面对objVal进行类型转换的技术称之为类型断言，是一种类型之间转换的技术，与类型转换不同的是，类型断言是在接口间进行。&lt;/p&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;p&gt;&amp;lt;目标类型的值&amp;gt;，&amp;lt;布尔参数&amp;gt; := &amp;lt;表达式&amp;gt;.( 目标类型 ) // 安全类型断言
&amp;lt;目标类型的值&amp;gt; := &amp;lt;表达式&amp;gt;.( 目标类型 )　　//非安全类型断言&lt;/p&gt;
&lt;p&gt;如果断言失败，会导致panic的发生，为了防止过多的panic，需要在断言之前进行一定的判断，这就是安全与非安全断言的区别，安全类型断言可以获得布尔值来判断断言是否成功。&lt;/p&gt;
&lt;p&gt;另外，也可以通过t.(type)得到变量的具体类型。&lt;/p&gt;
&lt;p&gt;var t interface{}
t = functionOfSomeType()
switch t := t.(type) {
default:
fmt.Printf(&amp;quot;unexpected type %T&amp;quot;, t)       // %T prints whatever type t has
case bool:
fmt.Printf(&amp;quot;boolean %t&#92;n&amp;quot;, t)             // t has type bool
case int:
fmt.Printf(&amp;quot;integer %d&#92;n&amp;quot;, t)             // t has type int
case *bool:
fmt.Printf(&amp;quot;pointer to boolean %t&#92;n&amp;quot;, *t) // t has type *bool
case *int:
fmt.Printf(&amp;quot;pointer to integer %d&#92;n&amp;quot;, *t) // t has type *int
}&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过这次的小实践，除了对泛型编程有了更多的了解，学习到了Go语言的泛型编程原理，认识到interface{}也算是Go语言中的一个亮点，同时对计算机底层操作数据的本质也有所了解，程序的数据是在底层是一堆二进制，解析数据不是去识别数据的类型，而是程序根据变量的类型读取对应的字节，然后采取不同的方式去解析它。所谓类型， 只是读取内存的方式不同罢了。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点个赞吧，谢谢^_^&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/27/16618367007a1173?w=258&amp;amp;h=258&amp;amp;f=jpeg&amp;amp;s=28215&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>［从0到1编写服务器］TCP连接建立与断开状态变化</title>
    <link href="https://hoohack.me/blog/2018/2018-09-27-webser-zero-to-hero-tcp-status/"/>
    <updated>2018-09-27T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2018/2018-09-27-webser-zero-to-hero-tcp-status/</id>
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://www.hoohack.me/2018/09/05/webserver-zero-to-one-basic&quot;&gt;上篇&lt;/a&gt;介绍了socket编程的准备知识，是不是有一种很想马上就开始了解网络编程，甚至开始写点代码的感觉，别着急，网络编程中还有一个比较重要的概念是TCP/IP，中文名称叫网络传输协议，本质上，TCP/IP是一种协议，同时也是网络编程中最重要的协议之一。TCP/IP涉及到的内容实在太多，无奈笔者才疏学浅，无法把整个TCP/IP介绍给大家，这篇文章的目的主要是基于上一篇文章的前提下，介绍TCP连接三次握手和断开连接四次挥手究竟做了什么？socket的状态有哪些？在各个API执行的过程中，socket的状态是怎么变化的？希望通过这篇文章，能让大家对在TCP连接建立与断开过程中，socket的整个状态变化流程有更深入的了解。&lt;/p&gt;
&lt;h3 id=&quot;%E5%87%A0%E4%B8%AA%E6%9C%AF%E8%AF%AD&quot; tabindex=&quot;-1&quot;&gt;几个术语&lt;/h3&gt;
&lt;p&gt;SYN : 同步序列编号，Synchronize Sequence Numbers，仅在三次握手建立TCP连接时有效。表示一个新的TCP连接请求。&lt;/p&gt;
&lt;p&gt;ACK : 确认编号，Acknowledgement Number，对TCP请求的确认标志，同时提示对端系统已经成功接收所有数据。&lt;/p&gt;
&lt;p&gt;FIN : 结束标志，FINISH，用来结束一个TCP会话，但对应端口仍处于开放状态，准备接收后续数据。&lt;/p&gt;
&lt;h3 id=&quot;tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B&quot; tabindex=&quot;-1&quot;&gt;TCP三次握手&lt;/h3&gt;
&lt;p&gt;建立一次连接会有下面的流程&lt;/p&gt;
&lt;p&gt;1）服务器通过socket（初始化socket）、bind（绑定ip端口）、listen（开始监听服务）完成一次socket连接的建立，并调用accept函数准备好接收外部请求连接，这一步被称为被动打开&lt;/p&gt;
&lt;p&gt;2）客户端通过socket（初始化socket）完成了连接建立，调用connect函数发起主动打开，此时客户端会发送一个SYN分节J给服务器，J的作用是告诉服务器，在接下来的数据传输过程中，J是客户端在连接中传输数据的初始序列号&lt;/p&gt;
&lt;p&gt;3）服务器收到客户端的SYN分节后，需要回复确认信号ACK，J+1，代表服务器已经收到客户端的请求，且已经确认了客户端的初始序列号，同时服务器会发送SYN分节K给客户端，K的作用是告诉客户端，在接下来的数据传输过程中，K是服务器在连接中传输数据的初始序列号&lt;/p&gt;
&lt;p&gt;4）客户端收到服务器的SYN分节后，回复确认信号（ACK）K+1。连接建立成功。&lt;/p&gt;
&lt;p&gt;整个建立连接过程至少需要三个分节，因此被称为TCP三路握手。下面是TCP三次握手的流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2018/09/tcp-3shake.gif&quot; alt=&quot;tcp-status&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;tcp%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B&quot; tabindex=&quot;-1&quot;&gt;TCP四次握手&lt;/h3&gt;
&lt;p&gt;TCP通过三次握手建立连接，然而，断开连接需要四次握手，TCP断开连接的流程描述如下：&lt;/p&gt;
&lt;p&gt;1、客户端应用程序调用close函数，TCP中，称首先调用close的那一端为主动关闭，主动关闭的这一端发送FIN分节，意味着已经完成发送数据了；&lt;/p&gt;
&lt;p&gt;2、另一端（即服务器），接收到关闭请求，也收到FIN分节，开始执行被动关闭操作，称为被动关闭的一端。这个FIN分节由TCP确认，发送一个确认分节ACK给客户端，收到的FIN同时也是作为文件结束符传递给应用，意味着应用程序在接收了FIN之后就不会再接收连接上的数据；&lt;/p&gt;
&lt;p&gt;3、之后，接收到文件结束符的应用程序会关闭它的socket，服务端的TCP也会发送一个FIN分节；&lt;/p&gt;
&lt;p&gt;4、客户端接收到FIN分节，并确认最后的关闭操作，发送ACK分节给服务端。&lt;/p&gt;
&lt;p&gt;整个连接过程中，每一端的关闭和确认关闭都各自需要一个FIN和ACK分节，整个过程通常共需要4个分节，因此也称为TCP四次握手。下面是TCP关闭连接四次握手的流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2018/09/tcp-4shake.gif&quot; alt=&quot;tcp-status&quot; /&gt;&lt;/p&gt;
&lt;p&gt;实际上，网络上的传输是没有连接的，包括TCP也是一样，TCP所谓的&amp;quot;连接&amp;quot;与&amp;quot;断开连接&amp;quot;，其实只是一种虚拟的叫法，只不过是在通讯的双方维护一个&amp;quot;连接状态&amp;quot;，让它看上去好像有连接一样，所以，了解TCP的状态变换是非常重要的，接下来介绍socket的状态以及在TCP建立连接与断开连接过程中，socket状态的变化。&lt;/p&gt;
&lt;h3 id=&quot;socket%E7%8A%B6%E6%80%81&quot; tabindex=&quot;-1&quot;&gt;socket状态&lt;/h3&gt;
&lt;p&gt;socket共定义了11种状态：LISTEN、SYN-SENT、SYN-RECEIVED、ESTABLISHED、FIN-WAIT-1、FIN-WAIT-1、CLOSE_WAIT、FIN_WAIT、LAST-ACK、TIME-WAIT、CLOSING、CLOSED。&lt;/p&gt;
&lt;p&gt;我们假定A服务请求连接B服务。&lt;/p&gt;
&lt;p&gt;LISTEN：开始建立连接，此时socket已经初始化成功，正在等待连接&lt;/p&gt;
&lt;p&gt;SYN-SENT：A成功发送连接请求给B，等待对方响应&lt;/p&gt;
&lt;p&gt;SYN-RECEIVED：B接收到A的连接请求，并回复了确认进行连接给A，此状态表示正在等待A也回复确认收到此消息&lt;/p&gt;
&lt;p&gt;ESTABLISHED：表示连接已经成功建立；这个状态是连接阶段中进行数据传输的正常状态&lt;/p&gt;
&lt;p&gt;FIN-WAIT-1：等待主动断开连接请求的确认，或者并发请求被拒绝的断开连接，这种状态通常持续时间很短，比较难捕捉&lt;/p&gt;
&lt;p&gt;FIN-WAIT-2：等待B断开连接操作，这个状态通常持续时间也很短，但是如果B发生阻塞或者其他原因没有关闭连接，那么这个状态就会持续较长时间&lt;/p&gt;
&lt;p&gt;CLOSE-WAIT：B已经收到了A的断开连接请求，正在等待本地应用程序发送断开连接请求&lt;/p&gt;
&lt;p&gt;CLOSING：A正在等待B的关闭连接确认信号，当A接收到本地程序断开连接的请求后，就发送断开连接请求给B，并进入此状态&lt;/p&gt;
&lt;p&gt;LAST-ACK：B等待断开连接的确认信号&lt;/p&gt;
&lt;p&gt;TIME-WAIT：等待一段时间，确认B接收到A的关闭连接确认信号&lt;/p&gt;
&lt;p&gt;CLOSED：连接完全关闭&lt;/p&gt;
&lt;p&gt;那么在一个完整的TCP连接过程，TCP的状态是怎么转换的呢？&lt;/p&gt;
&lt;p&gt;先来看看下面这张图，是UNIX网络编程中，TCP状态变化的经典流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2018/09/tcp-classic.png&quot; alt=&quot;TCP-status&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在server端，调用socket函数创建一个sockect，函数返回一个socket文件描述符，调用bind函数绑定ip地址和端口，之后调用listen函数，scokect变成正在监听的socket，进入LISTEN状态，并调用accept等待请求（想要测试LISTEN状态，可以建立socket=&amp;gt;bind=&amp;gt;listen，然后sleep10秒之后退出，启动server之后马上用netstat命令可以看到）&lt;/p&gt;
&lt;p&gt;客户端调用connect，主动打开文件描述符，请求建立连接，此时会触发TCP的三次握手，进入SYN-SENT状态&lt;/p&gt;
&lt;p&gt;此时服务器调用了accept正在阻塞阶段，接收到客户端的连接请求后，进入SYN-RECEIVED状态，回复确认报文给客户端，等待客户端确认连接&lt;/p&gt;
&lt;p&gt;客户端收到服务器的连接确认报文SYN后，此时TCP已经完成了三次握手，connect函数返回，确认建立连接，转成ESTABLISHED状态，并发送确认报文ACK给服务器。（当第二次握手完成，握手步骤的第二个segment被client接收到的时候，connect函数返回。）&lt;/p&gt;
&lt;p&gt;在服务器侧，接收到客户端的确认报文，accept也收到返回，服务器也进入ESTALISHED状态。（握手步骤的第三个分节被server接收到的时候，accept函数返回，即connect返回后经过一半的RTT时间才返回。）&lt;/p&gt;
&lt;p&gt;客户端和服务端成功建立&amp;quot;连接&amp;quot;后，就进行开始通信，此时会调用read/write函数进行读写数据，读写数据完毕后，就准备关闭连接&lt;/p&gt;
&lt;p&gt;假定客户端应用程序，收到了服务器的响应报文，完成了通信过程，准备关闭应用，调用close函数发起主动关闭，此时客户端进入FIN-WAIT1状态，发送FIN分节到服务器，等待服务器确认&lt;/p&gt;
&lt;p&gt;服务端收到断开连接请求分节FIN（M），此时read函数返回0，服务器准备执行关闭操作，不再接收任何数据，并发送确认报文ACK（M+1）给客户端&lt;/p&gt;
&lt;p&gt;客户端收到确认分节后，表示服务器已经接收到断开连接请求，此时不会再发送数据并等待服务器断开连接，进入FIN-WAIT2状态&lt;/p&gt;
&lt;p&gt;服务器发送确认断开连接后，调用close函数，断开连接，close函数成功返回后，发送FIN分节给客户端，进入LASK-ACK状态，等待客户端的确认&lt;/p&gt;
&lt;p&gt;客户端收到服务器的断开连接分节FIN（N）后，发送确认分节ACK给服务器，并进入TIME-WAIT状态，此时会等待足够的时间，大约是最长分节生命期的2倍（2MSL），确认服务器收到断开连接的确认分节，之后就会消失。 服务器收到客户端的断开连接的确认分节ACK（N+1）后，表示连接已经完全断开了，此时进入CLOSED状态&lt;/p&gt;
&lt;p&gt;看完上面的一大段文字可能有点枯燥，甚至有点懵，来看看这张动画图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2018/09/tcp-status.gif&quot; alt=&quot;tcp-status&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本次主要介绍了TCP状态，以及在TCP连接建立和断开过程中，TCP状态的变化，掌握了这个，对理解网络编程中，各个流程的状态有比较大的帮助，比如在排查服务是否启动的时候，就可以通过&lt;code&gt;netstat -nlp | grep &#39;端口号&#39;&lt;/code&gt;，查看服务的状态描述字符串，如果是LISTEN状态表示服务已经正常启动，如果服务处于其他状态，则可以通过服务状态来进一步排查问题。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点个赞吧，谢谢^_^&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>［从0到1编写服务器］准备知识</title>
    <link href="https://hoohack.me/blog/2018/2018-09-05-webserver-zero-to-one-basic/"/>
    <updated>2018-09-05T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2018/2018-09-05-webserver-zero-to-one-basic/</id>
    <content type="html">&lt;h3 id=&quot;%E5%89%8D%E8%A8%80&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;在互联网发达的时代里，我们的开发过程中，很多场景几乎都需要跟网络打交道，数据库连接、redis连接、nginx转发、RPC服务等等，这个服务器软件的底层实现本质都是网络编程，这也是为什么很多公司在面试的时候都会问到计算机网络。诚然，在正常开发的过程下，几乎不会去自己编写一个完整的服务器，但是，在开发中理解一些概念性的知识却非常有用，甚至在排查一下稀奇古怪的网络错误的时候，TCP/IP协议可以发挥巨大的用处。如果在排查奇怪的问题时，你把学到的网络知识发挥了用途，那么你在公司的前景就不用多说了，而且，作为一个有追求的程序员，不能仅仅满足于业务开发，底层的计算机原理也要经常巩固。毕竟基础知识真的非常重要。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里强调一次，不是说学了网络编程就要去做服务器开发，而是了解网络编程的基础，会有利于提高平时开发调试问题的能力以及理解问题的深度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;学习网络编程是很有必要的，现在市面上有很多书籍和博客，大家也读了很多，But，程序员都是以动手为主，不能仅限于理论知识，需要动手实践来体验当中的一些坑或者难点，解决遇到的难点和坑会使你成长一大步。在我开来，指导别人需要在自己懂的前提下，去告诉别人是怎么做的，通过一个最简单的demo来指导，然后再让他人去深入，而不是一股脑地为对方注入一些理论上的知识。&lt;/p&gt;
&lt;h3 id=&quot;%E7%BD%91%E7%BB%9C%E4%BA%A4%E4%BA%92%E7%9A%84%E6%9C%AC%E8%B4%A8&quot; tabindex=&quot;-1&quot;&gt;网络交互的本质&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;抛开一切术语来说，其实网络交互的本质就是一次通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于旧时代人而言，一开始的通信方式是写信、飞鸽传书，之后就是电话，而服务器之间的通信就通过网络来进行，而在通信过程中，最需要掌握的就是如何建立连接，然后确保连接成功，如何在网络中传递数据，数据传递的格式是怎样的（协议），等等。&lt;/p&gt;
&lt;p&gt;网络通信要解决的首要问题是如何唯一地标示一个通信的主体，比如网络上的两台服务器，如果无法唯一地标示两台服务器，那么就无法建立唯一的连接，通信自然也就无从谈起；再比如网络上的两个服务：两个用户使用微信通信，如果不能唯一标示两个微信客户端应用，A想发给B的消息却发送到C了，那么用户的通信就会变得混乱。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2018/09/TCP-Communicate.png&quot; alt=&quot;通信&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在机器上，我们通过进程ID来唯一标识一个进程，在网络中，ip地址唯一标识了网站中的一台计算机，而服务的端口号则唯一标识了计算机上的一个应用服务，IP地址+端口则能唯一标识网络中通信的唯一一个通信主体。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2018/09/mark-communicate.png&quot; alt=&quot;唯一标识通信载体&quot; /&gt;&lt;/p&gt;
&lt;p&gt;另一个问题就是通信的实现，通过什么样的方式、使用什么协议可以完成一次通信呢？这就是TCP/IP做的事情，要了解通信的实现，就需要学习socket以及它的相关api。&lt;/p&gt;
&lt;h3 id=&quot;socket%E4%BB%8B%E7%BB%8D&quot; tabindex=&quot;-1&quot;&gt;socket介绍&lt;/h3&gt;
&lt;p&gt;socket直译的意思就是网络套接字， 是一种操作系统提供的进程间通信机制。下面是从维基百科参考的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在操作系统中，通常会为应用程序提供一组应用程序接口（API），称为套接字接口（英语：socket API）。应用程序可以通过套接字接口，来使用网络套接字，以进行数据交换。最早的套接字接口来自于4.2 BSD，因此现代常见的套接字接口大多源自Berkeley套接字（Berkeley sockets）标准。在套接字接口中，以IP地址及通信端口组成套接字地址（socket address）。远程的套接字地址，以及本地的套接字地址完成连线后，再加上使用的协议（protocol），这个五元组（five-element tuple），作为套接字对（socket pairs），之后就可以彼此交换数据。例如，在同一台计算机上，TCP协议与UDP协议可以同时使用相同的port而互不干扰。 操作系统根据套接字地址，可以决定应该将数据送达特定的进程或线程。这就像是电话系统中，以电话号码加上分机号码，来决定通话对象一般。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;个人的理解，socket就是操作系统用于定义操作计算机网络通信的一个媒介。&lt;/p&gt;
&lt;h3 id=&quot;socketapi&quot; tabindex=&quot;-1&quot;&gt;socketAPI&lt;/h3&gt;
&lt;p&gt;对于一次TCP连接而言，建立连接主要通过socket、bind、listen、accept这些API，整个流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2018/09/TCP-Connect.png&quot; alt=&quot;TCP连接&quot; /&gt;&lt;/p&gt;
&lt;p&gt;下面简单介绍下这些API的用法和函数参数的含义，更详细的操作可以直接读&lt;a href=&quot;http://man7.org/&quot;&gt;man page文档&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;socket%EF%BC%88%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%94%A8%E4%BA%8E%E9%80%9A%E4%BF%A1%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;socket（创建一个用于通信的节点）&lt;/h4&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; domain&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; type&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; protocol&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;domain：指定通信的域，选择通信的协议族，比较常见的有：AF_INET（代表ipv4）、AF_INET6（代表ipv6）等等，这个参数指定了ip地址的格式。&lt;/p&gt;
&lt;p&gt;type：指定通信的方式，传递数据的方式，比较常见的有：SOCK_STREAM、SOCK_DGRAM。&lt;/p&gt;
&lt;p&gt;protocol：指定通信的协议，常见的有IPPROTO_TCP、IPPROTO_UDP、IPPRO_SCTP。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值：int&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数的返回值是文件描述符，该文件描述符是一个正整数，唯一标识服务端与某客户端的连接，服务端和客户端可以通过此连接进行通信。出错情况下，会返回-1，并设置errno，可以通过errno获得出错信息。&lt;/p&gt;
&lt;h4 id=&quot;bind%EF%BC%88%E5%B0%86%E7%94%9F%E6%88%90%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%BB%91%E5%AE%9A%E5%88%B0%E9%9C%80%E8%A6%81%E7%9B%91%E5%90%AC%E7%9A%84%E7%AB%AF%E5%8F%A3%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;bind（将生成的文件描述符绑定到需要监听的端口）&lt;/h4&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; sockfd&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;sockaddr&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;addr&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;socklen_t&lt;/span&gt; addrlen&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sockfd：通过socket函数返回的文件描述符&lt;/p&gt;
&lt;p&gt;addr：指定需要监听的地址，地址包含了ip和端口，该结构体定义如下：&lt;/p&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;sockaddr&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token class-name&quot;&gt;sa_family_t&lt;/span&gt; sa_family&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; sa_data&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际上，在调用bind函数时传递的参数定义是struct sockaddr_in，定义如下：&lt;/p&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;sockaddr_in&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; sin_family&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* 协议族，在socket编程中基本为AF_INET */&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; sin_port&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* 端口号r */&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;in_addr&lt;/span&gt; sin_addr&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* IP地址 */&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; sin_zero&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* 空字节，为了让sockaddr和sockaddr_in有相同的字节大小 */&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sockaddr_in结构体清楚定义了ip地址和端口，而socketaddr结构体则是将ip地址和端口号捆绑在一起保存在data了，因此使用sockaddr_in进行初始化可以分开存储ip地址和结构体，也让代码看起来更加清晰，之后可以通过类型转换传递到bind函数。&lt;/p&gt;
&lt;p&gt;addrlen：第二个参数的大小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值：int&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;成功返回0，出错情况下，会返回-1，并设置errno，可以通过errno获得出错信息。&lt;/p&gt;
&lt;h4 id=&quot;listen%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BE%A7%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%BC%80%E5%A7%8B%E7%9B%91%E5%90%AC%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E5%AE%8C%E8%BF%9E%E6%8E%A5%E7%9A%84socket%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;listen（服务端侧使用，开始监听已经建立完连接的socket）&lt;/h4&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;listen&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; sockfd&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; backlog&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sockfd：指向socket的文件描述符&lt;/p&gt;
&lt;p&gt;backlog：指定请求数量缓冲区长度，如果请求数量超过backlog的大小，客户端会收到报错信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值：int&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;成功返回0，出错情况下，会返回-1，并设置errno，可以通过errno获得出错信息。&lt;/p&gt;
&lt;h4 id=&quot;connect%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;connect（客户端请求连接服务端）&lt;/h4&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; sockfd&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;sockaddr&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;addr&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;socklen_t&lt;/span&gt; socklen&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数含义与bind相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值：int&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;成功返回0，出错情况下，会返回-1，并设置errno，可以通过errno获得出错信息。&lt;/p&gt;
&lt;h4 id=&quot;accept%EF%BC%88%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E7%9A%84%E5%88%B0%E6%9D%A5%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;accept（接收请求的到来）&lt;/h4&gt;
&lt;p&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *socklen);&lt;/p&gt;
&lt;p&gt;accept参数的含义与bind类似，有一个不一样的是socklen，是一个引用传递方式的参数，调用方需要默认的长度，即参数addr的长度，函数调用成功后，会将真实的大小写到socklen。&lt;/p&gt;
&lt;h4 id=&quot;close%EF%BC%88%E5%85%B3%E9%97%AD%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;close（关闭打开的文件描述符）&lt;/h4&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; fd&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;fd：文件描述符。&lt;/p&gt;
&lt;h3 id=&quot;linux-i%2Fo-api&quot; tabindex=&quot;-1&quot;&gt;linux I/O API&lt;/h3&gt;
&lt;p&gt;建立连接后，就需要开始传递数据进行通信，比较常用的I/O api有read、write、recv、send。&lt;/p&gt;
&lt;h4 id=&quot;read%EF%BC%88%E4%BB%8E%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%AF%BB%E5%8F%96count%E5%AD%97%E8%8A%82%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%B9%B6%E4%BF%9D%E5%AD%98%E5%88%B0buf%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;read（从文件描述符读取count字节的数据，并保存到buf）&lt;/h4&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token class-name&quot;&gt;ssize_t&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; fd&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;buf&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;size_t&lt;/span&gt; count&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;
fd：已经打开的文件描述符&lt;/p&gt;
&lt;p&gt;buf：保存读取数据的指针&lt;/p&gt;
&lt;p&gt;count：要读取的数据字节大小，不能为0&lt;/p&gt;
&lt;p&gt;返回值 int&lt;/p&gt;
&lt;p&gt;如果成功，返回已经读取的字节大小，0表示到达文件结尾，-1表示错误。&lt;/p&gt;
&lt;h4 id=&quot;write%EF%BC%88%E5%86%99%E5%85%A5%E5%9C%A8buf%E4%B8%ADcount%E4%B8%AA%E5%AD%97%E8%8A%82%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%B0%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6fd%E4%B8%AD%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;write（写入在buf中count个字节的数据到打开的文件描述符fd中）&lt;/h4&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token class-name&quot;&gt;ssize_t&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; fd&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;buf&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;size_t&lt;/span&gt; count&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;
fd：已经打开的文件描述符&lt;/p&gt;
&lt;p&gt;buf：保存数据的指针&lt;/p&gt;
&lt;p&gt;count：要写入的数据字节大小&lt;/p&gt;
&lt;p&gt;返回值：如果成功，返回写入的字节大小，返回的值比count小不算一种错误，如果出错，返回-1&lt;/p&gt;
&lt;h3 id=&quot;%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80&quot; tabindex=&quot;-1&quot;&gt;语言基础&lt;/h3&gt;
&lt;p&gt;本次的demo选用的都是C语言，无可否认，使用C语言编写服务器真的特别麻烦。但是个人比较喜欢C语言（虽然C语言比较水，但就是喜欢它），觉得它是一门特别优秀的语言，而且C语言最接近计算机底层的操作，程序出现各种错误和内存操作都需要程序员去考虑，涉及到的内存细节也更多，这些情况在更高级比如Java、Go这些语言里是很少能见到的，这样一来，除了能通过此练习巩固编程思维之外，还能了解到高级语言的API是如何封装的，怎么考虑异常情况等等，如果是自己设计的话，会怎么编写出强壮且维护性强的API。因此，学习服务器编程，需要准备一些C语言的基础，当然，一边练习一边学习也是可以的。&lt;/p&gt;
&lt;h3 id=&quot;%E5%B0%8F%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2018/09/server-learning.png&quot; alt=&quot;服务器准备&quot; /&gt;
本次主要描述了为什么需要学习网络编程，同时介绍了网络交互的本质，以及计算机通信的方式，还有一些常用到的API。通过了解这些介绍，可以着手去学习基础知识，为之后编写服务器打下坚实的基础。
再次强调，网络基础真的很重要，只要开发工作涉及到网络交互，那么不管是开发还是调试功能，都会起到非常重要的作用。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点个赞吧，谢谢^_^&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>［深入理解Redis］读取RDB文件</title>
    <link href="https://hoohack.me/blog/2018/2018-08-26-rdb-tools-read-binary-file/"/>
    <updated>2018-08-27T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2018/2018-08-26-rdb-tools-read-binary-file/</id>
    <content type="html">&lt;p&gt;最近在做一个解析rdb文件的功能，途中遇到了一些问题，也解决了一些问题。具体为什么要做这件事情之后再详谈，本次主要想聊聊遇到的开始处理文件时遇到的第一个难题：理解RDB文件的协议、如何读取二进制文件。&lt;/p&gt;
&lt;h2 id=&quot;rdb%E6%96%87%E4%BB%B6&quot; tabindex=&quot;-1&quot;&gt;RDB文件&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.hoohack.me/2018/04/04/deep-learning-redis-durability&quot;&gt;［Redis源码阅读］redis持久化&lt;/a&gt;
文章介绍过，Redis的持久化是通过RDB和AOF实现的。Redis的RDB文件是二进制格式的文件，从这个方面再次体现了Redis是基于内存的缓存数据库，不管对于存储到硬盘还是恢复数据都十分快捷。Redis有多种数据类型：string、list、hash、set、zset，不同数据类型占用的内存大小是不一样的，解析出自然语言可以识别的数据就需要使用不同的方法，保存到文件的时候也需要一些协议或者规则。这有点类似于编程语言里面的数据类型，不同的数据类型占用的字节大小不一致，但是保存到计算机都是二进制的编码，就看是读取多少个字节，以怎样的方式解读。&lt;/p&gt;
&lt;p&gt;举个例子，redis的对象类型是特定的几个字符表示，0代表字符串，读取到字符串类型后，紧接着就是字符串的长度，保存着接下来需要读取的字节大小，读取到的字节最终构成完整字符串对象的值。对于保存了&lt;code&gt;&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;hoohack&amp;quot;&lt;/code&gt;键值对的字符串对象保存到内存可以用下图表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2018/08/redis-string-storage.png&quot; alt=&quot;redis字符串存储&quot; /&gt;&lt;/p&gt;
&lt;p&gt;当然，除了字符串，redis还有列表，集合，哈希等各种对象，针对这些类型，在RDB文件里面都有不同的规则定义，只需要按照RDB文件格式的协议来解读文件，就能完整无误地把文件解读成自然语言能描述的字符。&lt;/p&gt;
&lt;p&gt;仔细对比，可以发现跟计算机的操作方式是类似的，数据保存在计算机都是二进制的，具体的值应该看需要多少个字节，以什么类型解析，读取不同的字节解析到的值是不一样的，同样的字节大小，但是使用不同类型保存，只要做适当的转换，也是正确的。比如在C语言中的&lt;code&gt;void *&lt;/code&gt;指针是4个字节，int也是4个字节，定义一个int整数，将它保存到&lt;code&gt;void *&lt;/code&gt;也是没问题的，读取的时候只需要做一次类型转换就可以了。&lt;/p&gt;
&lt;p&gt;因此，解读RDB文件最关键的就是理解RDB文件的协议，只要理解完RDB文件格式的协议，根据定义好的协议来解析各种数据类型的数据。更详细的RDB文件协议可以参考RDB文件格式的定义文档：&lt;a href=&quot;http://rdb.fnordig.de/file_format.html&quot;&gt;RDB file format&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;%E6%9F%A5%E7%9C%8Brdb%E6%96%87%E4%BB%B6&quot; tabindex=&quot;-1&quot;&gt;查看RDB文件&lt;/h2&gt;
&lt;p&gt;先清空redis数据库，保存一个键值对，然后执行save命令将当前数据库的数据保存的rdb文件，得到文件dump.rdb。&lt;/p&gt;
&lt;p&gt;127.0.0.1:6379&amp;gt; flushall
OK
127.0.0.1:6379&amp;gt; set name hoohack
OK
127.0.0.1:6379&amp;gt; save
OK&lt;/p&gt;
&lt;h3 id=&quot;cat%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%EF%BC%9A&quot; tabindex=&quot;-1&quot;&gt;cat查看文件：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2018/08/cat-rdb-file.png&quot; alt=&quot;cat-rdb-file&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到是一个包含乱码的文件，因为文件是以二进制的格式保存，要想打印出人类能看出的语言，可以通过linux的od命令查看。od命令用于输出文件的八进制、十六进制或其他格式编码的字节，通常用于输出文件中不能直接显示在终端的字符，注意输出的是字节，分隔符之间的字符都是保存在一个字节的。&lt;/p&gt;
&lt;h3 id=&quot;od%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E5%85%AB%E8%BF%9B%E5%88%B6%E3%80%81%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%AD%89%E6%A0%BC%E5%BC%8F&quot; tabindex=&quot;-1&quot;&gt;od命令输出文件八进制、十六进制等格式&lt;/h3&gt;
&lt;p&gt;通过man手册可以看到，打印出16进制格式的参数是x，字符是c，将字符与十六进制的对应关系打印出来：&lt;code&gt;od -A x -t x1c -v dump.rdb&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;打印得出结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2018/08/linux-od.png&quot; alt=&quot;linux-od&quot; /&gt;&lt;/p&gt;
&lt;p&gt;从上图看到，文件打印出来的都是一些十六进制的数字，转换成十进制再去ASCII码表就能查找到对应的字符。比如第一个字符，52=5&lt;em&gt;16+2&lt;/em&gt;1=82=&#39;R’。
在这里说一句，个人觉得这od命令非常有用，在解析数据出现疑惑的时候，就是通过这个命令排查遇到的问题。把文件内容打印出来，找到当前读取的字符，对比RDB文件协议，看看究竟要解析的是什么数据，再对比代码中的解析逻辑，看看是否有问题，然后再修正代码。
如果觉得敲命令麻烦，可以把文件上传然后在线查看：&lt;a href=&quot;https://www.onlinehexeditor.com/&quot;&gt;https://www.onlinehexeditor.com&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BF%9D%E5%AD%98%E5%92%8C%E8%AF%BB%E5%8F%96&quot; tabindex=&quot;-1&quot;&gt;数据的二进制保存和读取&lt;/h2&gt;
&lt;p&gt;我们知道，计算机的所有数据都是以二进制的格式保存的，我们看到的字符是通过读取二进制然后解析出来的数据，程序根据不同数据类型做相应的转换，然后展示出来的就是我们看到的字符。
计算机允许多种数据类型，比如有：32位整数、64位整数、字符串、浮点数、布尔值等等，不同的数据类型是通过读取不同大小的字节，根据类型指定的读取方式读取出来，就是想要的数据了。&lt;/p&gt;
&lt;p&gt;解析数据的第一步，就是读取数据。在计算机里面，大家所知道的数据都是逐个字节地读取数据。因此，首先要实现的就是按照字节去读取文件。&lt;/p&gt;
&lt;p&gt;本次采用实现的解析RDB文件功能的语言是Golang，在Golang的文件操作的API里，提供了按字节读取的函数&lt;code&gt;File.ReadAt&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;函数原型如下：&lt;/p&gt;
&lt;p&gt;func (f *File) ReadAt(b []byte, off int64) (n int, err error)&lt;/p&gt;
&lt;p&gt;函数从File指针的指向的位置off开始，读取len(b)个字节的数据，并保存到b中。
根据对API的理解，自己实现了一个按照字节读取文件数据的函数，函数接收长度值，代表需要读取的字节长度。具体实现代码如下：&lt;/p&gt;
&lt;p&gt;type Rdb struct {
fp *os.File
... // other field
}&lt;/p&gt;
&lt;p&gt;func (r *Rdb) ReadBuf(length int64) ([]byte, error) {
// 初始化一个大小为length的字节数组
buf := make([]byte, length)&lt;/p&gt;
&lt;p&gt;// 从curIndex开始读取length个字节
size, err := r.fp.ReadAt(buf[:length], r.curIndex)&lt;/p&gt;
&lt;p&gt;checkErr(err)&lt;/p&gt;
&lt;p&gt;if size &amp;lt; 0 {
fmt.Fprintf(os.Stderr, &amp;quot;cat: error reading: %s&#92;n&amp;quot;, err.Error())
return []byte{}, err
} else {
// 读取成功，更新文件操作的偏移量
r.curIndex += length
return buf, nil
}
}&lt;/p&gt;
&lt;h3 id=&quot;golang%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2&quot; tabindex=&quot;-1&quot;&gt;Golang的数据转换&lt;/h3&gt;
&lt;p&gt;上面实现的函数返回的是字节数组，当函数返回读取到的数据后，如果需要保存在不同的数据类型就需要做转换，Golang也提供了比较强大的api。以下是我在解析数据时遇到的数据类型转换的解决方案，希望对大家有帮助。
字符串&lt;/p&gt;
&lt;p&gt;str := string(buf)&lt;/p&gt;
&lt;p&gt;int整数，先转为二进制的值，然后再用int32类型格式化&lt;/p&gt;
&lt;p&gt;intVal := int(binary.BigEndian.Uint32(buf))&lt;/p&gt;
&lt;p&gt;int64整数，先转为二进制的值，然后再用int64类型格式化&lt;/p&gt;
&lt;p&gt;int64Val := int64(int16(binary.LittleEndian.Uint16(valBuf)))&lt;/p&gt;
&lt;p&gt;浮点数&lt;/p&gt;
&lt;p&gt;floatVal, err := strconv.ParseFloat(string(floatBuf), 64)&lt;/p&gt;
&lt;p&gt;float64浮点数，先转为二进制的值，再调用math库的Float64frombits函数转换二进制的值为float64类型&lt;/p&gt;
&lt;p&gt;floatBit := binary.LittleEndian.Uint64(buf)
floatVal := math.Float64frombits(floatBit)&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;理论上的理解和实践上的应用是不一样的，虽然大家都知道数据是二进制的，就是怎么怎么解析，但是真正实现起来还是不少问题。通过操作二进制文件的一次实践，收获了以下几点：&lt;/p&gt;
&lt;p&gt;1、更深刻地理解到数据在计算机中的保存方式，一切都是0和1的二进制内容，只是看你要怎么用而已，适当的类似转换也可以得到你想要的内容&lt;/p&gt;
&lt;p&gt;2、在某个系统下操作就要遵循已定义好的协议，不然得到的都是乱套或者乱码的东西，比如数据的字节序不同也会使数据的解析结果不一致&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点个赞吧，谢谢^_^&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>［Redis源码阅读］实现一个redis命令--nonzerodecr</title>
    <link href="https://hoohack.me/blog/2018/2018-06-21-implement-redis-command-nonzerodecr/"/>
    <updated>2018-06-21T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2018/2018-06-21-implement-redis-command-nonzerodecr/</id>
    <content type="html">&lt;p&gt;&lt;a href=&quot;http://u6.gg/dCVQx&quot;&gt;上篇文章&lt;/a&gt;介绍了命令的执行流程，对redis如何执行命令也有了初步的了解，通过实现一个redis命令来再次加深印象。&lt;/p&gt;
&lt;p&gt;笔者平时主要语言是PHP，有些功能PHP无法满足就会用到PHP的扩展，比如swoole。因此，就想到redis可不可以以做扩展？为了满足一些特殊的需求，可不可以为redis开发一个命令？&lt;/p&gt;
&lt;h2 id=&quot;%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87&quot; tabindex=&quot;-1&quot;&gt;前期准备&lt;/h2&gt;
&lt;p&gt;因为redis是用C开发的，为了能开发redis命令，首先也是必须的是，你要懂一点C语言基础，另一个就是，需要了解一下redis命令是如何执行的，知道redis执行命令大概的流程，最简单的一个流程描述就是：&lt;/p&gt;
&lt;p&gt;读取命令-&amp;gt;解析命令-&amp;gt;调用命令函数-&amp;gt;返回执行结果&lt;/p&gt;
&lt;p&gt;或者再读一次&lt;a href=&quot;http://u6.gg/dCVQx&quot;&gt;上篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我们要做的就是，确保redis能解析到新增的命令，能根据输入的命令找到对应的方法并执行。&lt;/p&gt;
&lt;h2 id=&quot;%E5%87%BD%E6%95%B0%E9%9C%80%E6%B1%82&quot; tabindex=&quot;-1&quot;&gt;函数需求&lt;/h2&gt;
&lt;p&gt;要实现一个命令，说明当前redis的命令无法满足开发的需求。考虑这样的一个需求，在秒杀的情景下，达到了这样的case：商品剩下最后一件，两个用户同时抢购，使用业务代码：&lt;/p&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;redis&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;decr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; success&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样做有个问题就是活动结束后，key的值可能为-1，这样对于最终查询库存时会出现负值，不利于数据对账及统计。那么，能不能新增一个命令，让redis在计算时判断key的值，如果是0就不进行扣减呢？&lt;/p&gt;
&lt;p&gt;将函数命名为nonzerodecr，开始实现。&lt;/p&gt;
&lt;h2 id=&quot;%E6%B7%BB%E5%8A%A0%E5%87%BD%E6%95%B0%E5%90%8D%E5%88%B0%E5%91%BD%E4%BB%A4%E8%A1%A8&quot; tabindex=&quot;-1&quot;&gt;添加函数名到命令表&lt;/h2&gt;
&lt;p&gt;把函数名称添加到命令表，参照decr命令的命令表：&lt;/p&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;decr&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;decrCommand&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;wmF&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;增加nonzerodecrCommand：&lt;/p&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;nonzerodecr&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;nonzerodecrCommand&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;wmF&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;声明nonzerodecr，因为新增的命令nonzerodecr只是内部增加一个非0的判断，其余操作没有变化，因此只需要跟decrCommand一样的声明即可：&lt;/p&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;nonzerodecrCommand&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;client &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0&quot; tabindex=&quot;-1&quot;&gt;实现函数&lt;/h2&gt;
&lt;p&gt;在实现新的函数之前，先看看decrComamnd命令的实现：&lt;/p&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;decrCommand&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;client &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;incrDecrCommand&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数调用了incrDecrCommand实现自增和自减，实现如下：&lt;/p&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/*&lt;br /&gt;* incr、decr具体的实现&lt;br /&gt;*/&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;incrDecrCommand&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;client &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; incr&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; value&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; oldvalue&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  robj &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;o&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;new&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;// 检查key和value的类型&lt;/span&gt;&lt;br /&gt;  o &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;lookupKeyWrite&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;db&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;c&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;argv&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;o &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;checkType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;o&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;OBJ_STRING&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getLongLongFromObjectOrReply&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;o&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; C_OK&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;// 处理执行后溢出的情况&lt;/span&gt;&lt;br /&gt;  oldvalue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; value&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;incr &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; oldvalue &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; incr &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;LLONG_MIN&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;oldvalue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;incr &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; oldvalue &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; incr &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;LLONG_MAX&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;oldvalue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token function&quot;&gt;addReplyError&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;increment or decrement would overflow&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  value &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; incr&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;/*&lt;br /&gt;  * 在long范围内，直接赋值，否则使用longlong创建字符串后再赋值&lt;br /&gt;  */&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;o &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; o&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;refcount &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; o&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;encoding &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; OBJ_ENCODING_INT &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;value &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; value &lt;span class=&quot;token operator&quot;&gt;&gt;=&lt;/span&gt; OBJ_SHARED_INTEGERS&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;br /&gt;    value &lt;span class=&quot;token operator&quot;&gt;&gt;=&lt;/span&gt; LONG_MIN &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; value &lt;span class=&quot;token operator&quot;&gt;&amp;lt;=&lt;/span&gt; LONG_MAX&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    new &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; o&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    o&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;ptr &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    new &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createStringObjectFromLongLong&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;o&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token function&quot;&gt;dbOverwrite&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;db&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;c&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;argv&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;new&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token function&quot;&gt;dbAdd&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;db&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;c&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;argv&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;new&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token function&quot;&gt;signalModifiedKey&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;db&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;c&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;argv&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token function&quot;&gt;notifyKeyspaceEvent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;NOTIFY_STRING&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;incrby&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;c&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;argv&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;c&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;db&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;id&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  server&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dirty&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token function&quot;&gt;addReply&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;shared&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;colon&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token function&quot;&gt;addReply&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;new&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token function&quot;&gt;addReply&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;shared&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;crlf&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数的流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2018/06/incrDecrCommand.png&quot; alt=&quot;incrDecrCommand&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如图所示，要实现函数nonzerodecrCommand，只需要在进行增/减操作前增加一个大于等于0 的判断即可，其余的逻辑不变，实现如下：&lt;/p&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;nonzerodecrCommand&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;client &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; incr &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; value&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; oldvalue&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    robj &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;o&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;new&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// 检查key和value的类型&lt;/span&gt;&lt;br /&gt;    o &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;lookupKeyWrite&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;db&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;c&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;argv&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;o &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;checkType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;o&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;OBJ_STRING&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getLongLongFromObjectOrReply&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;o&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; C_OK&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// 处理执行后溢出的情况&lt;/span&gt;&lt;br /&gt;    oldvalue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; value&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;incr &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; oldvalue &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; incr &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;LLONG_MIN&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;oldvalue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token function&quot;&gt;addReplyError&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;increment or decrement would overflow&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    value &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; incr&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// 判断，如果操作后结果小于0，直接返回&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;value &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token function&quot;&gt;addReply&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;shared&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;czero&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;o &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; o&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;refcount &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; o&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;encoding &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; OBJ_ENCODING_INT &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;value &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; value &lt;span class=&quot;token operator&quot;&gt;&gt;=&lt;/span&gt; OBJ_SHARED_INTEGERS&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;br /&gt;      value &lt;span class=&quot;token operator&quot;&gt;&gt;=&lt;/span&gt; LONG_MIN &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; value &lt;span class=&quot;token operator&quot;&gt;&amp;lt;=&lt;/span&gt; LONG_MAX&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;      new &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; o&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;      o&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;ptr &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;      new &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createStringObjectFromLongLong&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;o&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;          &lt;span class=&quot;token function&quot;&gt;dbOverwrite&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;db&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;c&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;argv&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;new&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;          &lt;span class=&quot;token function&quot;&gt;dbAdd&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;db&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;c&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;argv&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;new&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;signalModifiedKey&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;db&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;c&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;argv&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;notifyKeyspaceEvent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;NOTIFY_STRING&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;incrby&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;c&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;argv&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;c&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;db&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;id&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    server&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dirty&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;addReply&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;shared&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;colon&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;addReply&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;new&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;addReply&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;shared&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;crlf&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;%E7%BC%96%E8%AF%91%E6%B5%8B%E8%AF%95&quot; tabindex=&quot;-1&quot;&gt;编译测试&lt;/h2&gt;
&lt;p&gt;编写完代码后，对代码进行编译测试：&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;&lt;span class=&quot;token number&quot;&gt;127.0&lt;/span&gt;.0.1:637&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token file-descriptor important&quot;&gt;9&lt;/span&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token builtin class-name&quot;&gt;set&lt;/span&gt; totalCount &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;br /&gt;OK&lt;br /&gt;&lt;span class=&quot;token number&quot;&gt;127.0&lt;/span&gt;.0.1:637&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token file-descriptor important&quot;&gt;9&lt;/span&gt;&gt;&lt;/span&gt; get totalCount&lt;br /&gt;&lt;span class=&quot;token string&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token number&quot;&gt;127.0&lt;/span&gt;.0.1:637&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token file-descriptor important&quot;&gt;9&lt;/span&gt;&gt;&lt;/span&gt; nonzerodecr totalCount&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token number&quot;&gt;127.0&lt;/span&gt;.0.1:637&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token file-descriptor important&quot;&gt;9&lt;/span&gt;&gt;&lt;/span&gt; get totalCount&lt;br /&gt;&lt;span class=&quot;token string&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token number&quot;&gt;127.0&lt;/span&gt;.0.1:637&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token file-descriptor important&quot;&gt;9&lt;/span&gt;&gt;&lt;/span&gt; nonzerodecr totalCount&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token number&quot;&gt;127.0&lt;/span&gt;.0.1:637&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token file-descriptor important&quot;&gt;9&lt;/span&gt;&gt;&lt;/span&gt; get totalCount&lt;br /&gt;&lt;span class=&quot;token string&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果符合最初的需求，在值等于0之后，再进行扣减，值不会变为负数。&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83&quot; tabindex=&quot;-1&quot;&gt;总结与思考&lt;/h2&gt;
&lt;p&gt;通过介绍实现nonzerodecr命令的过程，对如何实现一个命令有了一个初步的认识，之后如果有新的需求也可以根据这个步骤去实现一个新的命令。&lt;/p&gt;
&lt;p&gt;上面介绍的命令实现方式比较粗暴，可能会有隐藏的bug，但对于入门实现一个命令这个目的来说，这个代码时可以的，另外，一开始提到的秒杀场景除了可以使用新命令来解决，也可以使用redis-lua脚本的形式来实现，实现方法是多样的，具体的技术选型需要根据业务的场景来选择，如果你有更好的方案，欢迎评论留下你的方案。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点个赞吧，谢谢^_^&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>［Redis源码阅读］当你输入get/set命令的时候，redis做了什么</title>
    <link href="https://hoohack.me/blog/2018/2018-06-11-what-happen-when-you-use-get-set/"/>
    <updated>2018-06-11T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2018/2018-06-11-what-happen-when-you-use-get-set/</id>
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://www.hoohack.me/2018/05/26/read-redis-src-how-server-start&quot;&gt;上一篇文章&lt;/a&gt;介绍了redis-server的启动过程，服务端启动之后，就启动事件循环机制监听新事件的到来，此时不同的客户端就可以通过发送指令的方式请求server并得到处理结果的回复。在开发过程中，用到最多的就是get和set命令，那么，当我们输入get/set命令时，redis做了什么呢？&lt;/p&gt;
&lt;h2 id=&quot;redis-cli%E5%90%AF%E5%8A%A8&quot; tabindex=&quot;-1&quot;&gt;redis-cli启动&lt;/h2&gt;
&lt;p&gt;了解命令是如何使用之前，先了解下redis-client启动时做了什么。redis客户端有多种实现，不同的语言也有自己的实现，在这里可以看到各种版本：&lt;a href=&quot;https://redis.io/clients&quot;&gt;redis版本&lt;/a&gt;，平常调试过程中比较常用的是redis-client，即命令行的形式，redis-client的主要实现代码在&lt;code&gt;redis-cli.h&lt;/code&gt;和&lt;code&gt;redis-cli.c&lt;/code&gt;。redis-client的启动入口是在main函数，阅读代码可以看到是先给config设置属性，然后判断客户端使用哪种模式启动，启动模式有：Latency、Latency分布式、从库、获取RDB、查找大key、管道、Stat、Scan、LRU、Intrinsic Latency、交互模式。我们用的命令行就是交互模式。&lt;/p&gt;
&lt;p&gt;在redis整个连接过程中，使用了redisContext结构体来保存连接的上下文，看看结构体的定义：&lt;/p&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* 代表一个Redis连接的上下文结构体 */&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;redisContext&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; err&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; errstr&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;128&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; fd&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; flags&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;obuf&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    redisReader &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;reader&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;redisConnectionType&lt;/span&gt; connection_type&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;timeval&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;timeout&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;host&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;source_addr&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; port&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; tcp&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;path&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; unix_sock&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; redisContext&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;err：操作过程中的错误标志，0表示无错误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;errstr：错误信息字符串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;fd：redis-client连接服务器后的socket文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;obuf：保存输入的命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;tcp：保存一个tcp连接的信息，包括IP，协议族，端口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;介绍完使用的数据结构后，继续连接过程，在交互模式下，redis调用&lt;code&gt;cliConnect&lt;/code&gt;函数进行连接。&lt;/p&gt;
&lt;p&gt;cliConnect函数的执行流程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1、调用redisConnect函数连接到redis服务器实例，使用redisContext保存连接上下文。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;2、通过设置KeepAlive属性避免连接断开，KeepAlive的默认时间是15s。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;3、连接成功后，进行验证并选择正确的DB。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;连接建立成功后，redis-cli启动就完成了，此时进入了交互阶段，redisContext封装了客户端连接服务器的状态，之后有关客户端的操作都会操作这个结构体。&lt;/p&gt;
&lt;h2 id=&quot;%E8%B7%9F%E8%B8%AAget%2Fset%E5%91%BD%E4%BB%A4%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B&quot; tabindex=&quot;-1&quot;&gt;跟踪get/set命令的全过程&lt;/h2&gt;
&lt;p&gt;客户端启动成功，就可以输入指令调用redis的命令了。
本文测试使用的key是&lt;code&gt;username:1234&lt;/code&gt;，先输入&lt;code&gt;get username:1234&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;继续阅读代码，发现客户端进入交互模式之后，就调用repl读取终端命令、发送命令到客户端并返回结果，repl函数是交互模式的核心函数。repl函数调用linenoise函数读取用户输入的命令，读取方式是通过空格分隔多个参数，读取到命令请求之后，就会调用&lt;code&gt;issueCommandRepeat&lt;/code&gt;函数启动命令执行，&lt;code&gt;issueCommandRepeat&lt;/code&gt;函数调用&lt;code&gt;cliSendCommand&lt;/code&gt;发送命令给服务器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cliSendCommand&lt;/code&gt;函数调用&lt;code&gt;redisAppendCommandArgv&lt;/code&gt;函数使用redis的协议编码输入的命令，然后调用&lt;code&gt;cliReadReply&lt;/code&gt;函数发送数据到服务端并读取服务端的返回数据。读到这里的时候，挺想看看使用redis协议编码后的数据是怎样的，于是想到使用gdb断点调试，查看每一个步骤的数据以及交互。&lt;/p&gt;
&lt;h2 id=&quot;gdb%E8%B0%83%E8%AF%95redis%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C&quot; tabindex=&quot;-1&quot;&gt;gdb调试redis准备工作&lt;/h2&gt;
&lt;p&gt;在使用gdb调试的时候，输出其中一些变量会得到如下结果：&lt;/p&gt;
&lt;p&gt;​   &lt;code&gt;&amp;lt;value optimized out&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这是因为在编译的时候默认使用了-O2优化选项，在这个选项下，编译器会把它认为冗余的部分变量进行优化，因此看不到具体的值，要想去掉这个优化，在gcc编译的时候指定-O0就可以了，对于redis的编译来说，修改makefile文件，把-O2改为-O0或者执行&lt;code&gt;make noopt&lt;/code&gt;即可。&lt;/p&gt;
&lt;h2 id=&quot;redis%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D&quot; tabindex=&quot;-1&quot;&gt;redis通信协议介绍&lt;/h2&gt;
&lt;p&gt;众所周知，HTTP有自己的协议，协议是通信计算机双方必须共同遵从的一组约定。 如怎么样建立连接、怎么样互相识别等。 只有遵守这个约定，计算机之间才能相互通信交流。 对于redis而言，为了保证服务器与客户端的正常通信，也定义了自己的通信协议，客户端和服务器在接收解析数据时都需要遵循这个协议才能保证通信正常进行。&lt;/p&gt;
&lt;p&gt;redis请求协议的一般形式：&lt;/p&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;参数数量&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; CR LF&lt;br /&gt;$&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;参数 &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; 的字节数量&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; CR LF&lt;br /&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;参数 &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; 的数据&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; CR LF&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;br /&gt;$&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;参数 N 的字节数量&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; CR LF&lt;br /&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;参数 N 的数据&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; CR LF&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;回复的协议：&lt;/p&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;状态回复（status reply）的第一个字节是 &lt;span class=&quot;token string&quot;&gt;&quot;+&quot;&lt;/span&gt;&lt;br /&gt;错误回复（error reply）的第一个字节是 &lt;span class=&quot;token string&quot;&gt;&quot;-&quot;&lt;/span&gt;&lt;br /&gt;整数回复（integer reply）的第一个字节是 &lt;span class=&quot;token string&quot;&gt;&quot;:&quot;&lt;/span&gt;&lt;br /&gt;批量回复（bulk reply）的第一个字节是 &lt;span class=&quot;token string&quot;&gt;&quot;$&quot;&lt;/span&gt;&lt;br /&gt;多条批量回复（multi bulk reply）的第一个字节是 &lt;span class=&quot;token string&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4&quot; tabindex=&quot;-1&quot;&gt;解析命令&lt;/h2&gt;
&lt;p&gt;根据上面的描述可知，&lt;code&gt;issueCommandRepeat&lt;/code&gt;函数是执行命令的核心实现，为函数进行一个断点。&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; b issueCommandRepeat&lt;br /&gt;Breakpoint &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; at 0x40f891: &lt;span class=&quot;token function&quot;&gt;file&lt;/span&gt; redis-cli.c, line &lt;span class=&quot;token number&quot;&gt;1281&lt;/span&gt;.&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; run&lt;br /&gt;Starting program: /usr/local/src/redis-stable/src/redis-cli&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;Thread debugging using libthread_db enabled&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;br /&gt;Using &lt;span class=&quot;token function&quot;&gt;host&lt;/span&gt; libthread_db library &lt;span class=&quot;token string&quot;&gt;&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;&lt;/span&gt;&lt;span class=&quot;token builtin class-name&quot;&gt;.&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token number&quot;&gt;127.0&lt;/span&gt;.0.1:637&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token file-descriptor important&quot;&gt;9&lt;/span&gt;&gt;&lt;/span&gt; get username:1234&lt;br /&gt;Breakpoint &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;, issueCommandRepeat &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;argc&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;token assign-left variable&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;0x68a950, &lt;span class=&quot;token assign-left variable&quot;&gt;repeat&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; at redis-cli.c:1281&lt;br /&gt;&lt;span class=&quot;token number&quot;&gt;1281&lt;/span&gt;            config.cluster_reissue_command &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把&lt;code&gt;issuseCommandRepeat&lt;/code&gt;的参数打印出来：&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; p *argv&lt;br /&gt;&lt;span class=&quot;token variable&quot;&gt;$1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; 0x685583 &lt;span class=&quot;token string&quot;&gt;&quot;get&quot;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; p *&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;argv+1&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token variable&quot;&gt;$2&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; 0x68a973 &lt;span class=&quot;token string&quot;&gt;&quot;username:1234&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以知道，用户输入的命令通过&lt;code&gt;lineinoise&lt;/code&gt;解析后通过数组传递给&lt;code&gt;issuseCommandRepeat&lt;/code&gt;函数了。&lt;/p&gt;
&lt;p&gt;继续执行，就进入了&lt;code&gt;cliSendCommand&lt;/code&gt;函数，这个函数主要做的事情是使用redis协议编码发送过来的命令（调用&lt;code&gt;redisAppendCommandArgv&lt;/code&gt;函数），然后发送给服务器，并等待服务器的回复（调用&lt;code&gt;cliReadReply&lt;/code&gt;函数）。&lt;/p&gt;
&lt;p&gt;命令的解析过程是，使用redis的协议编码，然后将结果保存到redisContext-&amp;gt;obuf，结合前面介绍的redis通信协议看代码，非常直观，编码过程：&lt;/p&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/*&lt;br /&gt; * 使用Redis协议格式化命令，通过sds字符串保存，使用sdscatfmt函数追加&lt;br /&gt; * 函数接收几个参数，参数数组以及参数长度数组&lt;br /&gt; * 如果参数长度数组为NULL，参数长度会用strlen函数计算&lt;br /&gt; */&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;redisFormatSdsCommandArgv&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sds &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;target&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; argc&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;argv&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;argvlen&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    sds cmd&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; totlen&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; j&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token class-name&quot;&gt;size_t&lt;/span&gt; len&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;/* Abort on a NULL target */&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;target &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;/* 计算总大小 */&lt;/span&gt;&lt;br /&gt;    totlen &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;countDigits&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;argc&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;j &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; j &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; argc&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; j&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        len &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; argvlen &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; argvlen&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;j&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;argv&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;j&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        totlen &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;bulklen&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;len&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;/* 初始化一个sds字符串 */&lt;/span&gt;&lt;br /&gt;    cmd &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;sdsempty&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cmd &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;/* 使用前面计算得到的totlen分配空间 */&lt;/span&gt;&lt;br /&gt;    cmd &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;sdsMakeRoomFor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cmd&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; totlen&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cmd &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;/* 构造命令字符串 */&lt;/span&gt;&lt;br /&gt;    cmd &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;sdscatfmt&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cmd&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;*%i&#92;r&#92;n&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; argc&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// *%i 表示包含命令在内，共有多少个参数&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;j&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; j &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; argc&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; j&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        len &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; argvlen &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; argvlen&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;j&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;argv&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;j&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        cmd &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;sdscatfmt&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cmd&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;%u&#92;r&#92;n&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; len&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// %u 表示该参数的长度&lt;/span&gt;&lt;br /&gt;        cmd &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;sdscatlen&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cmd&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; argv&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;j&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; len&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 参数的值&lt;/span&gt;&lt;br /&gt;        cmd &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;sdscatlen&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cmd&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&#92;r&#92;n&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&#92;r&#92;n&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 最后加上&#92;r&#92;n&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;sdslen&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cmd&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt;totlen&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;target &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; cmd&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; totlen&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结合编码过程，对于输入的命令，得到的编码结果应该是：&lt;/p&gt;
&lt;p&gt;​   &lt;code&gt;*2&#92;r&#92;n$3&#92;r&#92;nget&#92;r&#92;n$13&#92;r&#92;nusername:1234&#92;r&#92;n&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在gdb打印验证一下，在执行redisAppendCommandArgv函数前后打印context-&amp;gt;obuf结果如下，验证成功：&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token number&quot;&gt;984&lt;/span&gt;             redisAppendCommandArgv&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;context,argc,&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;const char**&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;argv,argvlen&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; p context-&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;obuf&lt;br /&gt;&lt;span class=&quot;token variable&quot;&gt;$3&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; 0x6855a3 &lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; n&lt;br /&gt;&lt;span class=&quot;token number&quot;&gt;985&lt;/span&gt;             &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;config.monitor_mode&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; p context-&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;obuf&lt;br /&gt;&lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; 0x68a9e3 &lt;span class=&quot;token string&quot;&gt;&quot;*2&lt;span class=&quot;token entity&quot; title=&quot;&#92;r&quot;&gt;&#92;r&lt;/span&gt;&lt;span class=&quot;token entity&quot; title=&quot;&#92;n&quot;&gt;&#92;n&lt;/span&gt;3&lt;span class=&quot;token entity&quot; title=&quot;&#92;r&quot;&gt;&#92;r&lt;/span&gt;&lt;span class=&quot;token entity&quot; title=&quot;&#92;n&quot;&gt;&#92;n&lt;/span&gt;get&lt;span class=&quot;token entity&quot; title=&quot;&#92;r&quot;&gt;&#92;r&lt;/span&gt;&lt;span class=&quot;token entity&quot; title=&quot;&#92;n&quot;&gt;&#92;n&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;$13&lt;/span&gt;&lt;span class=&quot;token entity&quot; title=&quot;&#92;r&quot;&gt;&#92;r&lt;/span&gt;&lt;span class=&quot;token entity&quot; title=&quot;&#92;n&quot;&gt;&#92;n&lt;/span&gt;username:1234&lt;span class=&quot;token entity&quot; title=&quot;&#92;r&quot;&gt;&#92;r&lt;/span&gt;&lt;span class=&quot;token entity&quot; title=&quot;&#92;n&quot;&gt;&#92;n&lt;/span&gt;&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把&#92;r&#92;n去掉，通过一种更直观展示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;*2 // 命令参数的总数量，包含命令在内&lt;/p&gt;
&lt;p&gt;$3 // 第一个参数的长度&lt;/p&gt;
&lt;p&gt;get // 第一个参数的值&lt;/p&gt;
&lt;p&gt;$13 // 第二个参数的长度&lt;/p&gt;
&lt;p&gt;username:1234 // 第二个参数的值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E5%8F%91%E9%80%81%E5%91%BD%E4%BB%A4&quot; tabindex=&quot;-1&quot;&gt;发送命令&lt;/h2&gt;
&lt;p&gt;客户端解析完命令，并对其进行编码后，就进入下一阶段，将命令发给服务器，对cliReadReply函数进行断点：&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;Breakpoint &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;, cliReadReply &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;output_raw_strings&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; at redis-cli.c:840&lt;br /&gt;&lt;span class=&quot;token number&quot;&gt;840&lt;/span&gt;     static int cliReadReply&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;int output_raw_strings&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; n&lt;br /&gt;&lt;span class=&quot;token number&quot;&gt;843&lt;/span&gt;         sds out &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; NULL&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token number&quot;&gt;844&lt;/span&gt;         int output &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token number&quot;&gt;846&lt;/span&gt;         &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;redisGetReply&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;context,&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;_reply&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; REDIS_OK&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用了&lt;code&gt;redisGetReply&lt;/code&gt;函数，函数接收连接上下文redisContext参数，并把结果写到_reply。在redisGetReply函数里，函数做的事情是把命令发送给服务器，然后等待服务器返回，里面一个I/O操作，底层调用了系统调用write和read。&lt;/p&gt;
&lt;p&gt;调用write函数发送命令之后，请求到了服务器，上一篇文章有讲到了redis服务器是怎么启动的，启动之后就进入了事件循环状态，接下来就看看服务器是怎么处理请求的。&lt;/p&gt;
&lt;h2 id=&quot;%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82&quot; tabindex=&quot;-1&quot;&gt;处理请求&lt;/h2&gt;
&lt;p&gt;服务器启动会注册文件事件，注册的回调&lt;code&gt;acceptTcpHandler&lt;/code&gt;，当服务器可读时（即客户端可以write/close），&lt;code&gt;acceptTcpHandler&lt;/code&gt;被调用，追踪函数，调用链路如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;acceptTcpHandler -&amp;gt; anetTcpAccept -&amp;gt; acceptCommonHandler&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;acceptTcpHandler&lt;/code&gt;函数会调用anetTcpAccept函数发起accept，接收客户端请求，请求到来后，会调用&lt;code&gt;acceptCommonHandler&lt;/code&gt;函数处理。&lt;code&gt;acceptCommonHandler&lt;/code&gt;调用链：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;acceptCommonHandler-&amp;gt; createClient -&amp;gt; readQueryFromClient&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;acceptCommonHandler&lt;/code&gt;函数调用&lt;code&gt;createClient&lt;/code&gt;创建一个客户端，注册回调函数，如果有请求到来，会调用&lt;code&gt;readQueryFromClient&lt;/code&gt;函数读取客户端的请求。客户端创建成功后，redis会将它添加到当前服务器的客户端链表中，之后如果需要对所有客户端进行交互，都会使用这个链表。&lt;/p&gt;
&lt;p&gt;梳理整个调用链路后，对readQueryFromClient函数加一个断点，看看接收到的数据：&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; b readQueryFromClient&lt;br /&gt;Breakpoint &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; at 0x440b6b: &lt;span class=&quot;token function&quot;&gt;file&lt;/span&gt; networking.c, line &lt;span class=&quot;token number&quot;&gt;1377&lt;/span&gt;.&lt;br /&gt;&lt;span class=&quot;token number&quot;&gt;1377&lt;/span&gt;        client c &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;client&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; privdata&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; n&lt;br /&gt;&lt;span class=&quot;token number&quot;&gt;1383&lt;/span&gt;        readlen &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; PROTO_IOBUF_LEN&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; n&lt;br /&gt;&lt;span class=&quot;token number&quot;&gt;1390&lt;/span&gt;        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c-&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;reqtype &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; PROTO_REQ_MULTIBULK &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; c-&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;multibulklen &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; c-&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;bulklen &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token parameter variable&quot;&gt;-1&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; n&lt;br /&gt;&lt;span class=&quot;token number&quot;&gt;1398&lt;/span&gt;        qblen &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; sdslen&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c-&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;querybuf&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; n&lt;br /&gt;&lt;span class=&quot;token number&quot;&gt;1399&lt;/span&gt;        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c-&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;querybuf_peak &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; qblen&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; c-&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;querybuf_peak &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; qblen&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; n&lt;br /&gt;&lt;span class=&quot;token number&quot;&gt;1400&lt;/span&gt;        c-&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;querybuf &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; sdsMakeRoomFor&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c-&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;querybuf, readlen&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; n&lt;br /&gt;&lt;span class=&quot;token number&quot;&gt;1401&lt;/span&gt;        nread &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; read&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fd, c-&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;querybuf+qblen, readlen&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从执行步骤发现，redis-server为请求的命令创建一个字符串结构体保存，然后发起系统调用read从当前socket读取数据，执行完这步后，打印读取到的字符串，以及字符串结构体在内存中的保存情况：&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; p nread&lt;br /&gt;&lt;span class=&quot;token variable&quot;&gt;$7&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;33&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; p c-&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;querybuf&lt;br /&gt;&lt;span class=&quot;token number&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sds&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; 0x7ffff6b3a345 &lt;span class=&quot;token string&quot;&gt;&quot;*2&lt;span class=&quot;token entity&quot; title=&quot;&#92;r&quot;&gt;&#92;r&lt;/span&gt;&lt;span class=&quot;token entity&quot; title=&quot;&#92;n&quot;&gt;&#92;n&lt;/span&gt;3&lt;span class=&quot;token entity&quot; title=&quot;&#92;r&quot;&gt;&#92;r&lt;/span&gt;&lt;span class=&quot;token entity&quot; title=&quot;&#92;n&quot;&gt;&#92;n&lt;/span&gt;get&lt;span class=&quot;token entity&quot; title=&quot;&#92;r&quot;&gt;&#92;r&lt;/span&gt;&lt;span class=&quot;token entity&quot; title=&quot;&#92;n&quot;&gt;&#92;n&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;$13&lt;/span&gt;&lt;span class=&quot;token entity&quot; title=&quot;&#92;r&quot;&gt;&#92;r&lt;/span&gt;&lt;span class=&quot;token entity&quot; title=&quot;&#92;n&quot;&gt;&#92;n&lt;/span&gt;username:1234&lt;span class=&quot;token entity&quot; title=&quot;&#92;r&quot;&gt;&#92;r&lt;/span&gt;&lt;span class=&quot;token entity&quot; title=&quot;&#92;n&quot;&gt;&#92;n&lt;/span&gt;&quot;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; x/33 c-&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;querybuf&lt;br /&gt;0x7ffff6b3a345: &lt;span class=&quot;token number&quot;&gt;42&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;*&#39;&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;50&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;2&#39;&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;13&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;&#92;r&#39;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;&#92;n&#39;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;36&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;$&#39;&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;51&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;3&#39;&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;13&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;&#92;r&#39;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;&#92;n&#39;&lt;/span&gt;&lt;br /&gt;0x7ffff6b3a34d: &lt;span class=&quot;token number&quot;&gt;103&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;g&#39;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;101&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;e&#39;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;116&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;t&#39;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;13&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;&#92;r&#39;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;&#92;n&#39;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;36&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;$&#39;&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;49&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;1&#39;&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;51&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;3&#39;&lt;/span&gt;&lt;br /&gt;0x7ffff6b3a355: &lt;span class=&quot;token number&quot;&gt;13&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;&#92;r&#39;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;&#92;n&#39;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;117&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;u&#39;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;115&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;s&#39;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;101&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;e&#39;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;114&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;r&#39;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;110&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;n&#39;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;97&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;a&#39;&lt;/span&gt;&lt;br /&gt;0x7ffff6b3a35d: &lt;span class=&quot;token number&quot;&gt;109&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;m&#39;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;101&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;e&#39;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;58&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;:&#39;&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;49&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;1&#39;&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;50&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;2&#39;&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;51&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;3&#39;&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;52&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;4&#39;&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;13&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;&#92;r&#39;&lt;/span&gt;&lt;br /&gt;0x7ffff6b3a365: &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;&#92;n&#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果根据redis协议计算解析到的字符串长度，得到长度是33，打印&lt;code&gt;c-&amp;gt;querybuf&lt;/code&gt;在内存中的保存情况，可以看到整个命令的字节字符串都在这，每一个字节都是紧挨着地保存。&lt;/p&gt;
&lt;p&gt;因为redis是事件驱动的，在每一次有数据到来，&lt;code&gt;readQueryFromClient&lt;/code&gt;函数都会被调用，读取命令。本次调试用的get命令比较短，redis-server只需要一次事件循环过程就解析完整个命令了，server每次最多读取1024*16个字节的字符放到缓冲区，如果命令长度超过缓冲最大长度，会分别在多次事件中读取完然后再执行。&lt;/p&gt;
&lt;p&gt;读取完命令后，下一步就是解析和执行了。命令是根据之前介绍的redis协议编码的，server也是根据同样的协议解码，然后保存到redisClient，解析过程是一个反编码过程，具体是在processMultibulkBuffer函数中，有兴趣了解细节的可以查看这个函数。&lt;/p&gt;
&lt;p&gt;解析完命令后，通过调用&lt;code&gt;processCommand&lt;/code&gt;函数执行命令。上一篇文章说到，服务器启动时会加载命令表到server中，&lt;code&gt;processCommand&lt;/code&gt;函数先在命令表查找命令是否存在，查找方式是通过以命令名称作为key去redis的命令字典查找，对于get命令，定义的格式如下：&lt;/p&gt;
&lt;p&gt;{&amp;quot;get&amp;quot;,getCommand,2,&amp;quot;rF&amp;quot;,0,NULL,1,1,1,0,0}&lt;/p&gt;
&lt;p&gt;读取到之后，command-&amp;gt;proc就会被设置为getCommand函数，接着server进行一系列检查：参数是否正确、是否授权、集群模式处理、是否超出最大内存、如果硬盘有问题不处理等等，然后调用call函数执行命令。call函数是redis执行命令的核心函数，call函数的核心代码：&lt;/p&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;client &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; flags&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt; 执行前检查 &lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;/* 调用命令执行函数 */&lt;/span&gt;&lt;br /&gt;    dirty &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; server&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dirty&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    start &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;ustime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    c&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;cmd&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    duration &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;ustime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;start&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    dirty &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; server&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dirty&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;dirty&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;dirty &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; dirty &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt; 执行后处理 &lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看看上面的代码，是redis动态分发命令调用函数的实现，在命令表中配置好每个命令对应的执行函数，参数数量等信息，在server启动时把命令加载到命令表&lt;code&gt;server.commands&lt;/code&gt;，这时会将命令表中的命令函数保存到&lt;code&gt;redisCommand.proc&lt;/code&gt;，因此，在call函数，只需要执行&lt;code&gt;c-&amp;gt;cmd-&amp;gt;proc(c)&lt;/code&gt;就可以执行执行命令对应的函数了。&lt;/p&gt;
&lt;h2 id=&quot;getcommand%E5%AE%9E%E7%8E%B0&quot; tabindex=&quot;-1&quot;&gt;getCommand实现&lt;/h2&gt;
&lt;p&gt;对于本次get命令而言，直接看getCommand函数，调用了getGenericCommand&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*
* get命令的&amp;quot;通用&amp;quot;实现
*/
int getGenericCommand(client *c) {
    robj *o;
    // 调用lookupKeyReadOrReply函数查找指定key，找不到，返回
    if ((o = lookupKeyReadOrReply(c,c-&amp;gt;argv[1],shared.nullbulk)) == NULL)
        return C_OK;
    // 如果找到的对象类型不是string返回类型错误
    if (o-&amp;gt;type != OBJ_STRING) {
        addReply(c,shared.wrongtypeerr);
        return C_ERR;
    } else {
        addReplyBulk(c,o);
        return C_OK;
    }
}

/*
* get命令
* 调用getGenericCommand函数实现具体操作
*/
void getCommand(client *c) {
    getGenericCommand(c);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;getGenericCommand函数调用的&lt;code&gt;lookupKeyReadOrReply(c,c-&amp;gt;argv[1],shared.nullbulk)&lt;/code&gt;，传递的参数是客户端c，key，以及shared.nullbulk。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shared.nullbulk&lt;/code&gt;是由redis在服务器启动时创建的一个共享变量，因为使用的地方较多，所以redis会创建这些共享变量，减少重复创建过程以及减少内存的损耗。它的值是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shared.nullbulk = createObject(OBJ_STRING,sdsnew(&amp;quot;$-1&#92;r&#92;n&amp;quot;));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;lookupKeyReadOrReply函数只是做了简单的封装，看起来非常简洁，实际上，底层访问数据库是调用了db.c/lookupKey函数，这是get命令实现的核心：&lt;/p&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/*&lt;br /&gt;* 查找数据库中指定key的对象并返回，查询出来的对象用于读操作&lt;br /&gt;*/&lt;/span&gt;&lt;br /&gt;robj &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;lookupKeyReadOrReply&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;client &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; robj &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; robj &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;reply&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    robj &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;o &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;lookupKeyRead&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;db&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; key&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;o&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;addReply&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;reply&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; o&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;robj &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;lookupKey&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;redisDb &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;db&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; robj &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; flags&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// 在字典中根据key查找字典对象&lt;/span&gt;&lt;br /&gt;    dictEntry &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;de &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;dictFind&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;db&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;dict&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;key&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;ptr&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;de&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token comment&quot;&gt;// 获取字典对象的值&lt;/span&gt;&lt;br /&gt;        robj &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;val &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;dictGetVal&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;de&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token comment&quot;&gt;/* 更新key的最新访问时间 */&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;server&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;rdb_child_pid &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;br /&gt;            server&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;aof_child_pid &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;flags &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; LOOKUP_NOTOUCH&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;server&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;maxmemory_policy &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; MAXMEMORY_FLAG_LFU&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;                &lt;span class=&quot;token keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; ldt &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; val&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;lru &lt;span class=&quot;token operator&quot;&gt;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;                &lt;span class=&quot;token keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; counter &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;LFULogIncr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;val&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;lru &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;                val&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;lru &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ldt &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; counter&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            val&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;lru &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;LRU_CLOCK&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; val&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在redis中，所有的键值对都会用内置的哈希表保存在内存里，因此，在lookupKey的实现里，先使用&lt;code&gt;dictFind&lt;/code&gt;函数查找传进来的key是否存在哈希表中，如果找到，则调用&lt;code&gt;dictGetVal&lt;/code&gt;获取哈希节点对象的value属性，否则，返回NULL，函数的时间复杂度是O(1)。&lt;/p&gt;
&lt;p&gt;函数lookupKeyRead在接收到返回后，判断值的类型：&lt;/p&gt;
&lt;p&gt;如果是NULL，则将函数接收的参数shared.nullbulk返回给客户端。shared.nullbuk是上层函数传递进来的reply对象，一个null共享对象，根据redis的协议，解析为nil。&lt;/p&gt;
&lt;p&gt;如果函数不为空，则调用dictGetVal获取查找到的对象的值，然后返回。&lt;/p&gt;
&lt;p&gt;查找到的两种结果最终都是调用函数addReply返回结果给客户端，addReply函数将回复传递给客户端，addReply函数将回复结果写入到client的buf中，在redis的事件循环过程中，只要buf有数据就会输出到客户端。客户端得到内容后，根据redis协议解析结果，输出。在这个例子中，要查找的key不存在，因此客户端显示的是
(nil)&lt;/p&gt;
&lt;p&gt;至此，get命令的全流程已经介绍完，接着看看set命令的执行链路，输入&lt;code&gt;set username:1234&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;set%E5%91%BD%E4%BB%A4&quot; tabindex=&quot;-1&quot;&gt;set命令&lt;/h2&gt;
&lt;p&gt;set的执行流程与get的流程几乎一样，不同点在于处理请求的时候调用的是&lt;code&gt;setCommand&lt;/code&gt;，&lt;code&gt;setCommand&lt;/code&gt;先做了一些参数的校验，然后会为value做一次编码转换，因为保存redis字符串的有两种编码格式：embstr和sds，使用embstr编码字符串，可以节省空间，这也是redis做的其中一项优化，继续往下看，最终是调用了&lt;code&gt;setGenricCommand&lt;/code&gt;函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) {
    long long milliseconds = 0; /* 初始化，避免报错 */
    // 如果需要设置超时时间，根据unit单位参数设置超时时间
    if (expire) {
        // 获取时间值
        if (getLongLongFromObjectOrReply(c, expire, &amp;amp;milliseconds, NULL) != C_OK)
            return;
        // 处理非法的时间值
        if (milliseconds &amp;lt;= 0) {
            addReplyErrorFormat(c,&amp;quot;invalid expire time in %s&amp;quot;,c-&amp;gt;cmd-&amp;gt;name);
            return;
        }
        if (unit == UNIT_SECONDS) milliseconds *= 1000; // 统一用转换成毫秒
    }
    /*
     * 处理非法情况
     * 如果flags为OBJ_SET_NX 且 key存在或者flags为OBJ_SET_XX且key不存在，函数终止并返回abort_reply的值
     */
    if ((flags &amp;amp; OBJ_SET_NX &amp;amp;&amp;amp; lookupKeyWrite(c-&amp;gt;db,key) != NULL) ||
        (flags &amp;amp; OBJ_SET_XX &amp;amp;&amp;amp; lookupKeyWrite(c-&amp;gt;db,key) == NULL))
    {
        addReply(c, abort_reply ? abort_reply : shared.nullbulk);
        return;
    }
    // 设置val到key中
    setKey(c-&amp;gt;db,key,val);
    // 增加服务器的dirty值
    server.dirty++;
    // 设置过期时间
    if (expire) setExpire(c,c-&amp;gt;db,key,mstime()+milliseconds);
    // 通知监听了key的数据库，key被操作了set、expire命令
    notifyKeyspaceEvent(NOTIFY_STRING,&amp;quot;set&amp;quot;,key,c-&amp;gt;db-&amp;gt;id);
    if (expire) notifyKeyspaceEvent(NOTIFY_GENERIC,
        &amp;quot;expire&amp;quot;,key,c-&amp;gt;db-&amp;gt;id);
    // 返回成功的信息
    addReply(c, ok_reply ? ok_reply : shared.ok);
}

void setKey(redisDb *db, robj *key, robj *val) {
    /*
     * 如果key不在数据库里，新建
     * 否则，用新值覆盖
     */
    if (lookupKeyWrite(db,key) == NULL) {
        dbAdd(db,key,val);
    } else {
        dbOverwrite(db,key,val);
    }
    incrRefCount(val); // 增加值的引用计数
    removeExpire(db,key); // 重置键在数据库里的过期时间
    signalModifiedKey(db,key); // 发送修改键的通知
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;setGenericCommand&lt;/code&gt;调用&lt;code&gt;setKey&lt;/code&gt;函数将&lt;strong&gt;key-value&lt;/strong&gt;的键值对添加到数据库，setKey调用&lt;code&gt;dictFind&lt;/code&gt;函数查找key是否在数据库，如果在数据库，就用value覆盖旧值，否则将key-value添加到数据库。对于本文的例子，因为&lt;strong&gt;username:1234&lt;/strong&gt;这个key不存在，&lt;code&gt;dictFind&lt;/code&gt;查找返回的是空，因此函数&lt;code&gt;dbAdd&lt;/code&gt;被调用，&lt;code&gt;dbAdd&lt;/code&gt;函数只会在key不存在当前数据库的情况下被调用。&lt;/p&gt;
&lt;p&gt;redis中的键值对都会保存到dict（字典对象）数据结构中。
dict数据结构的介绍可见之前的文章：&lt;a href=&quot;https://www.hoohack.me/2018/01/07/read-redis-src-dict&quot;&gt;dict字典的实现&lt;/a&gt;。具体操作API实现直接看代码：&lt;a href=&quot;https://github.com/hoohack/read-redis-src/blob/master/redis-4.0/src/dict.c&quot;&gt;dict.c&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;追踪dbAdd函数代码细节可以发现，调用了&lt;code&gt;dictAdd&lt;/code&gt;函数执行具体的操作，&lt;code&gt;_dictKeyIndex&lt;/code&gt;函数为key返回合适的字典数组下标，然后分配内存保存新节点，将节点添加到哈希表中，并设置key和value的具体值。操作成功后，返回&lt;strong&gt;DICT_OK&lt;/strong&gt;，否则返回&lt;strong&gt;DICT_ERR&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;现在，username:1234已经设置了值，如果再次调用命令：&lt;code&gt;get username:1234&lt;/code&gt;，过程跟上面描述的一样，到了&lt;code&gt;dictFind&lt;/code&gt;阶段，函数能在数据库中找到&lt;code&gt;key username:1234&lt;/code&gt;，函数返回的结果不为空，因此调用dictGetVal函数获取key的值，然后调用&lt;code&gt;addReply&lt;/code&gt;返回对象的值。&lt;/p&gt;
&lt;p&gt;至此，set/get命令的整个流程到此结束，通读一遍可能还会有点懵逼，因此根据本次分享的内容再加一个图，看完这个图再回顾整个流程可以加深理解。&lt;a href=&quot;https://www.hoohack.me/assets/images/2018/06/redis-call-strace.jpg&quot;&gt;查看大图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2018/06/redis-call-strace.jpg&quot; alt=&quot;redis调用链路&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过本次的学习，从外层代码一只追溯到底层的网络代码实现，了解到了很多网络知识和代码封装技巧，再次感叹redis代码的优美。也借此机会将学习到的内容分享出来，如果有需要查看其它命令实现或者其他函数实现，也可以作为一次参考。&lt;/p&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://pauladamsmith.com/blog/2011/03/redis_get_set.html&quot;&gt;More Redis internals: Tracing a GET &amp;amp; SET&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>［Redis源码阅读］当你启动Redis的时候，Redis做了什么</title>
    <link href="https://hoohack.me/blog/2018/2018-05-26-read-redis-src-how-server-start/"/>
    <updated>2018-05-26T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2018/2018-05-26-read-redis-src-how-server-start/</id>
    <content type="html">&lt;p&gt;直奔主题，当启动Redis的时候，Redis执行了哪些操作？&lt;/p&gt;
&lt;p&gt;假设Redis安装在了/usr/local/目录下，那么启动Redis是通过执行&lt;code&gt;/usr/local/bin/redis-server -c xxx.conf&lt;/code&gt;的方式执行。
redis-server是一个通过编译server.c文件生成的程序，因此想了解redis是怎么启动的，应该从server.c/main函数入手。&lt;/p&gt;
&lt;p&gt;具体代码可见：&lt;a href=&quot;https://github.com/hoohack/read-redis-src/blob/master/redis-4.0/src/server.c&quot;&gt;server.c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;阅读main函数，可以知道，整个启动大致分为五个步骤：初始化server结构体、从配置文件夹在加载参数、初始化服务器、载入持久化文件、开始监听事件。&lt;/p&gt;
&lt;p&gt;redis用redisServer结构体来保存服务器的属性和信息，在server.c文件中，定义了一个全局服务器变量：&lt;/p&gt;
&lt;p&gt;struct redisServer server;&lt;/p&gt;
&lt;p&gt;另外，还定义了一个redis命令表，表里包含了命令以及命令对应的函数：&lt;/p&gt;
&lt;p&gt;struct redisCommand redisCommandTable;&lt;/p&gt;
&lt;p&gt;在main函数里，redis先调用initServerConfig函数初始化server结构体。&lt;/p&gt;
&lt;h2 id=&quot;%E5%88%9D%E5%A7%8B%E5%8C%96server%E7%BB%93%E6%9E%84%E4%BD%93&quot; tabindex=&quot;-1&quot;&gt;初始化server结构体&lt;/h2&gt;
&lt;p&gt;main函数调用initServerConfig函数为server的属性设置一些默认值，比如：&lt;/p&gt;
&lt;p&gt;服务器的运行ID&lt;/p&gt;
&lt;p&gt;redis使用的默认端口号，是在server.h定义的CONFIG_DEFAULT_SERVER_PORT = 6379&lt;/p&gt;
&lt;p&gt;LRU时钟&lt;/p&gt;
&lt;p&gt;主从备份相关参数&lt;/p&gt;
&lt;p&gt;命令表&lt;/p&gt;
&lt;p&gt;慢查询参数&lt;/p&gt;
&lt;p&gt;接着会保存当前执行的路径和参数，为之后的服务器重启使用相同的参数做准备：&lt;/p&gt;
&lt;p&gt;server.executable = getAbsolutePath(argv[0]);
server.exec_argv = zmalloc(sizeof(char*)*(argc+1));
server.exec_argv[argc] = NULL;
for (j = 0; j &amp;lt; argc; j++) server.exec_argv[j] = zstrdup(argv[j]);&lt;/p&gt;
&lt;h2 id=&quot;%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%8F%82%E6%95%B0&quot; tabindex=&quot;-1&quot;&gt;从配置文件加载参数&lt;/h2&gt;
&lt;p&gt;redis的启动参数有很多，其中一个是指定配置文件。初始化server结构体后，大部分的属性都会设置到结构体了，但是有部分参数可以通过配置文件重现设置，比如redis的端口号。&lt;/p&gt;
&lt;p&gt;初始化完server结构体后，函数会判断是否有指定配置文件，如果有，调用loadServerConfig函数，从配置文件加载相关的配置，把配置文件对应的参数设置到server结构体。&lt;/p&gt;
&lt;p&gt;读取配置文件加载参数的流程如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1、分割参数项&lt;/li&gt;
&lt;li&gt;2、跳过空行和注释行&lt;/li&gt;
&lt;li&gt;3、逐项检查，如果参数合法，设置配置值到server属性&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;至此，redisServer大部分属性已经设置好，server还有很多数据结构没有初始化，initServer函数就继续接下来的初始化工作。&lt;/p&gt;
&lt;h2 id=&quot;%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&quot; tabindex=&quot;-1&quot;&gt;初始化服务器数据结构&lt;/h2&gt;
&lt;p&gt;main函数会调用initServer函数初始化服务器状态，比如：&lt;/p&gt;
&lt;p&gt;进程ID&lt;/p&gt;
&lt;p&gt;客户端链表&lt;/p&gt;
&lt;p&gt;从库链表&lt;/p&gt;
&lt;p&gt;为常用值创建共享对象&lt;/p&gt;
&lt;p&gt;初始化事件循环器&lt;/p&gt;
&lt;p&gt;打开TCP开始监听套接字&lt;/p&gt;
&lt;p&gt;创建服务器的数据库，并初始化内部状态&lt;/p&gt;
&lt;p&gt;为serverCron定时器创建时间事件定时器&lt;/p&gt;
&lt;p&gt;如果开启了AOF，打开AOF文件，之后恢复数据时需要用到&lt;/p&gt;
&lt;p&gt;初始化慢查询日志模块&lt;/p&gt;
&lt;p&gt;初始化后台IO模块&lt;/p&gt;
&lt;h2 id=&quot;%E8%BD%BD%E5%85%A5%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%87%E4%BB%B6%EF%BC%8C%E8%BF%98%E5%8E%9F%E6%95%B0%E6%8D%AE%E5%BA%93&quot; tabindex=&quot;-1&quot;&gt;载入持久化文件，还原数据库&lt;/h2&gt;
&lt;p&gt;初始化完服务器的状态后，服务器已经处于一个可启动状态，因为redis有持久化特性，服务器还需要加载相应的文件来还原之前数据库的数据。
判断Redis当前开启了哪种模式，如果是AOF，则通过AOF还原数据库的数据，否则，载入RDB文件，通过RDB文件还原数据库的数据。&lt;/p&gt;
&lt;h2 id=&quot;%E5%BC%80%E5%A7%8B%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6&quot; tabindex=&quot;-1&quot;&gt;开始监听事件&lt;/h2&gt;
&lt;p&gt;main函数会设置beforeSleep和afterSleep回调函数，然后调用aeMain函数启动事件循环器，开始监听事件。aeMain函数是一个死循环，不断的监听新请求的到来。&lt;/p&gt;
&lt;p&gt;/*
* server启动后，main函数的最终步骤，不断地调用beforesleep和aeProcessEvents
*/
void aeMain(aeEventLoop *eventLoop) {
eventLoop-&amp;gt;stop = 0;
while (!eventLoop-&amp;gt;stop) {
if (eventLoop-&amp;gt;beforesleep != NULL)
eventLoop-&amp;gt;beforesleep(eventLoop);
aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP);
}
}&lt;/p&gt;
&lt;p&gt;综上所述，服务器整个启动简化流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2018/05/redis-start.png&quot; alt=&quot;redisServer&quot; /&gt;&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>［Redis源码阅读］redis持久化</title>
    <link href="https://hoohack.me/blog/2018/2018-04-04-deep-learning-redis-durability/"/>
    <updated>2018-04-04T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2018/2018-04-04-deep-learning-redis-durability/</id>
    <content type="html">&lt;p&gt;作为web开发的一员，相信大家的面试经历里少不了会遇到这个问题：redis是怎么做持久化的？&lt;/p&gt;
&lt;p&gt;不急着给出答案，先停下来思考一下，然后再看看下面的介绍。希望看了这边文章后，你能够回答这个问题。&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9F&quot; tabindex=&quot;-1&quot;&gt;为什么需要持久化？&lt;/h2&gt;
&lt;p&gt;由于Redis是一种内存型数据库，即服务器在运行时，系统为其分配了一部分内存存储数据，一旦服务器挂了，或者突然宕机了，那么数据库里面的数据将会丢失，为了使服务器即使突然关机也能保存数据，必须通过持久化的方式将数据从内存保存到磁盘中。&lt;/p&gt;
&lt;p&gt;对于进行持久化的程序来说，数据从程序写到计算机的磁盘的流程如下：&lt;/p&gt;
&lt;p&gt;1、客户端发送一个写指令给数据库（此时数据在客户端的内存）&lt;/p&gt;
&lt;p&gt;2、数据库接收到写的指令以及数据（数据此时在服务端的内存）&lt;/p&gt;
&lt;p&gt;3、数据库发起一个系统调用，把数据写到磁盘（此时数据在内核的内存）&lt;/p&gt;
&lt;p&gt;4、操作系统把数据传输到磁盘控制器（数据此时在磁盘缓存中）&lt;/p&gt;
&lt;p&gt;5、磁盘控制器执行真正写入数据到物理媒介的操作（如磁盘）&lt;/p&gt;
&lt;p&gt;如果只是考虑数据库层面，数据在第三阶段之后就安全了，在这个时候，系统调用已经发起了，即使数据库进程奔溃了，系统调用会继续进行，也能顺利将数据写入到磁盘中。
在这一步之后，在第4步内核会将数据从内核缓存保存到磁盘缓存中，但为了系统的效率问题，默认情况下不会太频繁地执行这个动作，大概会在30s执行一次，这就意味着如果这一步失败了或者就在进行这一步的时候服务器突然关机了，那么就可能会有30s的数据丢失了，这种比较普通的灾难性问题也是需要考虑的。&lt;/p&gt;
&lt;p&gt;POSIX API也提供了一个系统调用让内核强制将缓存数据写入到磁盘中，比较常见的就是fsync系统调用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;int fsync(int fd);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;fsync函数只对由文件描述符fd指定的一个文件起作用，并且等待写磁盘操作结束后才返回。每次调用fsync时，会初始化一个写操作，然后把缓冲区的数据写入到磁盘中。fsync()函数在完成写操作的时候会阻塞进程，如果其他线程也在写同一个文件，它也会阻塞其他线程，直到完成写操作。&lt;/p&gt;
&lt;h2 id=&quot;%E6%8C%81%E4%B9%85%E5%8C%96&quot; tabindex=&quot;-1&quot;&gt;持久化&lt;/h2&gt;
&lt;p&gt;持久化是将程序数据在持久状态和瞬时状态间转换的机制。对于程序来说，程序运行中数据是在内存的，如果没有及时同步写入到磁盘，那么一旦断电或者程序突然奔溃，数据就会丢失了，只有把数据及时同步到磁盘，数据才能永久保存，不会因为宕机影像数据的有效性。而持久化就是将数据从程序同步到磁盘的一个动作过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2018/04/Persistence.png&quot; alt=&quot;持久化&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96&quot; tabindex=&quot;-1&quot;&gt;Redis的持久化&lt;/h2&gt;
&lt;p&gt;redis有RDB和AOF两种持久化方式。RDB是快照文件的方式，redis通过执行SAVE/BGSAVE命令，执行数据的备份，将redis当前的数据保存到&lt;code&gt;*.rdb&lt;/code&gt;文件中，文件保存了所有的数据集合。AOF是服务器通过读取配置，在指定的时间里，追加redis写操作的命令到&lt;code&gt;*.aof&lt;/code&gt;文件中，是一种增量的持久化方式。&lt;/p&gt;
&lt;h3 id=&quot;rdb&quot; tabindex=&quot;-1&quot;&gt;RDB&lt;/h3&gt;
&lt;p&gt;RDB文件通过SAVE或BGSAVE命令实现。
SAVE命令会阻塞Redis服务进程，直到RDB文件创建完成为止。
BGSAVE命令通过fork子进程，有子进程来进行创建RDB文件，父进程和子进程共享数据段，父进程继续提供读写服务，子进程实现备份功能。BGSAVE阶段只有在需要修改共享数据段的时候才进行拷贝，也就是COW（Copy On Write）。SAVE创建RDB文件可以通过设置多个保存条件，只要其中一个条件满足，就可以在后台执行SAVE操作。&lt;/p&gt;
&lt;p&gt;SAVE和BGSAVE命令的实现代码如下：&lt;/p&gt;
&lt;p&gt;void saveCommand(client *c) {
// BGSAVE执行时不能执行SAVE
if (server.rdb_child_pid != -1) {
addReplyError(c,&amp;quot;Background save already in progress&amp;quot;);
return;
}
rdbSaveInfo rsi, *rsiptr;
rsiptr = rdbPopulateSaveInfo(&amp;amp;rsi);
// 调用rdbSave函数执行备份（阻塞当前客户端）
if (rdbSave(server.rdb_filename,rsiptr) == C_OK) {
addReply(c,shared.ok);
} else {
addReply(c,shared.err);
}
}&lt;/p&gt;
&lt;p&gt;/*
* BGSAVE 命令实现 [可选参数&amp;quot;schedule&amp;quot;]
*/
void bgsaveCommand(client *c) {
int schedule = 0;&lt;/p&gt;
&lt;p&gt;/* 当AOF正在执行时，SCHEDULE参数修改BGSAVE的效果
* BGSAVE会在之后执行，而不是报错
* 可以理解为：BGSAVE被提上日程
*/
if (c-&amp;gt;argc &amp;gt; 1) {
// 参数只能是&amp;quot;schedule&amp;quot;
if (c-&amp;gt;argc == 2 &amp;amp;&amp;amp; !strcasecmp(c-&amp;gt;argv[1]-&amp;gt;ptr,&amp;quot;schedule&amp;quot;)) {
schedule = 1;
} else {
addReply(c,shared.syntaxerr);
return;
}
}&lt;/p&gt;
&lt;p&gt;// BGSAVE正在执行，不操作
if (server.rdb_child_pid != -1) {
addReplyError(c,&amp;quot;Background save already in progress&amp;quot;);
} else if (server.aof_child_pid != -1) {
// aof正在执行，如果schedule==1，BGSAVE被提上日程
if (schedule) {
server.rdb_bgsave_scheduled = 1;
addReplyStatus(c,&amp;quot;Background saving scheduled&amp;quot;);
} else {
addReplyError(c,
&amp;quot;An AOF log rewriting in progress: can&#39;t BGSAVE right now. &amp;quot;
&amp;quot;Use BGSAVE SCHEDULE in order to schedule a BGSAVE whenever &amp;quot;
&amp;quot;possible.&amp;quot;);
}
} else if (rdbSaveBackground(server.rdb_filename,NULL) == C_OK) {// 否则调用rdbSaveBackground执行备份操作
addReplyStatus(c,&amp;quot;Background saving started&amp;quot;);
} else {
addReply(c,shared.err);
}
}&lt;/p&gt;
&lt;p&gt;有了RDB文件之后，如果服务器关机了，或者需要新增一个服务器，重新启动数据库服务器之后，就可以通过载入RDB文件恢复之前备份的数据。
但是bgsave会耗费较长时间，不够实时，会导致在停机的时候丢失大量数据。&lt;/p&gt;
&lt;h3 id=&quot;aof%EF%BC%88append-only-file%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;AOF（Append Only File）&lt;/h3&gt;
&lt;p&gt;RDB文件保存的是数据库的键值对数据，AOF保存的是数据库执行的写命令。&lt;/p&gt;
&lt;p&gt;AOF的实现流程有三步：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;append-&amp;gt;write-&amp;gt;fsync&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;append追加命令到AOF缓冲区，write将缓冲区的内容写入到程序缓冲区，fsync将程序缓冲区的内容写入到文件。
当AOF持久化功能处于开启状态时，服务器每执行完一个命令，就会将命令以协议格式追加写入到redisServer结构体的aof_buf缓冲区，具体的协议这里不展开阐述。&lt;/p&gt;
&lt;p&gt;AOF的持久化发生时期有个配置选项：appendfsync。该选项有三个值：
always：所有内容写入并同步到aof文件
everysec：将aof_buf缓冲区的内容写入到AOF文件，如果距离上次同步AOF文件的
no：将aof_buf缓冲区中的所有内容写入到AOF文件，但并不对AOF文件进行同步，由操作系统决定何时进行同步，一般是默认情况下的30s。&lt;/p&gt;
&lt;p&gt;AOF持久化模式每个写命令都会追加到AOF文件，随着服务器不断运行，AOF文件会越来越大，为了避免AOF产生的文件太大，服务器会对AOF文件进行重写，将操作相同key的相同命令合并，从而减少文件的大小。&lt;/p&gt;
&lt;p&gt;举个例子，要保存一个员工的名字、性别等信息：&lt;/p&gt;
&lt;p&gt;&amp;gt; hset employee_12345 name &amp;quot;hoohack&amp;quot;
&amp;gt; hset employee_12345 good_at &amp;quot;php&amp;quot;
&amp;gt; hset employee_12345 gender &amp;quot;male&amp;quot;&lt;/p&gt;
&lt;p&gt;只是录入这个哈希键的状态，AOF文件就需要保存三条命令，如果还有其他，比如删除，或者更新值的操作，那命令将会更多，文件会更大，有了重写后，就可以适当地减少文件的大小。&lt;/p&gt;
&lt;p&gt;AOF重写的实现原理是先服务器中的数据库，然后遍历数据库，找出每个数据库中的所有键对象，获取键值对的键和值，根据键的类型对键值对进行重写。比如上面的例子，可以合并为下面的一条命令：&lt;/p&gt;
&lt;p&gt;&amp;gt; hset employee_12345 name &amp;quot;hoohack&amp;quot; good_at &amp;quot;php&amp;quot; gender &amp;quot;male&amp;quot;。&lt;/p&gt;
&lt;p&gt;AOF的重写会执行大量的写入操作，Redis是单线程的，所以如果有服务器直接调用重写，服务器就不能处理其他命令了，因此Redis服务器新起了单独一个进程来执行AOF重写。&lt;/p&gt;
&lt;p&gt;Redis执行重写的流程：
&lt;img src=&quot;https://www.hoohack.me/assets/images/2018/04/redis-rewrite.png&quot; alt=&quot;redis rewrite&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在子进程执行AOF重写时，服务端接收到客户端的命令之后，先执行客户端发来的命令，然后将执行后的写命令追加到AOF缓冲区中，同时将执行后的写命令追加到AOF重写缓冲区中。
等到子进程完成了重写工作后，会发一个完成的信号给服务器，服务器就将AOF重写缓冲区中的所有内容追加到AOF文件中，然后原子性地覆盖现有的AOF文件。&lt;/p&gt;
&lt;h3 id=&quot;rdb%E5%92%8Caof%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9&quot; tabindex=&quot;-1&quot;&gt;RDB和AOF的优缺点&lt;/h3&gt;
&lt;p&gt;RDB持久化方式可以只通过服务器读取数据就能加载备份中的文件到程序中，而AOF方式必须创建一个伪客户端才能执行。&lt;/p&gt;
&lt;p&gt;RDB的文件较小，保存了某个时间点之前的数据，适合做灾备和主从同步。&lt;/p&gt;
&lt;p&gt;RDB备份耗时较长，如果数据量大，在遇到宕机的情况下，可能会丢失部分数据。另外，RDB是通过配置使达到某种条件的时候才执行，如果在这段时间内宕机，那么这部分数据也会丢失。&lt;/p&gt;
&lt;p&gt;AOF方式，在相同数据集的情况下，文件大小会比RDB方式的大。&lt;/p&gt;
&lt;p&gt;AOF的持久化方式也是通过配置的不同，默认配置的是每秒同步，最快的模式是同步每一个命令，最坏的方式是等待系统执行fsync将缓冲同步到磁盘文件中，大部分操作系统是30s。通常情况下会配置为每秒同步一次，所以最多会有1s的数据丢失。&lt;/p&gt;
&lt;h3 id=&quot;%E6%80%8E%E6%A0%B7%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E6%9B%B4%E5%A5%BD%EF%BC%9F&quot; tabindex=&quot;-1&quot;&gt;怎样的同步方式更好？&lt;/h3&gt;
&lt;p&gt;RDB和AOF方式结合。起一个定时任务，每小时备份一份服务器当前状态的数据，以日期和小时命名，另外起一个定时任务，定时删除无效的备份文件（比如48小时之前）。AOF配置为1s一次。这样一来，最多会丢失1s的数据，同时如果redis发生雪崩，也能迅速恢复为前一天的状态，不至于停止服务。&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;Redis的持久化方案也不是一成不变的，纸上的理论还需要结合实践成果来证明其可行性。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;参考文章：
&lt;a href=&quot;http://oldblog.antirez.com/post/redis-persistence-demystified.html&quot;&gt;http://oldblog.antirez.com/post/redis-persistence-demystified.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.httrack.com/blog/2013/11/15/everything-you-always-wanted-to-know-about-fsync/&quot;&gt;http://blog.httrack.com/blog/2013/11/15/everything-you-always-wanted-to-know-about-fsync/&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>［Redis源码阅读］redis对象</title>
    <link href="https://hoohack.me/blog/2018/2018-03-21-read-redis-src-object/"/>
    <updated>2018-03-21T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2018/2018-03-21-read-redis-src-object/</id>
    <content type="html">&lt;h2 id=&quot;%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89&quot; tabindex=&quot;-1&quot;&gt;结构定义&lt;/h2&gt;
&lt;p&gt;在redis中，对象的数据结构定义如下：&lt;/p&gt;
&lt;p&gt;​typedef struct redisObject {
​unsigned type:4;
​unsgined encoding:4;
​unsigned lru:LRU_BITS;
​int refcount;
​void *ptr;
​}&lt;/p&gt;
&lt;p&gt;结构定义中的&lt;code&gt;type:4&lt;/code&gt;、&lt;code&gt;encoding:4&lt;/code&gt;这种定义方式称为**&lt;a href=&quot;http://its.nbtvu.net.cn/xhyu/cai_c/c_web/c/c8/c83.htm&quot;&gt;位段类型&lt;/a&gt;**。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用位段类型的好处就是避免浪费内存，如果使用&lt;code&gt;unsigned int type&lt;/code&gt;定义type字段，需要4个字节，而使用&lt;code&gt;unsigned type:4&lt;/code&gt;，只需要4个位段就足够了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E&quot; tabindex=&quot;-1&quot;&gt;参数说明&lt;/h2&gt;
&lt;p&gt;redis对象有许多特性，比如：类型检查（通过type实现）、命令多态（encoding实现）、内存共享（通过refcount实现）等等，这些特性都是通过redisObject中的参数实现的。&lt;/p&gt;
&lt;h3 id=&quot;type&quot; tabindex=&quot;-1&quot;&gt;type&lt;/h3&gt;
&lt;p&gt;对象类型，它的取值范围有五个，分别是redis使用的五种对象类型：
​&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#define OBJ_STRING 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#define OBJ_LIST 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;​#define OBJ_SET 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#define OBJ_ZSET 3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#define OBJ_HASH 4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;在执行命令前对type字段进行检查，可判断出对象是否是命令允许执行的对象类型。&lt;/p&gt;
&lt;h3 id=&quot;encoding&quot; tabindex=&quot;-1&quot;&gt;encoding&lt;/h3&gt;
&lt;p&gt;对象使用的编码类型，它的取值范围有下面这些：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#define OBJ_ENCODING_RAW 0     /* 动态字符串 */&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#define OBJ_ENCODING_INT 1     /* 整数 */&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#define OBJ_ENCODING_HT 2      /* 哈希表 */&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#define OBJ_ENCODING_ZIPMAP 3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#define OBJ_ENCODING_LINKEDLIST 4 /* 旧的列表编码，现在不再使用了 */&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#define OBJ_ENCODING_ZIPLIST 5 /* 压缩表 */&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#define OBJ_ENCODING_INTSET 6  /* 整数集合 */&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#define OBJ_ENCODING_SKIPLIST 7  /* 跳跃表 */&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#define OBJ_ENCODING_EMBSTR 8  /* 用于保存短字符串的编码类型 */&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#define OBJ_ENCODING_QUICKLIST 9 /* 压缩链表和双向链表组成的快速列表 */&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;在调用命令的时候，redis还会根据对象使用的编码类型来选择正确的底层对象，执行对应函数的实现代码。&lt;/p&gt;
&lt;h3 id=&quot;lru&quot; tabindex=&quot;-1&quot;&gt;lru&lt;/h3&gt;
&lt;p&gt;最近最后一次被命令访问的时间 或者 最近最少使用的数据。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在执行OBJECT IDLETIME命令时，通过当前时间减去lru属性的值，得到键的空转时长。另外，如果服务器打开了maxmemory选项，且使用的内存回收算法是volatile-lur或者allkeys-lru，那么当服务器占用的内存超过了maxmemory的上限值，空转时长较高的键会优先被服务器释放，从而回收内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;refcount&quot; tabindex=&quot;-1&quot;&gt;refcount&lt;/h3&gt;
&lt;p&gt;对象的引用计数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;redis的对象共享和内存回收特性就是通过refcount属性来实现，通过将refcount + 1实现对象共享；进行内存回收检查时，检查refcount == 0的对象，将对象进行回收。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ptr&quot; tabindex=&quot;-1&quot;&gt;ptr&lt;/h3&gt;
&lt;p&gt;指向底层数据结构用于保存数据的指针。&lt;/p&gt;
&lt;h2 id=&quot;%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&quot; tabindex=&quot;-1&quot;&gt;对象使用的数据结构&lt;/h2&gt;
&lt;p&gt;redis有五种对象，不同对象可能用到的数据结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2018/03/redis-object-type.png&quot; alt=&quot;redis对象&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%91%BD%E4%BB%A4%E5%A4%9A%E6%80%81&quot; tabindex=&quot;-1&quot;&gt;编码转换与命令多态&lt;/h2&gt;
&lt;p&gt;同一种对象使用不同的数据结构是通过encoding来实现，而且，同一个命令的实现方法会根据对象的编码属性而变化，这是命令的多态实现。
以哈希对象为例看看编码转换以及命令多态等特性是怎么实现的。&lt;/p&gt;
&lt;h3 id=&quot;%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1&quot; tabindex=&quot;-1&quot;&gt;哈希对象&lt;/h3&gt;
&lt;p&gt;哈希对象使用的编码有：ziplist、hashtable。&lt;/p&gt;
&lt;p&gt;如果使用压缩表作为底层实现，每当有新的键值对需要加入哈希对象，会先添加键节点到链表，然后添加值节点。&lt;/p&gt;
&lt;p&gt;使用hashtable作为底层实现，每一个新的键值对都会使用字典键值对来保存，键和值分别是字符串对象。&lt;/p&gt;
&lt;p&gt;使用不同结构保存后的结构图如下所示：&lt;/p&gt;
&lt;p&gt;ziplist编码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2018/03/hash_ziplist.png&quot; alt=&quot;ziplist编码&quot; /&gt;&lt;/p&gt;
&lt;p&gt;hashtable编码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2018/03/hash_dict.png&quot; alt=&quot;hashtable编码&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2&quot; tabindex=&quot;-1&quot;&gt;编码转换&lt;/h3&gt;
&lt;p&gt;每一种对象在使用编码的时候都有一定的条件，使用ziplist编码的哈希对象都应该满足两个条件：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1、所有键值对的键和值字符串对象长度小于64字节&lt;/li&gt;
&lt;li&gt;2、哈希对象保存的键值对数量小于512个&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果不能满足上述条件时，redis会进行对哈希对象底层数据结构进行从压缩表到字典的转换，实现步骤是遍历压缩表，获取压缩表中的键和值，使用得到的键和值创建一个字典对象，然后添加字典里，具体代码如下：&lt;/p&gt;
&lt;p&gt;hashTypeIterator *hi;
dict *dict;
int ret;&lt;/p&gt;
&lt;p&gt;// 创建遍历器对象和哈希表
hi = hashTypeInitIterator(o);
dict = dictCreate(&amp;amp;hashDictType, NULL);&lt;/p&gt;
&lt;p&gt;while (hashTypeNext(hi) != C_ERR) {
sds key, value;&lt;/p&gt;
&lt;p&gt;// 用获取ziplis中的key、value新增键值对到哈希表
key = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);
value = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);
ret = dictAdd(dict, key, value);
if (ret != DICT_OK) {
serverLogHexDump(LL_WARNING,&amp;quot;ziplist with dup elements dump&amp;quot;,
o-&amp;gt;ptr,ziplistBlobLen(o-&amp;gt;ptr));
serverPanic(&amp;quot;Ziplist corruption detected&amp;quot;);
}
}
hashTypeReleaseIterator(hi);
zfree(o-&amp;gt;ptr);
o-&amp;gt;encoding = OBJ_ENCODING_HT;
o-&amp;gt;ptr = dict;&lt;/p&gt;
&lt;h3 id=&quot;%E5%91%BD%E4%BB%A4%E5%A4%9A%E6%80%81&quot; tabindex=&quot;-1&quot;&gt;命令多态&lt;/h3&gt;
&lt;p&gt;命令多态是检查对象的编码，然后执行不同的实现方式。比如哈希对象中的hget命令。&lt;/p&gt;
&lt;p&gt;hget命令实现代码：&lt;/p&gt;
&lt;p&gt;void hgetCommand(client *c) {
robj *o;&lt;/p&gt;
&lt;p&gt;// key不存在，返回空
if ((o = lookupKeyReadOrReply(c,c-&amp;gt;argv[1],shared.nullbulk)) == NULL ||
checkType(c,o,OBJ_HASH)) return;&lt;/p&gt;
&lt;p&gt;addHashFieldToReply(c, o, c-&amp;gt;argv[2]-&amp;gt;ptr);
}&lt;/p&gt;
&lt;p&gt;hget命令的实现最终是调用addHashFieldToReply函数（代码如下），该函数是通过判断哈希对象的编码来决定使用什么函数来获取哈希对象具体field的值，其他命令的实现也是大同小异。&lt;/p&gt;
&lt;p&gt;static void addHashFieldToReply(client *c, robj *o, sds field) {
int ret;&lt;/p&gt;
&lt;p&gt;if (o == NULL) {
addReply(c, shared.nullbulk);
return;
}&lt;/p&gt;
&lt;p&gt;// 根据底层不同编码获取field的值
if (o-&amp;gt;encoding == OBJ_ENCODING_ZIPLIST) {
unsigned char *vstr = NULL;
unsigned int vlen = UINT_MAX;
long long vll = LLONG_MAX;&lt;/p&gt;
&lt;p&gt;ret = hashTypeGetFromZiplist(o, field, &amp;amp;vstr, &amp;amp;vlen, &amp;amp;vll);
if (ret &amp;lt; 0) {
addReply(c, shared.nullbulk);
} else {
if (vstr) {
addReplyBulkCBuffer(c, vstr, vlen);
} else {
addReplyBulkLongLong(c, vll);
}
}&lt;/p&gt;
&lt;p&gt;} else if (o-&amp;gt;encoding == OBJ_ENCODING_HT) {
sds value = hashTypeGetFromHashTable(o, field);
if (value == NULL)
addReply(c, shared.nullbulk);
else
addReplyBulkCBuffer(c, value, sdslen(value));
} else {
serverPanic(&amp;quot;Unknown hash encoding&amp;quot;);
}
}&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;redis中的很多操作都是基于上面介绍的redis对象，了解这些对象的底层实现，可以为之后更多的redis特性做准备。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>［Redis源码阅读］dict字典的实现</title>
    <link href="https://hoohack.me/blog/2018/2018-01-07-read-redis-src-dict/"/>
    <updated>2018-01-07T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2018/2018-01-07-read-redis-src-dict/</id>
    <content type="html">&lt;h2 id=&quot;dict%E7%9A%84%E7%94%A8%E9%80%94&quot; tabindex=&quot;-1&quot;&gt;dict的用途&lt;/h2&gt;
&lt;p&gt;dict是一种用于保存键值对的抽象数据结构，在redis中使用非常广泛，比如数据库、哈希结构的底层。&lt;/p&gt;
&lt;p&gt;当执行下面这个命令：&lt;/p&gt;
&lt;p&gt;&amp;gt; set msg &amp;quot;hello&amp;quot;&lt;/p&gt;
&lt;p&gt;以及使用哈希结构，如：&lt;/p&gt;
&lt;p&gt;&amp;gt; hset people name &amp;quot;hoohack&amp;quot;&lt;/p&gt;
&lt;p&gt;都会使用到dict作为底层数据结构的实现。&lt;/p&gt;
&lt;h2 id=&quot;%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9A%E4%B9%89&quot; tabindex=&quot;-1&quot;&gt;结构的定义&lt;/h2&gt;
&lt;p&gt;先看看字典以及相关数据结构体的定义：&lt;/p&gt;
&lt;h3 id=&quot;%E5%AD%97%E5%85%B8&quot; tabindex=&quot;-1&quot;&gt;字典&lt;/h3&gt;
&lt;p&gt;/* 字典结构 每个字典有两个哈希表，实现渐进式哈希时需要用在将旧表rehash到新表 */
typedef struct dict {
dictType &lt;em&gt;type; /&lt;/em&gt; 类型特定函数 */
void &lt;em&gt;privdata; /&lt;/em&gt; 保存类型特定函数需要使用的参数 &lt;em&gt;/
dictht ht[2]; /&lt;/em&gt; 保存的两个哈希表，ht[0]是真正使用的，ht[1]会在rehash时使用 &lt;em&gt;/
long rehashidx; /&lt;/em&gt; rehashing not in progress if rehashidx == -1 rehash进度，如果不等于-1，说明还在进行rehash &lt;em&gt;/
unsigned long iterators; /&lt;/em&gt; number of iterators currently running 正在运行中的遍历器数量 */
} dict;&lt;/p&gt;
&lt;h3 id=&quot;%E5%93%88%E5%B8%8C%E8%A1%A8&quot; tabindex=&quot;-1&quot;&gt;哈希表&lt;/h3&gt;
&lt;p&gt;/* 哈希表结构 */
typedef struct dictht {
dictEntry *&lt;em&gt;table; /&lt;/em&gt; 哈希表节点数组 &lt;em&gt;/
unsigned long size; /&lt;/em&gt; 哈希表大小 &lt;em&gt;/
unsigned long sizemask; /&lt;/em&gt; 哈希表大小掩码，用于计算哈希表的索引值，大小总是dictht.size - 1 &lt;em&gt;/
unsigned long used; /&lt;/em&gt; 哈希表已经使用的节点数量 */
} dictht;&lt;/p&gt;
&lt;h3 id=&quot;%E5%93%88%E5%B8%8C%E8%A1%A8%E8%8A%82%E7%82%B9&quot; tabindex=&quot;-1&quot;&gt;哈希表节点&lt;/h3&gt;
&lt;p&gt;/* 哈希表节点 */
typedef struct dictEntry {
void &lt;em&gt;key; /&lt;/em&gt; 键名 */
union {
void &lt;em&gt;val;
uint64_t u64;
int64_t s64;
double d;
} v; /&lt;/em&gt; 值 &lt;em&gt;/
struct dictEntry &lt;em&gt;next; /&lt;/em&gt; 指向下一个节点, 将多个哈希值相同的键值对连接起来&lt;/em&gt;/
} dictEntry;&lt;/p&gt;
&lt;h3 id=&quot;dicttype&quot; tabindex=&quot;-1&quot;&gt;dictType&lt;/h3&gt;
&lt;p&gt;/* 保存一连串操作特定类型键值对的函数 */
typedef struct dictType {
uint64_t (*hashFunction)(const void &lt;em&gt;key); /&lt;/em&gt; 哈希函数 */
void *(*keyDup)(void *privdata, const void &lt;em&gt;key); /&lt;/em&gt; 复制键函数 */
void *(*valDup)(void *privdata, const void &lt;em&gt;obj); /&lt;/em&gt; 复制值函数 */
int (*keyCompare)(void *privdata, const void *key1, const void &lt;em&gt;key2); /&lt;/em&gt; 比较键函数 */
void (*keyDestructor)(void *privdata, void &lt;em&gt;key); /&lt;/em&gt; 销毁键函数 */
void (*valDestructor)(void *privdata, void &lt;em&gt;obj); /&lt;/em&gt; 销毁值函数 */
} dictType;&lt;/p&gt;
&lt;p&gt;把上面的结构定义串起来，得到下面的字典数据结构：
&lt;img src=&quot;https://www.hoohack.me/assets/images/2018/01/dict.png&quot; alt=&quot;dict struct&quot; /&gt;&lt;/p&gt;
&lt;p&gt;根据数据结构定义，把关联图画出来后，看代码的时候就更加清晰。&lt;/p&gt;
&lt;p&gt;从图中也可以看出来，字典的哈希表里，使用了链表解决键冲突的情况，称为链式地址法。&lt;/p&gt;
&lt;h2 id=&quot;rehash(%E9%87%8D%E6%96%B0%E6%95%A3%E5%88%97)&quot; tabindex=&quot;-1&quot;&gt;rehash(重新散列)&lt;/h2&gt;
&lt;p&gt;当操作越来越多，比如不断的向哈希表添加元素，此时哈希表需要分配了更多的空间，如果接下来的操作是不断地删除哈希表的元素，那么哈希表的大小就会发生变化，更重要的是，现在的哈希表不再需要那么大的空间了，在redis的实现中，为了保证哈希表的负载因子维持在一个合理范围内，当哈希表保存的键值对太多或者太少时，redis对哈希表大小进行相应的扩展和收缩，称为rehash（重新散列）。&lt;/p&gt;
&lt;h3 id=&quot;%E6%89%A7%E8%A1%8Crehash%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE&quot; tabindex=&quot;-1&quot;&gt;执行rehash的流程图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2018/01/redis-dict-rehash.png&quot; alt=&quot;redis-dict-rehash&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90%E8%A7%A3%E9%87%8A&quot; tabindex=&quot;-1&quot;&gt;负载因子解释&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;负载因子 = 哈希表已保存节点数量 / 哈希表大小&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;负载因子越大，意味着哈希表越满，越容易导致冲突，性能也就越低。因此，一般来说，当负载因子大于某个常数(可能是 1，或者 0.75 等)时，哈希表将自动扩容。&lt;/p&gt;
&lt;h2 id=&quot;%E6%B8%90%E8%BF%9B%E5%BC%8Frehash&quot; tabindex=&quot;-1&quot;&gt;渐进式rehash&lt;/h2&gt;
&lt;p&gt;在上面的rehash流程图里面，rehash的操作不是一次性就完成了的，而是分多次，渐进式地完成。&lt;/p&gt;
&lt;p&gt;原因是，如果需要rehash的键值对较多，会对服务器造成性能影响，渐进式地rehash避免了对服务器的影响。&lt;/p&gt;
&lt;p&gt;渐进式的rehash使用了dict结构体中的rehashidx属性辅助完成。当渐进式哈希开始时，rehashidx会被设置为0，表示从dictEntry[0]开始进行rehash，每完成一次，就将rehashidx加1。直到ht[0]中的所有节点都被rehash到ht[1]，rehashidx被设置为-1，此时表示rehash结束。&lt;/p&gt;
&lt;h3 id=&quot;%E7%BB%93%E5%90%88%E4%BB%A3%E7%A0%81%E5%86%8D%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3&quot; tabindex=&quot;-1&quot;&gt;结合代码再深入理解&lt;/h3&gt;
&lt;p&gt;／* 实现渐进式的重新哈希，如果还有需要重新哈希的key，返回1，否则返回0
*
* 需要注意的是，rehash持续将bucket从老的哈希表移到新的哈希表，但是，因为有的哈希表是空的，
* 因此函数不能保证即使一个bucket也会被rehash，因为函数最多一共会访问N*10个空bucket，不然的话，函数将会耗费过多性能，而且函数会被阻塞一段时间
&lt;em&gt;/
int dictRehash(dict &lt;em&gt;d, int n) {
int empty_visits = n&lt;/em&gt;10; /&lt;/em&gt; Max number of empty buckets to visit. */
if (!dictIsRehashing(d)) return 0;&lt;/p&gt;
&lt;p&gt;while(n-- &amp;amp;&amp;amp; d-&amp;gt;ht[0].used != 0) {
dictEntry *de, *nextde;&lt;/p&gt;
&lt;p&gt;assert(d-&amp;gt;ht[0].size &amp;gt; (unsigned long)d-&amp;gt;rehashidx);
/* 找到非空的哈希表下标 */
while(d-&amp;gt;ht[0].table[d-&amp;gt;rehashidx] == NULL) {
d-&amp;gt;rehashidx++;
if (--empty_visits == 0) return 1;
}
de = d-&amp;gt;ht[0].table[d-&amp;gt;rehashidx];&lt;/p&gt;
&lt;p&gt;/* 实现将bucket从老的哈希表移到新的哈希表 */
while(de) {
unsigned int h;&lt;/p&gt;
&lt;p&gt;nextde = de-&amp;gt;next;
/* Get the index in the new hash table */
h = dictHashKey(d, de-&amp;gt;key) &amp;amp; d-&amp;gt;ht[1].sizemask;
de-&amp;gt;next = d-&amp;gt;ht[1].table[h];
d-&amp;gt;ht[1].table[h] = de;
d-&amp;gt;ht[0].used--;
d-&amp;gt;ht[1].used++;
de = nextde;
}
d-&amp;gt;ht[0].table[d-&amp;gt;rehashidx] = NULL;
d-&amp;gt;rehashidx++;
}&lt;/p&gt;
&lt;p&gt;/* 如果已经完成了，释放旧的哈希表，返回0 */
if (d-&amp;gt;ht[0].used == 0) {
zfree(d-&amp;gt;ht[0].table);
d-&amp;gt;ht[0] = d-&amp;gt;ht[1];
_dictReset(&amp;amp;d-&amp;gt;ht[1]);
d-&amp;gt;rehashidx = -1;
return 0;
}&lt;/p&gt;
&lt;p&gt;/* 继续下一次rehash */
return 1;
}&lt;/p&gt;
&lt;p&gt;在渐进式rehash期间，所有对字典的操作，包括：添加、查找、更新等等，程序除了执行指定的操作之外，还会顺带将ht[0]哈希表索引的所有键值对rehash到ht[1]。比如添加：&lt;/p&gt;
&lt;p&gt;dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing)
{
int index;
dictEntry *entry;
dictht *ht;&lt;/p&gt;
&lt;p&gt;／* 如果正在rehash，顺带执行rehash操作 */
if (dictIsRehashing(d)) _dictRehashStep(d);&lt;/p&gt;
&lt;p&gt;/* 获取新元素的下标，如果已经存在，返回-1 */
if ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == -1)
return NULL;&lt;/p&gt;
&lt;p&gt;ht = dictIsRehashing(d) ? &amp;amp;d-&amp;gt;ht[1] : &amp;amp;d-&amp;gt;ht[0]; // 如果正在进行rehash操作，返回ht[1],否则返回ht[0]
entry = zmalloc(sizeof(*entry));
entry-&amp;gt;next = ht-&amp;gt;table[index];
ht-&amp;gt;table[index] = entry;
ht-&amp;gt;used++;&lt;/p&gt;
&lt;p&gt;/* Set the hash entry fields. */
dictSetKey(d, entry, key);
return entry;
}&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;使用一个标记值标记某项操作正在执行是编程中常用的手段，比如本文提到的rehashidx，多利用此手段可以解决很多问题。&lt;/p&gt;
&lt;p&gt;我在github有对Redis源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hoohack/read-redis-src&quot;&gt;Redis4.0源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/hoohack/read-redis-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>［Redis源码阅读］sds字符串实现</title>
    <link href="https://hoohack.me/blog/2017/2017-11-12-read-redis-src-sds/"/>
    <updated>2017-11-12T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2017/2017-11-12-read-redis-src-sds/</id>
    <content type="html">&lt;h2 id=&quot;%E5%88%9D%E8%A1%B7&quot; tabindex=&quot;-1&quot;&gt;初衷&lt;/h2&gt;
&lt;p&gt;从开始工作就开始使用Redis，也有一段时间了，但都只是停留在使用阶段，没有往更深的角度探索，每次想读源码都止步在阅读书籍上，因为看完书很快又忘了，这次逼自己先读代码。因为个人觉得写作需要阅读文字来增强灵感，那么写代码的，就阅读更多代码来增强灵感吧。&lt;/p&gt;
&lt;p&gt;redis的实现原理，在《Redis设计与实现》一书中讲得很详细了，但是想通过结合代码的形式再深入探索，加深自己的理解，现在将自己探索的心得写在这儿。&lt;/p&gt;
&lt;h2 id=&quot;sds%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89&quot; tabindex=&quot;-1&quot;&gt;sds结构体的定义&lt;/h2&gt;
&lt;p&gt;#define SDS_TYPE_5  0
#define SDS_TYPE_8  1
#define SDS_TYPE_16 2
#define SDS_TYPE_32 3
#define SDS_TYPE_64 4
#define SDS_TYPE_MASK 7&lt;/p&gt;
&lt;p&gt;// sds结构体，使用不同的结构体来保存不同长度大小的字符串
typedef char *sds;&lt;/p&gt;
&lt;p&gt;struct &lt;strong&gt;attribute&lt;/strong&gt; ((&lt;strong&gt;packed&lt;/strong&gt;)) sdshdr5 {
unsigned char flags; /* flags共8位，低三位保存类型标志，高5位保存字符串长度，小于32(2^5-1) &lt;em&gt;/
char buf[]; // 保存具体的字符串
};
struct &lt;strong&gt;attribute&lt;/strong&gt; ((&lt;strong&gt;packed&lt;/strong&gt;)) sdshdr8 {
uint8_t len; /&lt;/em&gt; 字符串长度，buf已用的长度 &lt;em&gt;/
uint8_t alloc; /&lt;/em&gt; 为buf分配的总长度，alloc-len就是sds结构体剩余的空间 &lt;em&gt;/
unsigned char flags; /&lt;/em&gt; 低三位保存类型标志 &lt;em&gt;/
char buf[];
};
struct &lt;strong&gt;attribute&lt;/strong&gt; ((&lt;strong&gt;packed&lt;/strong&gt;)) sdshdr16 {
uint16_t len; /&lt;/em&gt; used &lt;em&gt;/
uint16_t alloc; /&lt;/em&gt; excluding the header and null terminator &lt;em&gt;/
unsigned char flags; /&lt;/em&gt; 3 lsb of type, 5 unused bits &lt;em&gt;/
char buf[];
};
struct &lt;strong&gt;attribute&lt;/strong&gt; ((&lt;strong&gt;packed&lt;/strong&gt;)) sdshdr32 {
uint32_t len; /&lt;/em&gt; used &lt;em&gt;/
uint32_t alloc; /&lt;/em&gt; excluding the header and null terminator &lt;em&gt;/
unsigned char flags; /&lt;/em&gt; 3 lsb of type, 5 unused bits &lt;em&gt;/
char buf[];
};
struct &lt;strong&gt;attribute&lt;/strong&gt; ((&lt;strong&gt;packed&lt;/strong&gt;)) sdshdr64 {
uint64_t len; /&lt;/em&gt; used &lt;em&gt;/
uint64_t alloc; /&lt;/em&gt; excluding the header and null terminator &lt;em&gt;/
unsigned char flags; /&lt;/em&gt; 3 lsb of type, 5 unused bits */
char buf[];
};&lt;/p&gt;
&lt;p&gt;sds结构体从4.0开始就使用了5种header定义，节省内存的使用，但是不会用到sdshdr5，我认为是因为sdshdr5能保存的大小较少，2^5=32，因此就不使用它。&lt;/p&gt;
&lt;p&gt;其他的结构体保存了len、alloc、flags以及buf四个属性。各自的含义见代码的注释。&lt;/p&gt;
&lt;h2 id=&quot;sds%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E8%8E%B7%E5%8F%96&quot; tabindex=&quot;-1&quot;&gt;sds结构体的获取&lt;/h2&gt;
&lt;p&gt;上面可以看到有5种结构体的定义，在使用的时候是通过一个宏来获取的：&lt;/p&gt;
&lt;p&gt;#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))&lt;/p&gt;
&lt;p&gt;**&amp;quot;##&amp;quot;**被称为连接符，它是一种预处理运算符， 用来把两个语言符号(Token)组合成单个语言符号。比如&lt;code&gt;SDS_HDR(8, s)&lt;/code&gt;，根据宏定义展开是：&lt;/p&gt;
&lt;p&gt;((struct sdshdr8 *)((s)-(sizeof(struct sdshdr8))))&lt;/p&gt;
&lt;p&gt;而具体使用哪一个结构体，sds底层是通过flags属性与&lt;code&gt;SDS_TYPE_MASK&lt;/code&gt;做与运算得出具体的类型（具体的实现可见下面的sdslen函数），然后再根据类型去获取具体的结构体。&lt;/p&gt;
&lt;h2 id=&quot;sds%E7%89%B9%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0&quot; tabindex=&quot;-1&quot;&gt;sds特性的实现&lt;/h2&gt;
&lt;p&gt;在Redis设计与实现一书中讲到，相比C字符串而言，sds的特性如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;常数复杂度获取字符串长度&lt;/li&gt;
&lt;li&gt;杜绝缓冲区溢出&lt;/li&gt;
&lt;li&gt;减少内存重新分配次数&lt;/li&gt;
&lt;li&gt;二进制安全&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么，它是怎么做到的呢？看代码。&lt;/p&gt;
&lt;h3 id=&quot;%E5%B8%B8%E6%95%B0%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6&quot; tabindex=&quot;-1&quot;&gt;常数复杂度获取字符串长度&lt;/h3&gt;
&lt;p&gt;因为sds将长度属性保存在结构体中，所以只需要读取这个属性就能获取到sds的长度，具体调用的函数时sdslen，实现如下：&lt;/p&gt;
&lt;p&gt;static inline size_t sdslen(const sds s) {
unsigned char flags = s[-1];
switch(flags&amp;amp;SDS_TYPE_MASK) {
case SDS_TYPE_5:
return SDS_TYPE_5_LEN(flags);
case SDS_TYPE_8:
return SDS_HDR(8,s)-&amp;gt;len;
case SDS_TYPE_16:
return SDS_HDR(16,s)-&amp;gt;len;
case SDS_TYPE_32:
return SDS_HDR(32,s)-&amp;gt;len;
case SDS_TYPE_64:
return SDS_HDR(64,s)-&amp;gt;len;
}
return 0;
}&lt;/p&gt;
&lt;p&gt;可以看到，函数是根据类型调用SDS_HDR宏来获取具体的sds结构，然后直接返回结构体的len属性。&lt;/p&gt;
&lt;h3 id=&quot;%E6%9D%9C%E7%BB%9D%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA&quot; tabindex=&quot;-1&quot;&gt;杜绝缓冲区溢出&lt;/h3&gt;
&lt;p&gt;对于C字符串的操作函数来说，如果在修改字符串的时候忘了为字符串分配足够的空间，就有可能出现缓冲区溢出的情况。而sds中的API就不会出现这种情况，因为它在修改sds之前，都会判断它是否有足够的空间完成接下来的操作。&lt;/p&gt;
&lt;p&gt;拿书中举例的&lt;code&gt;sdscat&lt;/code&gt;函数来看，如果&lt;code&gt;strcat&lt;/code&gt;想在原来的&amp;quot;Redis&amp;quot;字符串的基础上进行字符串拼接的操作，但是没有检查空间是否满足，就有可能会修改了&amp;quot;Redis&amp;quot;字符串之后使用到的内存，可能是其他结构使用了，也有可能是一段没有被使用的空间，因此有可能会出现缓冲区溢出。但是&lt;code&gt;sdscat&lt;/code&gt;就不会，如下面代码所示：&lt;/p&gt;
&lt;p&gt;sds sdscatlen(sds s, const void *t, size_t len) {
size_t curlen = sdslen(s);&lt;/p&gt;
&lt;p&gt;s = sdsMakeRoomFor(s,len);
if (s == NULL) return NULL;
memcpy(s+curlen, t, len);
sdssetlen(s, curlen+len);
s[curlen+len] = &#39;&#92;0&#39;;
return s;
}&lt;/p&gt;
&lt;p&gt;sds sdscat(sds s, const char *t) {
return sdscatlen(s, t, strlen(t));
}&lt;/p&gt;
&lt;p&gt;从代码中可以看到，在执行&lt;code&gt;memcpy&lt;/code&gt;将字符串写入sds之前会调用&lt;code&gt;sdsMakeRoomFor&lt;/code&gt;函数去检查sds字符串s是否有足够的空间，如果没有足够空间，就为其分配足够的空间，从而杜绝了缓冲区溢出。&lt;code&gt;sdsMakeRoomFor&lt;/code&gt;函数的实现如下：&lt;/p&gt;
&lt;p&gt;sds sdsMakeRoomFor(sds s, size_t addlen) {
void *sh, *newsh;
size_t avail = sdsavail(s);
size_t len, newlen;
char type, oldtype = s[-1] &amp;amp; SDS_TYPE_MASK;
int hdrlen;&lt;/p&gt;
&lt;p&gt;/* 只有有足够空间就马上返回，否则就继续执行分配空间的操作 */
if (avail &amp;gt;= addlen) return s;&lt;/p&gt;
&lt;p&gt;len = sdslen(s);
sh = (char*)s-sdsHdrSize(oldtype);
newlen = (len+addlen);
// SDS_MAX_PREALLOC == 1MB，如果修改后的长度小于1M，则分配的空间是原来的2倍，否则增加1MB的空间
if (newlen &amp;lt; SDS_MAX_PREALLOC)
newlen *= 2;
else
newlen += SDS_MAX_PREALLOC;&lt;/p&gt;
&lt;p&gt;type = sdsReqType(newlen);&lt;/p&gt;
&lt;p&gt;if (type == SDS_TYPE_5) type = SDS_TYPE_8;&lt;/p&gt;
&lt;p&gt;hdrlen = sdsHdrSize(type);
if (oldtype==type) {
newsh = s_realloc(sh, hdrlen+newlen+1);
if (newsh == NULL) return NULL;
s = (char*)newsh+hdrlen;
} else {
/* 新增空间后超过当前类型的长度，使用malloc，并把原字符串拷贝过去 &lt;em&gt;/
newsh = s_malloc(hdrlen+newlen+1);
if (newsh == NULL) return NULL;
memcpy((char&lt;/em&gt;)newsh+hdrlen, s, len+1);
s_free(sh);
s = (char*)newsh+hdrlen;
s[-1] = type; // 给类型标志位赋值
sdssetlen(s, len);
}
sdssetalloc(s, newlen);
return s;
}&lt;/p&gt;
&lt;h3 id=&quot;%E5%87%8F%E5%B0%91%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%93%8D%E4%BD%9C&quot; tabindex=&quot;-1&quot;&gt;减少内存分配操作&lt;/h3&gt;
&lt;p&gt;sds字符串的很多操作都涉及到修改字符串内容，比如&lt;code&gt;sdscat&lt;/code&gt;拼接字符串、&lt;code&gt;sdscpy&lt;/code&gt;拷贝字符串等等。这时候就需要内存的分配与释放，如果每次操作都分配刚刚好的大小，那么对程序的性能必定有影响，因为内存分配涉及到系统调用以及一些复杂的算法。&lt;/p&gt;
&lt;p&gt;sds使用了空间预分配以及惰性空间释放的策略来减少内存分配操作。&lt;/p&gt;
&lt;h4 id=&quot;%E7%A9%BA%E9%97%B4%E9%A2%84%E5%88%86%E9%85%8D&quot; tabindex=&quot;-1&quot;&gt;空间预分配&lt;/h4&gt;
&lt;p&gt;前面提到，每次涉及到字符串的修改时，都会调用&lt;code&gt;sdsMakeRoomFor&lt;/code&gt;检查sds字符串，如果大小不够再进行大小的重新分配。&lt;code&gt;sdsMakeRoomFor&lt;/code&gt;函数有下面这几行判断：&lt;/p&gt;
&lt;p&gt;// SDS_MAX_PREALLOC == 1MB，如果修改后的长度小于1M，则分配的空间是原来的2倍，否则增加1MB的空间
if (newlen &amp;lt; SDS_MAX_PREALLOC)
newlen *= 2;
else
newlen += SDS_MAX_PREALLOC;&lt;/p&gt;
&lt;p&gt;函数判断字符串修改后的大小，如果修改后的长度小于1M，则分配给sds的空间是原来的2倍，否则增加1MB的空间。&lt;/p&gt;
&lt;h4 id=&quot;%E6%83%B0%E6%80%A7%E7%A9%BA%E9%97%B4%E9%87%8A%E6%94%BE&quot; tabindex=&quot;-1&quot;&gt;惰性空间释放&lt;/h4&gt;
&lt;p&gt;如果操作后减少了字符串的大小，比如下面的&lt;code&gt;sdstrim&lt;/code&gt;函数，只是在最后修改len属性，不会马上释放多余的空间，而是继续保留多余的空间，这样在下次需要增加sds字符串的大小时，就不需要再为其分配空间了。当然，如果之后检查到sds的大小实在太大，也会调用&lt;code&gt;sdsRemoveFreeSpac&lt;/code&gt;e函数释放多余的空间。&lt;/p&gt;
&lt;p&gt;sds sdstrim(sds s, const char *cset) {
char *start, *end, *sp, *ep;
size_t len;&lt;/p&gt;
&lt;p&gt;sp = start = s;
ep = end = s+sdslen(s)-1;
/* 从头部和尾部逐个字符遍历往中间靠拢，如果字符在cest中，则继续前进 */
while(sp &amp;lt;= end &amp;amp;&amp;amp; strchr(cset, *sp)) sp++;
while(ep &amp;gt; sp &amp;amp;&amp;amp; strchr(cset, *ep)) ep--;
len = (sp &amp;gt; ep) ? 0 : ((ep-sp)+1); // 全部被去除了，长度就是0
if (s != sp) memmove(s, sp, len); // 拷贝内容
s[len] = &#39;&#92;0&#39;;
sdssetlen(s,len);
return s;
}&lt;/p&gt;
&lt;h3 id=&quot;%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8&quot; tabindex=&quot;-1&quot;&gt;二进制安全&lt;/h3&gt;
&lt;p&gt;二进制安全指的是只关心二进制化的字符串，不关心具体格式。只会严格的按照二进制的数据存取，不会妄图以某种特殊格式解析数据。比如遇到&#39;&#92;0&#39;字符不会停止解析。&lt;/p&gt;
&lt;p&gt;对于C字符串来说，&lt;code&gt;strlen&lt;/code&gt;是判断遇到&#39;&#92;0&#39;之前的字符数量。如果需要保存二进制的数据，就不能通过传统的C字符串来保存，因为获取不到它真实的长度。而sds字符串是通过len属性保存字符串的大小，所以它是二进制安全的。&lt;/p&gt;
&lt;h2 id=&quot;%E5%85%B6%E4%BB%96%E5%B0%8F%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0&quot; tabindex=&quot;-1&quot;&gt;其他小函数实现&lt;/h2&gt;
&lt;p&gt;在阅读源码的过程中，也发现了两个个人比较感兴趣趣的函数：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;sdsll2str（将long long类型的整型数字转成字符串）&lt;/li&gt;
&lt;li&gt;sdstrim （去除头部和尾部的指定字符）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;我这两个函数拉出来做了测试，在项目的&lt;code&gt;redis-4.0/tests&lt;/code&gt;目录下。&lt;code&gt;sdstrim&lt;/code&gt;函数的实现源码上面有列出，看看&lt;code&gt;sdsll2str&lt;/code&gt;的实现：&lt;/p&gt;
&lt;p&gt;int sdsll2str(char *s, long long value) {
char *p, aux;
unsigned long long v;
size_t l;&lt;/p&gt;
&lt;p&gt;/* 通过取余数得到原字符串的逆转形式 */
v = (value &amp;lt; 0) ? -value : value;
p = s;
do {
*p++ = &#39;0&#39;+(v%10);
v /= 10;
} while(v);
if (value &amp;lt; 0) *p++ = &#39;-&#39;;&lt;/p&gt;
&lt;p&gt;/* Compute length and add null term. */
l = p-s;
*p = &#39;&#92;0&#39;;&lt;/p&gt;
&lt;p&gt;/* 反转字符串 */
p--;
while(s &amp;lt; p) {
aux = *s;
*s = *p;
*p = aux;
s++;
p--;
}
return l;
}&lt;/p&gt;
&lt;p&gt;函数是通过不断取余数，得到原字符串的逆转形式，接着，通过从尾部开始将字符逐个放到字符串s中，看起来像是一个反转操作，从而实现了将整型转为字符串的操作。&lt;/p&gt;
&lt;p&gt;觉得感兴趣是因为&lt;code&gt;sdsll2str&lt;/code&gt;这个函数在之前学习C语言的时候经常能看到作为问题出现，能看到如此简洁的实现，表示眼前一亮。而在PHP开发时经常使用trim函数，所以想看看它们的区别。&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过详细地阅读sds的源码，不仅学习到sds的实现细节，还学习到了一些常用字符串操作函数的实现。如果只是仅仅看看数据结构的定义也可以初步了解，但是要深入了解的话还是需要详细的阅读具体函数的实现代码。还是那句，写代码的，需要阅读更多代码来增强灵感。&lt;/p&gt;
&lt;p&gt;我在github有对Redis源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/hoohack/read-redis-src&quot;&gt;Redis4.0源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/hoohack/read-redis-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点个赞吧，谢谢^_^&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>［PHP源码阅读］number_format函数</title>
    <link href="https://hoohack.me/blog/2017/2017-09-21-php-source-code-number-format/"/>
    <updated>2017-09-21T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2017/2017-09-21-php-source-code-number-format/</id>
    <content type="html">&lt;p&gt;上次讲到&lt;a href=&quot;https://www.hoohack.me/2017/09/14/learning-php-big-number-detail&quot;&gt;PHP是如何解析大整数&lt;/a&gt;的，一笔带过了number_format的处理，再详细阅读该函数的源码，以下是小分析。&lt;/p&gt;
&lt;h2 id=&quot;%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B&quot; tabindex=&quot;-1&quot;&gt;函数原型&lt;/h2&gt;
&lt;p&gt;string number_format ( float $number [, int $decimals = 0 ] )&lt;/p&gt;
&lt;p&gt;string number_format ( float $number , int $decimals = 0 , string $dec_point = &amp;quot;.&amp;quot; , string $thousands_sep = &amp;quot;,&amp;quot; )&lt;/p&gt;
&lt;p&gt;函数可以接受1、2、4个参数（具体可以看代码的实现）。&lt;/p&gt;
&lt;p&gt;_&lt;/p&gt;
&lt;p&gt;如果只提供第一个参数，number的小数部分会被去掉，并且每个千位分隔符都是英文小写逗号&amp;quot;,&amp;quot; ；
如果提供两个参数，number将保留小数点后的位数到你设定的值，其余同楼上；
如果提供了四个参数，number 将保留decimals个长度的小数部分, 小数点被替换为dec_point，千位分隔符替换为thousands_sep&lt;/p&gt;
&lt;h2 id=&quot;php_function(number_format)&quot; tabindex=&quot;-1&quot;&gt;PHP_FUNCTION(number_format)&lt;/h2&gt;
&lt;p&gt;// number
// 你要格式化的数字
// num_decimal_places
// 要保留的小数位数
// dec_separator
// 指定小数点显示的字符
// thousands_separator
// 指定千位分隔符显示的字符
/* proto string number_format(float number [, int num_decimal_places [, string dec_separator, string thousands_separator]])
Formats a number with grouped thousands */
PHP_FUNCTION(number_format)
{
// 期望number_format的第一个参数num是double类型的，在词法阶段已经对字面量常量做了转换
double num;
zend_long dec = 0;
char *thousand_sep = NULL, *dec_point = NULL;
char thousand_sep_chr = &#39;,&#39;, dec_point_chr = &#39;.&#39;;
size_t thousand_sep_len = 0, dec_point_len = 0;
// 解析参数
ZEND_PARSE_PARAMETERS_START(1, 4)
Z_PARAM_DOUBLE(num)// 拿到double类型的num
Z_PARAM_OPTIONAL
Z_PARAM_LONG(dec)
Z_PARAM_STRING_EX(dec_point, dec_point_len, 1, 0)
Z_PARAM_STRING_EX(thousand_sep, thousand_sep_len, 1, 0)
ZEND_PARSE_PARAMETERS_END();
switch(ZEND_NUM_ARGS()) {
case 1:
RETURN_STR(_php_math_number_format(num, 0, dec_point_chr, thousand_sep_chr));
break;
case 2:
RETURN_STR(_php_math_number_format(num, (int)dec, dec_point_chr, thousand_sep_chr));
break;
case 4:
if (dec_point == NULL) {
dec_point = &amp;amp;dec_point_chr;
dec_point_len = 1;
//}
if (thousand_sep == NULL) {
thousand_sep = &amp;amp;thousand_sep_chr;
thousand_sep_len = 1;
}
// _php_math_number_format_ex
// 真正处理的函数，在本文件第1107行
RETVAL_STR(_php_math_number_format_ex(num, (int)dec,
dec_point, dec_point_len, thousand_sep, thousand_sep_len));
break;
default:
WRONG_PARAM_COUNT;
}
}&lt;/p&gt;
&lt;h2 id=&quot;%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE&quot; tabindex=&quot;-1&quot;&gt;代码执行流程图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/09/number_format.png&quot; alt=&quot;number_format流程图&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;_php_math_number_format_ex&quot; tabindex=&quot;-1&quot;&gt;&lt;code&gt;_php_math_number_format_ex&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;函数实现的各种参数数量，最终都会调用_php_math_number_format_ex函数。函数主要做的是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;处理负数；
根据要保留的小数点对浮点数进行四舍五入；
调用strpprintf函数将浮点数表达式转成字符串表示；
计算需要分配给结果变量的字符串长度；
将结果拷贝到返回值中（如果有千位符，则进行千位符分割）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;strpprintf&quot; tabindex=&quot;-1&quot;&gt;strpprintf&lt;/h2&gt;
&lt;p&gt;这个函数是实现浮点数与字符串的转换，如上文所说，最终是调用了php_conv_fp函数做的转换（这里是通过gdb调试做的定位），而php_conv_fp函数，往下追踪，调用的是zend_dtoa函数，&lt;/p&gt;
&lt;p&gt;更多细节注解，见&lt;a href=&quot;https://github.com/hoohack/read-php-src/commit/2bac1ac45911d42884b0fe7bda2ecce65dd59235&quot;&gt;github项目提交记录&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;阅读完这个函数的源码，学习到的是浮动数与字符串的互相转换的实现细节，字符串与浮点数之间的关系较复杂，之后还要继续学习。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点个赞吧，谢谢^_^&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>自上而下，逐步揭开PHP解析大整数的面纱</title>
    <link href="https://hoohack.me/blog/2017/2017-09-14-learning-php-big-number-detail/"/>
    <updated>2017-09-14T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2017/2017-09-14-learning-php-big-number-detail/</id>
    <content type="html">&lt;h2 id=&quot;%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98&quot; tabindex=&quot;-1&quot;&gt;遇到的问题&lt;/h2&gt;
&lt;p&gt;最近遇到一个PHP大整数的问题，问题代码是这样的&lt;/p&gt;
&lt;p&gt;$shopId = 17978812896666957068;
var_dump($shopId);&lt;/p&gt;
&lt;p&gt;上面的代码输出，会把$shopId转换成float类型，且使用了科学计数法来表示，输出如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;float(1.7978812896667E+19)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但在程序里需要的是完整的数字作为查找数据的参数，所以需要用的是完整的数字，当时以为只是因为数据被转换成科学计数法了，于是想到的解决方案是强制让它不使用科学计数法表示：&lt;/p&gt;
&lt;p&gt;$shopId= number_format(17978812896666957068);
var_dump($shopId);&lt;/p&gt;
&lt;p&gt;这时候奇怪的事情出现了，输出的是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;17978812896666957824&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当时没有仔细看，对比了前十位就没有继续往下看，所以认为问题解决了，等到真正根据ID去找数据的时候才发现数据查不出来，这时候才发现是数据转换错误了。&lt;/p&gt;
&lt;p&gt;这里使用number_format失败的原因在后面会讲到，当时就想到将原来的数据转成字符串的，但是使用了以下方法仍然不行&lt;/p&gt;
&lt;p&gt;$shopId= strval(17978812896666957068);
var_dump($shopId);&lt;/p&gt;
&lt;p&gt;$shopId = 17978812896666957068 . &#39;&#39;;
var_dump($shopId);&lt;/p&gt;
&lt;p&gt;输出的结果都是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;float(1.7978812896667E+19)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后只有下面这种方案是可行的：&lt;/p&gt;
&lt;p&gt;$shopId = &#39;17978812896666957068&#39;;
var_dump($shopId);&lt;/p&gt;
&lt;p&gt;// 输出
// string(20) &amp;quot;17978812896666957068&amp;quot;&lt;/p&gt;
&lt;p&gt;众所周知，PHP是一门解释型语言，所以当时就大胆地猜测PHP是在编译期间就将数字的字面量常量转换成float类型，并用科学计数法表示。但仅仅猜测不能满足自己的好奇心，想要看到真正实现代码才愿意相信。于是就逐步分析、探索，直到找到背后的实现。&lt;/p&gt;
&lt;p&gt;刚开始根据这个问题直接上网搜“PHP大整数解析过程”，并没有搜到答案，因此只能自己去追查。一开始对PHP的执行过程不熟悉，出发点就只能是一步一步地调试，然后&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;p&gt;// test.php
$var = 17978812896666957068;
var_dump($var);&lt;/p&gt;
&lt;h2 id=&quot;%E8%BF%BD%E6%9F%A5%E8%BF%87%E7%A8%8B&quot; tabindex=&quot;-1&quot;&gt;追查过程&lt;/h2&gt;
&lt;p&gt;1、查看opcode&lt;/p&gt;
&lt;p&gt;通过vld查看PHP执行代码的opcode，可以看到，赋值的是一个ASSIGN的opcode操作
&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/09/php-big-int-1.png&quot; alt=&quot;php整数01&quot; /&gt;&lt;/p&gt;
&lt;p&gt;接下来就想看看ASSIGN是在哪里执行的。&lt;/p&gt;
&lt;p&gt;2、gdb调试&lt;/p&gt;
&lt;p&gt;2-1、用list查看有什么地方可以进行断点&lt;/p&gt;
&lt;p&gt;​&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/09/php-big-int-2.png&quot; alt=&quot;php整数02&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2-2、暂时没有头绪，在1186断点试试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/09/php-big-int-3.png&quot; alt=&quot;php整数03&quot; /&gt;&lt;/p&gt;
&lt;p&gt;结果程序走到sapi/cli/php_cli.c文件的1200行了，按n不断下一步执行，一直到这里就走到了程序输出结果了：
&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/09/php-big-int-4.png&quot; alt=&quot;php整数04&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2-4、于是可以猜测，ASSIGN操作是在do_cli函数里面进行的，因此对do_cli函数做断点：break do_cli。&lt;/p&gt;
&lt;p&gt;输入n，不断回车，在sapi/cli/php_cli.c文件的993行之后就走到程序输出结果了：
&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/09/php-big-int-5.png&quot; alt=&quot;php整数05&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2-5、再对php_execute_script函数做断点：break php_execute_script
不断逐步执行，发现在main/main.c文件的2537行就走到程序输出结果了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/09/php-big-int-6.png&quot; alt=&quot;php整数06&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2-6、继续断点的步骤：break zend_execute_scripts
重复之前的步骤，发现在zend/Zend.c文件的1476行走到了程序输出结果的步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/09/php-big-int-7.png&quot; alt=&quot;php整数07&quot; /&gt;&lt;/p&gt;
&lt;p&gt;看到这里的时候，第1475行里有一个op_array，就猜测会不会是在op_array的时候就已经有值了，于是开始打印op_array的值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/09/php-big-int-8.png&quot; alt=&quot;php整数08&quot; /&gt;&lt;/p&gt;
&lt;p&gt;打印之后并没有看到有用的信息，但是其实这里包含有很大的信息量，比如opcode的handler: &lt;strong&gt;ZEND_ASSIGN_SPEC_CV_RETVAL_CV_CONST_RETVAL_UNUSED_HANDLER&lt;/strong&gt;，但是当时没注意到，因为就想着看看op_array是怎么被赋值的，相关步骤做了什么，忽略了这个重要的信息，之后还是会回到这个handler。&lt;/p&gt;
&lt;p&gt;2-7、重新从2-5的断点开始，让程序逐步执行，看到op_array的赋值如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/09/php-big-int-9.png&quot; alt=&quot;php整数09&quot; /&gt;&lt;/p&gt;
&lt;p&gt;将zend_compile_file函数运行的结果赋值给op_array了，于是break zend_compile_file，被告知zend_compile_file未定义，通过源码工具追踪到zend_compile_file指向的是compile_file，于是break zend_compile&lt;/p&gt;
&lt;p&gt;发现是在Zend/zend_language_scanner.l 文件断点了，逐步执行，看到这行pass_two(op_array)，猜测可能会在这里就有值，所以打印看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/09/php-big-int-10.png&quot; alt=&quot;php整数10&quot; /&gt;&lt;/p&gt;
&lt;p&gt;结果发现还是跟之前的一样，但是此时看到有一个opcodes的值，打印看看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/09/php-big-int-11.png&quot; alt=&quot;php整数11&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/09/php-big-int-12.png&quot; alt=&quot;php整数12&quot; /&gt;&lt;/p&gt;
&lt;p&gt;看到opcode = 38，网上查到38代表赋值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/09/php-big-int-13.png&quot; alt=&quot;php整数13&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2-8、于是可以知道，在这一步之前就已得到了ASSIGN的opcode，因此，不断的往前找，从op_array开始初始化时就开始，逐步打印op_array-&amp;gt;opcodes的值，一直都是null：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/09/php-big-int-14.png&quot; alt=&quot;php整数14&quot; /&gt;&lt;/p&gt;
&lt;p&gt;直到执行了CG(zend_lineno) = last_lineno;才得到opcode = 38 的值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/09/php-big-int-15.png&quot; alt=&quot;php整数15&quot; /&gt;&lt;/p&gt;
&lt;p&gt;因为这一句：CG(zend_lineno) = last_lineno;是一个宏，所以也没头绪，接近放弃状态。。。&lt;/p&gt;
&lt;p&gt;于是先去了解opcode的数据结构，在&lt;a href=&quot;http://www.php-internals.com/book/&quot;&gt;深入理解PHP内核&lt;/a&gt;书里找到opcode处理函数查找这一章，给了我一些继续下去的思路。&lt;/p&gt;
&lt;p&gt;引用里面的内容：&lt;/p&gt;
&lt;p&gt;在PHP内部有一个函数用来快速的返回特定opcode对应的opcode处理函数指针：zend_vm_get_opcode_handler()函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/09/php-big-int-16.png&quot; alt=&quot;php整数16&quot; /&gt;&lt;/p&gt;
&lt;p&gt;知道其实opcode处理函数的命名是有以下规律的&lt;/p&gt;
&lt;p&gt;ZEND_[opcode]&lt;em&gt;SPEC&lt;/em&gt;(变量类型1)_(变量类型2)_HANDLER&lt;/p&gt;
&lt;p&gt;根据之前调试打印出来的内容，在2-6的时候就看到了一个handler的值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/09/php-big-int-17.png&quot; alt=&quot;php整数17&quot; /&gt;&lt;/p&gt;
&lt;p&gt;是
&lt;strong&gt;ZEND_ASSIGN_SPEC_CV_CONST_RETVAL_UNUSED_HANDLER&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;找出函数的定义如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/09/php-big-int-18.png&quot; alt=&quot;php整数18&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到，opcode操作的时候，值是从EX_CONSTANT获取的，根据定义展开这个宏，那就是&lt;/p&gt;
&lt;p&gt;opline-&amp;gt;op2-&amp;gt;execute_data-&amp;gt;literals&lt;/p&gt;
&lt;p&gt;这里可以得到两个信息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1、参数的转换在opcode执行前就做好了&lt;/li&gt;
&lt;li&gt;2、赋值过程取值时是在op2-&amp;gt;execute_data-&amp;gt;literals，如果猜想没错的话，op2-&amp;gt;execute_data-&amp;gt;literals此时保存的就是格式转换后的值，可以打印出来验证一下&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/09/php-big-int-19.png&quot; alt=&quot;php整数19&quot; /&gt;&lt;/p&gt;
&lt;p&gt;猜想验证正确，但是没有看到真正做转换的地方，还是不死心，继续找PHP的Zend底层做编译的逻辑代码。&lt;/p&gt;
&lt;p&gt;参考开源的&lt;a href=&quot;https://github.com/pangudashu/php7-internal&quot;&gt;GitHub项目&lt;/a&gt;，PHP编译阶段如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/09/php-big-int-20.png&quot; alt=&quot;php整数20&quot; /&gt;&lt;/p&gt;
&lt;p&gt;猜测最有可能的是在zendparse、zend_compile_top_stmt这两个阶段完成转换，因为这个两个阶段做的事情就是将PHP代码转换成opcode数组。&lt;/p&gt;
&lt;p&gt;上网搜索了PHP语法分析相关的文章，有一篇里面讲到了解析整数的过程，因此找到了PHP真正将大整数做转换的地方：&lt;/p&gt;
&lt;p&gt;&amp;lt;ST_IN_SCRIPTING&amp;gt;{LNUM} {
char &lt;em&gt;end;
if (yyleng &amp;lt; MAX_LENGTH_OF_LONG - 1) { /&lt;/em&gt; Won&#39;t overflow &lt;em&gt;/
errno = 0;
ZVAL_LONG(zendlval, ZEND_STRTOL(yytext, &amp;amp;end, 0));
/&lt;/em&gt; This isn&#39;t an assert, we need to ensure 019 isn&#39;t valid octal
* Because the lexing itself doesn&#39;t do that for us
&lt;em&gt;/
if (end != yytext + yyleng) {
zend_throw_exception(zend_ce_parse_error, &amp;quot;Invalid numeric literal&amp;quot;, 0);
ZVAL_UNDEF(zendlval);
RETURN_TOKEN(T_LNUMBER);
}
} else {
errno = 0;
ZVAL_LONG(zendlval, ZEND_STRTOL(yytext, &amp;amp;end, 0));
if (errno == ERANGE) { /&lt;/em&gt; Overflow &lt;em&gt;/
errno = 0;
if (yytext[0] == &#39;0&#39;) { /&lt;/em&gt; octal overflow */
ZVAL_DOUBLE(zendlval, zend_oct_strtod(yytext, (const char **)&amp;amp;end));
} else {
ZVAL_DOUBLE(zendlval, zend_strtod(yytext, (const char *&lt;em&gt;)&amp;amp;end));
}
/&lt;/em&gt; Also not an assert for the same reason &lt;em&gt;/
if (end != yytext + yyleng) {
zend_throw_exception(zend_ce_parse_error,
&amp;quot;Invalid numeric literal&amp;quot;, 0);
ZVAL_UNDEF(zendlval);
RETURN_TOKEN(T_DNUMBER);
}
RETURN_TOKEN(T_DNUMBER);
}&lt;br /&gt;
/&lt;/em&gt; Also not an assert for the same reason */
if (end != yytext + yyleng) {
zend_throw_exception(zend_ce_parse_error, &amp;quot;Invalid numeric literal&amp;quot;, 0);
ZVAL_UNDEF(zendlval);
RETURN_TOKEN(T_DNUMBER);
}
}
ZEND_ASSERT(!errno);
RETURN_TOKEN(T_LNUMBER);
}&lt;/p&gt;
&lt;p&gt;可以看到，zend引擎在对PHP代码在对纯数字的表达式做词法分析的时候，先判断数字是否有可能会溢出，如果有可能溢出，先尝试将其用LONG类型保存，如果溢出，先用zend_strtod将其转换为double类型，然后用double类型的zval结构体保存之。&lt;/p&gt;
&lt;h2 id=&quot;number_format%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%8E%9F%E5%9B%A0&quot; tabindex=&quot;-1&quot;&gt;number_format失败的原因&lt;/h2&gt;
&lt;p&gt;通过gdb调试，追查到number_format函数，在PHP底层最终会调用php_conv_fp函数对数字进行转换：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/09/php-big-int-21.png&quot; alt=&quot;php整数21&quot; /&gt;&lt;/p&gt;
&lt;p&gt;函数原型如下：&lt;/p&gt;
&lt;p&gt;PHPAPI char * php_conv_fp(register char format, register double num, boolean_e add_dp, int precision, char dec_point, bool_int * is_negative, char *buf, size_t *len);&lt;/p&gt;
&lt;p&gt;这里接收的参数num是一个double类型，因此，如果传入的是字符串类型数字的话，number_format函数也会将其转成double类型传入到php_conf_fp函数里。而这个double类型的num最终之所以输出为17978812896666957824，是因为进行科学计数法之后的精度丢失了，重新转成double时就恢复不了原来的值。在C语言下验证：&lt;/p&gt;
&lt;p&gt;double local_dval = 1.7978812896666958E+19;
printf(&amp;quot;%f&#92;n&amp;quot;, local_dval);&lt;/p&gt;
&lt;p&gt;输出的结果就是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;17978812896666957824.000000&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，这不是PHP的bug，它就是这样的。&lt;/p&gt;
&lt;h2 id=&quot;%E6%AD%A4%E7%B1%BB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&quot; tabindex=&quot;-1&quot;&gt;此类问题解决方案&lt;/h2&gt;
&lt;p&gt;对于存储，超过PHP最大表示范围的纯整数，在MySQL中可以使用bigint/varchar保存，MySQL在查询出来的时候会将其使用string类型保存的。
对于赋值，在PHP里，如果遇到有大整数需要赋值的话，不要尝试用整型类型去赋值，比如，不要用以下这种：&lt;/p&gt;
&lt;p&gt;$var = 17978812896666957068;&lt;/p&gt;
&lt;p&gt;而用这种：&lt;/p&gt;
&lt;p&gt;$var = &#39;17978812896666957068&#39;;&lt;/p&gt;
&lt;p&gt;而对于number_format，在64位操作系统下，它能解析的精度不会丢失的数，建议的最大值是这个：9007199254740991。参考鸟哥博客：&lt;a href=&quot;http://www.laruence.com/2011/12/19/2399.html&quot;&gt;关于PHP浮点数你应该知道的&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这个问题的原因看起来不太重要，虽然学这个对于实际上的业务开发也没什么用，不会让你的开发能力“duang”地一下上去几个level，但是了解了PHP对于大整数的处理，也是自己知识框架的一个小小积累，知道了为什么之后，在日常开发中就会多加注意，比如从存储以及使用赋值的角度。了解这个细节还是很有好处的。&lt;/p&gt;
&lt;p&gt;回想整个解决问题的过程，个人感觉有点长，总共大约花了4个小时去定位这个问题。因为对PHP的内核只是一知半解，没有系统的把整个流程梳理下来，所以一开始也不知道从哪里开始下手，就开始根据自己的猜测来调试。现在回想起来，应该先学习PHP的编译、执行流程，然后再去猜测具体的步骤。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点个赞吧，谢谢^_^&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>MySQL主从复制原理探索</title>
    <link href="https://hoohack.me/blog/2017/2017-07-11-learning-mysql-replication-detail/"/>
    <updated>2017-07-11T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2017/2017-07-11-learning-mysql-replication-detail/</id>
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://www.hoohack.me/2017/06/24/mark-mysql-replication-bad-case&quot;&gt;上一篇文章&lt;/a&gt;里面，讲到了遇到mysql主从延迟的坑，对于这次的坑多说两句，以前也看过这样的例子，也知道不能够写完之后马上更新，但是真正开发的时候还是没有注意到这一点，道理大家都懂，但是还是会犯错，只有等到自己亲生体验到该错误之后，才真正的掌握到该道理。&lt;/p&gt;
&lt;p&gt;经历过一次mysql主从延迟之后，就开始思考，主从复制是什么东西？它是怎么实现的呢？它的原理是什么？于是乎就开始查阅资料、文章，现将自己理解到的内容总结在此，加深印象。&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%9F&quot; tabindex=&quot;-1&quot;&gt;为什么要做主从复制？&lt;/h2&gt;
&lt;p&gt;1、在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。&lt;/p&gt;
&lt;p&gt;2、做数据的热备&lt;/p&gt;
&lt;p&gt;3、架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。&lt;/p&gt;
&lt;h2 id=&quot;mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F&quot; tabindex=&quot;-1&quot;&gt;mysql主从复制的原理是什么？&lt;/h2&gt;
&lt;p&gt;binlog: binary log，主库中保存所有更新事件日志的二进制文件。&lt;/p&gt;
&lt;p&gt;主从复制的基础是主库记录数据库的所有变更记录到binlog。binlog是数据库服务器启动的那一刻起，保存所有修改数据库结构或内容的一个文件。&lt;/p&gt;
&lt;p&gt;mysql主从复制是一个异步的复制过程，主库发送更新事件到从库，从库读取更新记录，并执行更新记录，使得从库的内容与主库保持一致。&lt;/p&gt;
&lt;p&gt;在主库里，只要有更新事件出现，就会被依次地写入到binlog里面，之后会推到从库中作为从库进行复制的数据源。&lt;/p&gt;
&lt;p&gt;**binlog输出线程。**每当有从库连接到主库的时候，主库都会创建一个线程然后发送binlog内容到从库。
对于每一个即将发送给从库的sql事件，binlog输出线程会将其锁住。一旦该事件被线程读取完之后，该锁会被释放，即使在该事件完全发送到从库的时候，该锁也会被释放。&lt;/p&gt;
&lt;p&gt;在从库里，当复制开始的时候，从库就会创建两个线程进行处理：&lt;/p&gt;
&lt;p&gt;**从库I/O线程。**当START SLAVE语句在从库开始执行之后，从库创建一个I/O线程，该线程连接到主库并请求主库发送binlog里面的更新记录到从库上。
从库I/O线程读取主库的binlog输出线程发送的更新并拷贝这些更新到本地文件，其中包括relay log文件。&lt;/p&gt;
&lt;p&gt;**从库的SQL线程。**从库创建一个SQL线程，这个线程读取从库I/O线程写到relay log的更新事件并执行。&lt;/p&gt;
&lt;p&gt;可以知道，对于每一个主从复制的连接，都有三个线程。拥有多个从库的主库为每一个连接到主库的从库创建一个binlog输出线程，每一个从库都有它自己的I/O线程和SQL线程。&lt;/p&gt;
&lt;p&gt;从库通过创建两个独立的线程，使得在进行复制时，从库的读和写进行了分离。因此，即使负责执行的线程运行较慢，负责读取更新语句的线程并不会因此变得缓慢。比如说，如果从库有一段时间没运行了，当它在此启动的时候，尽管它的SQL线程执行比较慢，它的I/O线程可以快速地从主库里读取所有的binlog内容。这样一来，即使从库在SQL线程执行完所有读取到的语句前停止运行了，I/O线程也至少完全读取了所有的内容，并将其安全地备份在从库本地的relay log，随时准备在从库下一次启动的时候执行语句。&lt;/p&gt;
&lt;h2 id=&quot;%E6%9F%A5%E7%9C%8B%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E7%8A%B6%E6%80%81&quot; tabindex=&quot;-1&quot;&gt;查看主从复制的状态&lt;/h2&gt;
&lt;p&gt;当主从复制正在进行中时，如果想查看从库两个线程运行状态，可以通过执行在从库里执行”show slave status&#92;G”语句，以下的字段可以给你想要的信息：&lt;/p&gt;
&lt;p&gt;Master_Log_File — 上一个从主库拷贝过来的binlog文件
Read_Master_Log_Pos — 主库的binlog文件被拷贝到从库的relay log中的位置
Relay_Master_Log_File — SQL线程当前处理中的relay log文件
Exec_Master_Log_Pos — 当前binlog文件正在被执行的语句的位置&lt;/p&gt;
&lt;p&gt;整个主从复制的流程可以通过以下图示理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/07/DB-replication.png&quot; alt=&quot;DB Replication&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;步骤一：主库db的更新事件(update、insert、delete)被写到binlog&lt;/li&gt;
&lt;li&gt;步骤二：从库发起连接，连接到主库&lt;/li&gt;
&lt;li&gt;步骤三：此时主库创建一个binlog dump thread，把binlog的内容发送到从库&lt;/li&gt;
&lt;li&gt;步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log&lt;/li&gt;
&lt;li&gt;步骤五：还会创建一个SQL线程，从relay log里面读取内容，从&lt;strong&gt;Exec_Master_Log_Pos&lt;/strong&gt;位置开始执行读取到的更新事件，将更新内容写入到slave的db&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;注：上面的解释是解释每一步做了什么，整个mysql主从复制是异步的，不是按照上面的步骤执行的。&lt;/p&gt;
&lt;h2 id=&quot;%E5%85%B6%E4%BB%96&quot; tabindex=&quot;-1&quot;&gt;其他&lt;/h2&gt;
&lt;p&gt;关于主从复制架构的搭建，可以参考网上更多的文档，文笔有限，不做更多的介绍。&lt;/p&gt;
&lt;p&gt;作为一名开发，这些基础的mysql知识还是需要多多学习。&lt;/p&gt;
&lt;h2 id=&quot;%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99&quot; tabindex=&quot;-1&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://dbadiaries.com/what-is-mysql-replication-and-how-does-it-work&quot;&gt;What is MySQL Replication and How Does It Work?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.6/en/replication-implementation-details.html&quot;&gt;Replication Implementation Details&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点个赞吧，谢谢^_^&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>【踩坑记录】记一次MySQL主从复制延迟的坑</title>
    <link href="https://hoohack.me/blog/2017/2017-06-24-mark-mysql-replication-bad-case/"/>
    <updated>2017-06-24T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2017/2017-06-24-mark-mysql-replication-bad-case/</id>
    <content type="html">&lt;p&gt;最近开发中遇到的一个MySQL主从延迟的坑，记录并总结，避免再次犯同样的错误。&lt;/p&gt;
&lt;h2 id=&quot;%E6%83%85%E6%99%AF&quot; tabindex=&quot;-1&quot;&gt;情景&lt;/h2&gt;
&lt;p&gt;一个活动信息需要审批，审批之后才能生效。因为之后活动要编辑，编辑后也可能触发审批，审批中展示的是编辑前的活动内容，考虑到字段比较多，也要保存审批活动的内容，因此设计采用了一张临时表，审批中的活动写进审批表(activity_tmp)，审批通过之后才把真正的活动内容写进活动表(activity)。表的简要设计如下，这里将活动内容字段合并为content展示：&lt;/p&gt;
&lt;p&gt;activity_tmp（）
id
status // 审批状态&lt;br /&gt;
content //  审批阶段提交的活动内容&lt;/p&gt;
&lt;p&gt;activity
id
content // 审批通过后真正展示的活动内容&lt;/p&gt;
&lt;h2 id=&quot;%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98&quot; tabindex=&quot;-1&quot;&gt;遇到的问题&lt;/h2&gt;
&lt;p&gt;当时是有编辑触发审批的情况，发现审批通过之后活动内容是空的，于是开始追查问题的原因。这里说一句，当程序出问题的时候，95%都是代码的问题，先不要去怀疑环境出问题。好好的查日志，然后看看你的代码吧。&lt;/p&gt;
&lt;h2 id=&quot;%E8%BF%BD%E6%9F%A5%E9%97%AE%E9%A2%98%E5%9B%9E%E6%BA%AF&quot; tabindex=&quot;-1&quot;&gt;追查问题回溯&lt;/h2&gt;
&lt;p&gt;1、查activity_tmp表，发现当时提交审批的活动内容是正常的，而且状态也更新为审批通过了，怀疑是写入activity表失败
2、查activity表，发现审批后的内容确实没有写入，怀疑是代码问题
3、查看代码，代码逻辑没看出问题，怀疑数据库操作失败，查看日志
4、日志显示，有一句insert语句的活动内容为空，活动内容来自上一个mysql执行的是select语句，把该select语句拿出来放到线上的备库查询，发现活动内容是存在的。运行时查询为空，执行完毕后查询时内容存在，初步怀疑是主从延迟问题。
5、报错只是部分失败，确定是主从延迟的问题。&lt;/p&gt;
&lt;h2 id=&quot;%E5%BD%93%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A3%E7%A0%81&quot; tabindex=&quot;-1&quot;&gt;当时的问题代码&lt;/h2&gt;
&lt;p&gt;$intStatus = $arrInput[‘status’];
$this-&amp;gt;objActTmp-&amp;gt;updateInfoByAId($intActId, $intStatus);
// 更新后，马上查
$arrActContent = $this-&amp;gt;objActTmp-&amp;gt;getActByStatus($intStatus);&lt;/p&gt;
&lt;p&gt;这就是主从延迟出现的地方，update后，马上get，这是主从复制架构上开发的一个大忌。&lt;/p&gt;
&lt;h2 id=&quot;%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&quot; tabindex=&quot;-1&quot;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;这类问题的解决方案有两种：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;修改代码逻辑&lt;/li&gt;
&lt;li&gt;修改系统架构&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于修改代码逻辑，鄙人有两点见解：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果第二步获取的数据不需要第一步更新的status字段，那就先读，然后再更新&lt;/li&gt;
&lt;li&gt;如果第二步获取的数据需要依赖第一步的status字段，那就在读出来的时候先判断是否为空，如果是空的，报错，下一次重试。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;其实之前也听到过这样的例子，但是由于没有亲身经历，所以只保留了一种理论上的记忆，实际上印象不深，经历了这么一次踩坑后，印象特别深刻，现在看到别人写这样的代码也能马上发现并指出。还是自己亲身去踩坑印象最深。&lt;/p&gt;
&lt;p&gt;日志很重要，详细的日志更重要。日志要记录有用的信息，方便追查问题的时候去追溯问题的本质原因。我觉得日志就应该尽量做成飞机中的黑匣子，帮助我们保存“事故“发生时的所有相关信息。&lt;/p&gt;
&lt;p&gt;接下来，会去学习主从复制的原理，敬请期待。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点个赞吧，谢谢^_^&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>[源码学习]cjson库学习</title>
    <link href="https://hoohack.me/blog/2017/2017-04-27-learning-src-cjson/"/>
    <updated>2017-04-27T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2017/2017-04-27-learning-src-cjson/</id>
    <content type="html">&lt;h2 id=&quot;cjson%E5%BA%93%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F&quot; tabindex=&quot;-1&quot;&gt;cJSON库是什么？&lt;/h2&gt;
&lt;p&gt;cJSON是一个轻量级的json解析库。使用起来非常简单，整个库非常地简洁，核心功能的实现都在cJSON.c文件，非常适合阅读源代码来学习C语言。最近读完这个库的源码，分享自己收获的一些心得。&lt;/p&gt;
&lt;h2 id=&quot;%E4%BB%80%E4%B9%88%E6%98%AFjson%EF%BC%8C%E7%85%A7%E6%90%ACjson%E5%AE%98%E7%BD%91%E7%9A%84%E8%AF%B4%E6%B3%95%EF%BC%9A&quot; tabindex=&quot;-1&quot;&gt;什么是json，照搬json官网的说法：&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;cjson%E5%BA%93%E9%87%8C%E9%9D%A2%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F&quot; tabindex=&quot;-1&quot;&gt;cJSON库里面有什么？&lt;/h2&gt;
&lt;p&gt;cjson库github地址：&lt;a href=&quot;https://github.com/DaveGamble/cJSON&quot;&gt;https://github.com/DaveGamble/cJSON&lt;/a&gt;
整个库包含cJSON.h和cJSON.c两个文件，头文件定义了一系列的API。这个库最基本也最重要的功能就是解析一个json字符串，使用的API是cJSON_Parse。cJSON_Parse函数调用了cJSON_ParseWithOpts函数，该函数实现了具体的逻辑。&lt;/p&gt;
&lt;p&gt;两个函数的原型如下：&lt;/p&gt;
&lt;p&gt;CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value);
CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated);&lt;/p&gt;
&lt;p&gt;函数接收一段字符串，然后进行解析后返回。解析完返回的是一个cjson结构，cJSON结构的定义如下：&lt;/p&gt;
&lt;p&gt;typedef struct cJSON
{
struct cJSON *next; // 向后指针
struct cJSON *prev; // 向前指针&lt;/p&gt;
&lt;p&gt;struct cJSON *child; // 指向子元素，比如子数组或者子对象&lt;/p&gt;
&lt;p&gt;int type; // 元素的类型&lt;/p&gt;
&lt;p&gt;char *valuestring; // 元素的字符串值，如果type == cJSON_String 或者 type == cJSO_Raw&lt;/p&gt;
&lt;p&gt;int valueint; // 已废弃，现在使用cJSON_SetNumberValue设置整型值&lt;/p&gt;
&lt;p&gt;double valuedouble; // 元素的整型值，如果type == cJSON_Number&lt;/p&gt;
&lt;p&gt;char *string; // 表示元素键值的值，如果它有子元素的话
} cJSON;&lt;/p&gt;
&lt;h2 id=&quot;%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E4%B8%80%E4%B8%AAjson%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9F&quot; tabindex=&quot;-1&quot;&gt;如何解析一个json字符串？&lt;/h2&gt;
&lt;p&gt;json的官网在这里，&lt;a href=&quot;http://www.json.org/&quot;&gt;http://www.json.org&lt;/a&gt;
网站首页描述了json是什么以及它的格式规范，有了规范之后，可以知道json是如何构成的，因此就有了如何解析json数据的方向。&lt;/p&gt;
&lt;p&gt;json使用两种结构构建，对象或者数组。&lt;/p&gt;
&lt;p&gt;对象使用&lt;code&gt;{&lt;/code&gt;作开头，&lt;code&gt;}&lt;/code&gt;作结尾，里边的每一个元素都是键值对的无序集合，键名和值使用&lt;code&gt;:&lt;/code&gt;分隔，使用&lt;code&gt;,&lt;/code&gt;分隔每一个元素；数组使用[作开头，]作结尾，里面的元素都是有序的值组成的集合，且使用&lt;code&gt;,&lt;/code&gt;做分隔符。&lt;/p&gt;
&lt;p&gt;每一个值可以是字符串，整型，也可以是true，false，null等常量，还可以是对象或数组，因为json结构是可嵌套的。&lt;/p&gt;
&lt;p&gt;因此，我们可以得知：&lt;/p&gt;
&lt;p&gt;1、可以根据json的首字母判断整个json的类型，如果json以&lt;code&gt;&#39;{&#39;&lt;/code&gt;开头时，就是对象，以&lt;code&gt;&#39;[&#39;&lt;/code&gt;开头时，就是数组，否则就是字符串或者其他常量。&lt;/p&gt;
&lt;p&gt;2、如果是对象，那么它的一定有键名，先解析它的键名，然后解析它的值，解析值的过程与第一步一样，递归解析&lt;/p&gt;
&lt;p&gt;3、如果是数组，则逐个解析数组内的元素，直到遇到&lt;code&gt;]&lt;/code&gt;为止，解析数组里面的元素的过程也是与第一步一致，递归解析。&lt;/p&gt;
&lt;p&gt;这就是根据json官网的定义得出解析json字符串的思路，接下来看看cJSON库是如何实现的。cJSON_Parse的实现流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/04/cjson-process.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;cJSON_ParseWithOpts函数里面调用了parse_value，是整个函数的核心实现。
parse_value函数的流程图如下所示：
&lt;img src=&quot;https://www.hoohack.me/assets/images/2017/04/cjson-parse-value.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到，parse_value是对json值的开头进行判断，然后进入相应的分支进行解析，下面对每一个分支进行分析。解析出来的值是保存在cJSON的结构体中，以下命名为item。&lt;/p&gt;
&lt;h3 id=&quot;%E5%B8%B8%E9%87%8F&quot; tabindex=&quot;-1&quot;&gt;常量&lt;/h3&gt;
&lt;p&gt;如果json值是以&#39;null&#39;,&#39;true&#39;,&#39;false&#39;,则分别将item的type设置为cJSON_NULL、cJSON_TRUE、cJSON_FALSE。然后继续解析剩下的json值。&lt;/p&gt;
&lt;h3 id=&quot;string&quot; tabindex=&quot;-1&quot;&gt;string&lt;/h3&gt;
&lt;p&gt;如果遇到&amp;quot;开头，则说明json值是字符串，就解析它的值，此时只需要拿到两个&amp;quot;之间的值即可。保存字符串也是一个结构体，需要申请内存，计算长度的过程中，当遇到转义字符时，需要记录，因为转义符不保存。&lt;/p&gt;
&lt;h3 id=&quot;number&quot; tabindex=&quot;-1&quot;&gt;number&lt;/h3&gt;
&lt;p&gt;当遇到数字开头时，将其后面的数字字符记录起来，然后转成整型数字，然后做值的范围检查。&lt;/p&gt;
&lt;h3 id=&quot;array&quot; tabindex=&quot;-1&quot;&gt;array&lt;/h3&gt;
&lt;p&gt;解析数组时，为数组的元素创建一个新的json结构体new_item，然后继续解析数组里面的值，用&#39;,&#39;判断下一个元素的位置，得到的值保存到结构体中，并将多个元素用链表连接起来。一直解析，直到遇到&#39;]&#39;符号。&lt;/p&gt;
&lt;h3 id=&quot;object&quot; tabindex=&quot;-1&quot;&gt;object&lt;/h3&gt;
&lt;p&gt;解析对象的过程与数组的类似，为对象的元素创建一个新的json结构体new_item，然后继续解析对象里面的值，对象是有键值对组成的，因此先得到键的值，然后用&#39;:&#39;判断值的位置，进而继续解析得到值，多个键值对之间用&#39;,&#39;分隔开，最后用链表连接起来。一直解析，直到遇到&#39;}&#39;符号。&lt;/p&gt;
&lt;h2 id=&quot;%E5%85%B6%E4%BB%96&quot; tabindex=&quot;-1&quot;&gt;其他&lt;/h2&gt;
&lt;p&gt;在解析所有值之前，会调用skip_whitespace函数过滤字符串两边的所有空白字符。此处是ASCII码小于等于32的字符，如：&#92;t、&#92;n。函数如下：&lt;/p&gt;
&lt;p&gt;static const unsigned char *skip_whitespace(const unsigned char *in)
{
while (in &amp;amp;&amp;amp; *in &amp;amp;&amp;amp; (*in &amp;lt;= 32))
{
in++;
}&lt;/p&gt;
&lt;p&gt;return in;
}&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过阅读这个小小的json解析库，知道了大部分的json库是如何实现的，自己对json的认识也有了一个更深刻的印象。
学习到了一种解析某种格式的字符串的思路，要先知道该字符串格式的规范，直到它是如何组成的，有哪些规则和注意的地方，从它的组成规范中逐步分解和解析。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点个赞吧，谢谢^_^&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>[深入学习Redis]RedisAPI的原子性分析</title>
    <link href="https://hoohack.me/blog/2017/2017-04-04-analysis-redis-commands-atomicity/"/>
    <updated>2017-04-04T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2017/2017-04-04-analysis-redis-commands-atomicity/</id>
    <content type="html">&lt;p&gt;在学习Redis的常用操作时，经常看到介绍说，Redis的set、get以及hset等等命令的执行都是原子性的，但是令自己百思不得其解的是，为什么这些操作是原子性的？&lt;/p&gt;
&lt;h2 id=&quot;%E5%8E%9F%E5%AD%90%E6%80%A7&quot; tabindex=&quot;-1&quot;&gt;原子性&lt;/h2&gt;
&lt;p&gt;原子性是数据库的事务中的特性。在数据库事务的情景下，原子性指的是：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。&lt;a href=&quot;https://zh.wikipedia.org/wiki/ACID&quot;&gt;【维基百科】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于Redis而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。&lt;/p&gt;
&lt;h2 id=&quot;redis%E6%93%8D%E4%BD%9C%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%E5%8E%9F%E5%9B%A0&quot; tabindex=&quot;-1&quot;&gt;Redis操作原子性的原因&lt;/h2&gt;
&lt;p&gt;Redis的操作之所以是原子性的，是因为Redis是单线程的。&lt;/p&gt;
&lt;p&gt;由于对操作系统相关的知识不是很熟悉，从上面这句话并不能真正理解Redis操作是原子性的原因，进一步查阅进程与线程的概念及其区别。&lt;/p&gt;
&lt;h2 id=&quot;%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B&quot; tabindex=&quot;-1&quot;&gt;进程与线程&lt;/h2&gt;
&lt;h3 id=&quot;%E8%BF%9B%E7%A8%8B&quot; tabindex=&quot;-1&quot;&gt;进程&lt;/h3&gt;
&lt;p&gt;计算机中已执行程序的实体。&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B&quot;&gt;【维基百科】&lt;/a&gt;。比如，一个启动了的php-fpm，就是一个进程。&lt;/p&gt;
&lt;h3 id=&quot;%E7%BA%BF%E7%A8%8B&quot; tabindex=&quot;-1&quot;&gt;线程&lt;/h3&gt;
&lt;p&gt;操作系统能够进行运算调度的最小单元。它被包含在进程之中，是进程的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B&quot;&gt;【维基百科】&lt;/a&gt;。比如，mysql运行时，mysql启动后，该mysql服务就是一个进程，而mysql的连接、查询的操作，就是线程。&lt;/p&gt;
&lt;h3 id=&quot;%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB&quot; tabindex=&quot;-1&quot;&gt;进程与线程的区别&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;资源（如打开文件）：进程间的资源相互独立，同一进程的各线程间共享资源。某进程的线程在其他进程不可见。&lt;/li&gt;
&lt;li&gt;通信：进程间通信：消息传递、同步、共享内存、远程过程调用、管道。线程间通信：直接读写进程数据段（需要进程同步和互斥手段的辅助，以保证数据的一致性）。&lt;/li&gt;
&lt;li&gt;调度和切换：线程上下文切换比进程上下文切换要快得多。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;线程，是操作系统最小的执行单元，在单线程程序中，任务一个一个地做，必须做完一个任务后，才会去做另一个任务。&lt;/p&gt;
&lt;h2 id=&quot;redis%E5%9C%A8%E5%B9%B6%E5%8F%91%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%8E%B0&quot; tabindex=&quot;-1&quot;&gt;Redis在并发中的表现&lt;/h2&gt;
&lt;p&gt;Redis的API是原子性的操作，那么多个命令在并发中也是原子性的吗？&lt;/p&gt;
&lt;p&gt;看看下面这段代码：&lt;/p&gt;
&lt;p&gt;$redis = new Redis();
$redis-&amp;gt;connect(&#39;127.0.0.1&#39;, 6379);
for($i = 0; $i &amp;lt; 1000; $i++) {
$num = (int) $redis-&amp;gt;get(&#39;val&#39;);
$num++;
$redis-&amp;gt;set(&#39;val&#39;, $num);
usleep(10000);
}&lt;/p&gt;
&lt;p&gt;用两个终端执行上面的程序，发现val的结果是小于2000的值，那么可以知道，在程序中执行多个Redis命令并非是原子性的，这也和普通数据库的表现是一样的。&lt;/p&gt;
&lt;p&gt;如果想在上面的程序中实现原子性，可以将get和set改成单命令操作，比如incr，或者使用Redis的事务，或者使用Redis+Lua的方式实现。&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;综上所述，对Redis来说，执行get、set以及eval等API，都是一个一个的任务，这些任务都会由Redis的线程去负责执行，任务要么执行成功，要么执行失败，这就是Redis的命令是原子性的原因。&lt;/p&gt;
&lt;p&gt;Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点下推荐吧，谢谢^_^&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>[计算机网络]httpserver--如何解析HTTP请求报文</title>
    <link href="https://hoohack.me/blog/2016/2016-11-06-mhs-parse-request/"/>
    <updated>2016-11-06T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-11-06-mhs-parse-request/</id>
    <content type="html">&lt;p&gt;这个http server的实现源代码我放在了&lt;a href=&quot;https://github.com/hoohack/Makehttpd&quot;&gt;我的github上&lt;/a&gt;，有兴趣的话可以点击查看哦。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.hoohack.me/2016/10/28/lcn-simple-server&quot;&gt;上一篇文章&lt;/a&gt;中，讲述了如何编写一个最简单的server，但该程序只是接受到请求之后马上返回响应，实在不能更简单。在正常的开发中，应该根据不同的请求做出不同的响应。要做到上述的功能，首先要解析客户端发来的请求报文。&lt;/p&gt;
&lt;p&gt;报文在不同的上下文情景下有不同的理解，本文所说的报文都是在HTTP上下文中描述的名词。&lt;/p&gt;
&lt;h2 id=&quot;http%E6%8A%A5%E6%96%87%E6%98%AF%E4%BB%80%E4%B9%88&quot; tabindex=&quot;-1&quot;&gt;HTTP报文是什么&lt;/h2&gt;
&lt;p&gt;在HTTP程序中，报文就是HTTP用来搬运东西的包裹，也可以理解为程序之间传递信息时发送的数据块。这些数据块以一些文本形式的元信息开头，这些信息描述了报文的内容和含义，后面跟着可选的数据部分。&lt;/p&gt;
&lt;h2 id=&quot;%E6%8A%A5%E6%96%87%E7%9A%84%E6%B5%81%E5%8A%A8&quot; tabindex=&quot;-1&quot;&gt;报文的流动&lt;/h2&gt;
&lt;p&gt;HTTP使用属于流入和流出来描述报文的传递方向。HTTP报文会像合水一样流动。不管时请求报文还是响应报文，都会向下游流动，所有报文的发送者都在接受者的上游。下图展示了报文向下游流动的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/package-float.png&quot; alt=&quot;报文向下游流动&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%84%E6%88%90&quot; tabindex=&quot;-1&quot;&gt;报文的组成&lt;/h2&gt;
&lt;p&gt;报文由三个部分组成：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;对报文进行描述的起始行&lt;/li&gt;
&lt;li&gt;包含属性的首部块&lt;/li&gt;
&lt;li&gt;可选的、包含数据的主体部分&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;起始行和首部是由行分隔的ASCII文本。每行都以一个由两个字符（回车符--ASCII码13和换行符--ASCII码10）组成的行终止序列结束。可以写做&lt;strong&gt;CRLF&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;尽管规范说明应该用CRLF来表示行终止，但稳健的应用程序也应该接受单个换行作为行的终止。笔者仅支持以CRLF换行的解析，因为我觉得既然有了规范，那就需要遵循，遵循相同的协议的程序才能互相通信。&lt;/p&gt;
&lt;p&gt;实体是一个可选的数据块。与起始行和首部不同的是，主体中可以包含主体或二进制数据，也可以为空（比如仅仅GET一个页面或文件）。&lt;/p&gt;
&lt;p&gt;下面来看看报文的语法的格式和规则。&lt;/p&gt;
&lt;h3 id=&quot;%E6%8A%A5%E6%96%87%E7%9A%84%E8%AF%AD%E6%B3%95&quot; tabindex=&quot;-1&quot;&gt;报文的语法&lt;/h3&gt;
&lt;p&gt;请求报文的语法：&lt;/p&gt;
&lt;p&gt;&amp;lt;method&amp;gt; &amp;lt;request-URL&amp;gt; &amp;lt;version&amp;gt;
&amp;lt;headers&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;entity-body&amp;gt;&lt;/p&gt;
&lt;p&gt;响应报文的语法：&lt;/p&gt;
&lt;p&gt;&amp;lt;version&amp;gt; &amp;lt;status-code&amp;gt; &amp;lt;reason-phrase&amp;gt;
&amp;lt;headers&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;entity-body&amp;gt;&lt;/p&gt;
&lt;p&gt;method，方法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端希望服务器对资源执行的操作。比如GET、POST&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;request-URL，请求URL&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请求资源，或者URL路径组件的完整URL。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;version，版本&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;报文所使用的HTTP版本。格式：HTTP/&amp;lt;major&amp;gt;.&amp;lt;minor&amp;gt;。其中major(主要版本号)和minor(次要版本号)都是整数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;status-code，状态码&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;描述请求过程所发生的情况的数字。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;reason-phrase，原因短语&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数字状态码的文字描述版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;headers，首部&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每个首部包含一个名字，后面跟着一个冒号(:)，然后是一个可选的空格，接着是一个值，最后是一个CRLF。可以有零个或多个首部。首部由一个CRLF结束，表示首部结束和实体主体开始。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;entity-body，实体的主体部分&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;包含一个由任意数据组成的数据块。可以没有，此时是以一个CRLF结束。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;%E8%AF%B7%E6%B1%82%E8%A1%8C&quot; tabindex=&quot;-1&quot;&gt;请求行&lt;/h3&gt;
&lt;p&gt;请求报文的起始行称为请求行。所有的HTTP报文都以一行起始行作为开始。请求行包含一个方法和一个请求URL以及HTTP的版本三个字段。每个字段都以空格分隔。&lt;/p&gt;
&lt;p&gt;比如：&lt;strong&gt;GET / HTTP/1.1&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;请求方法为GET，请求URL为/，HTTP版本为HTTP/1.1。&lt;/p&gt;
&lt;h3 id=&quot;%E5%93%8D%E5%BA%94%E8%A1%8C&quot; tabindex=&quot;-1&quot;&gt;响应行&lt;/h3&gt;
&lt;p&gt;响应报文的起始行称为响应行。响应行包含HTTP版本、数字状态码以及描述操作状态的文本形式的原因短语。三个字段也是以空格分隔。&lt;/p&gt;
&lt;p&gt;比如：&lt;strong&gt;HTTP/1.1 200 OK&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;HTTP版本为HTTP/1.1，数字状态码是200，原因短语是OK。表示请求成功。&lt;/p&gt;
&lt;h3 id=&quot;%E9%A6%96%E9%83%A8&quot; tabindex=&quot;-1&quot;&gt;首部&lt;/h3&gt;
&lt;p&gt;首部是是包含在请求和响应报文的一些附加信息。本质上，他们只是一些键值对的列表。&lt;/p&gt;
&lt;p&gt;比如：&lt;strong&gt;Content-Length: 19&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表示返回内容长度为19。&lt;/p&gt;
&lt;h3 id=&quot;%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%BB%E4%BD%93%E9%83%A8%E5%88%86&quot; tabindex=&quot;-1&quot;&gt;实体的主体部分&lt;/h3&gt;
&lt;p&gt;简单地说，这部分就是HTTP要传输的内容。&lt;/p&gt;
&lt;h2 id=&quot;%E8%A7%A3%E6%9E%90%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87&quot; tabindex=&quot;-1&quot;&gt;解析请求报文&lt;/h2&gt;
&lt;p&gt;了解了报文是如何组成和各部分代表的内容之后，就对如何解析请求报文心里有数了。&lt;/p&gt;
&lt;h3 id=&quot;%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81&quot; tabindex=&quot;-1&quot;&gt;核心代码&lt;/h3&gt;
&lt;p&gt;/* 解析请求行 */
int parse_start_line(int sockfd, char *recv_buf, req_pack *rp)
{
char *p = recv_buf;
char *ch = p;
int i = 0;
enum parts { method, url, ver } req_part = method;
char *method_str;
char *url_str;
char *ver_str;
int k = 0;&lt;/p&gt;
&lt;p&gt;if (*ch &amp;lt; &#39;A&#39; || *ch &amp;gt; &#39;Z&#39;) {
return -1;
}&lt;/p&gt;
&lt;p&gt;while (*ch != CR) {
if (*ch != BLANK) {
k++;
} else if (req_part == method) {
method_str = (char *)malloc(k * sizeof(char *));
memset(method_str, 0, sizeof(char *));
strncpy(method_str, recv_buf, k);
k = 0;
req_part = url;
} else if (req_part == url) {
url_str = (char *)malloc(k * sizeof(char *));
memset(url_str, 0, sizeof(char *));
strncpy(url_str, recv_buf + strlen(method_str) + 1, k);
k = 0;
req_part = ver;
}
ch++;
i++;
}&lt;/p&gt;
&lt;p&gt;if (req_part == url) {
if (k != 0) {
url_str = (char *)malloc(k * sizeof(char));
memset(url_str, 0, sizeof(char));
strncpy(url_str, recv_buf + strlen(method_str) + 1, k);
k = 0;
} else {
return -1;
}
}&lt;/p&gt;
&lt;p&gt;if (k == 0) {
ver_str = (char *)malloc(8 * sizeof(char));
memset(ver_str, 0, sizeof(char));
strcpy(ver_str, &amp;quot;HTTP/1.1&amp;quot;);
} else {
ver_str = (char *)malloc(k * sizeof(char));
memset(ver_str, 0, sizeof(char));
strncpy(ver_str,
recv_buf + strlen(method_str) + strlen(url_str) + 2, k);
}&lt;/p&gt;
&lt;p&gt;rp-&amp;gt;method = method_str;
rp-&amp;gt;url = url_str;
rp-&amp;gt;version = ver_str;&lt;/p&gt;
&lt;p&gt;return (i + 2);
}&lt;/p&gt;
&lt;p&gt;/* 解析首部字段 */
int parse_header(int sockfd, char *recv_buf, header headers[])
{
char *p = recv_buf;
char *ch = p;
int i = 0;
int k = 0;
int v = 0;
int h_i = 0;
bool is_newline = false;
char *key_str;
char *value_str;
header *tmp_header = (header *)malloc(sizeof(header *));
memset(tmp_header, 0, sizeof(header));&lt;/p&gt;
&lt;p&gt;while (1) {
if (*ch == CR &amp;amp;&amp;amp; *(ch + 1) == LF) {
break;
}
while (*ch != COLON) {
ch++;
i++;
k++;
}
if (*ch == COLON) {
key_str = (char *)malloc(k * sizeof(char *));
memset(key_str, 0, sizeof(char *));
strncpy(key_str, recv_buf + i - k, k);
k = 0;
ch++;
i++;
}
while (*ch != CR) {
ch++;
i++;
v++;
}
if (*ch == CR) {
value_str = (char *)malloc(v * sizeof(char *));
memset(value_str, 0, sizeof(char *));
strncpy(value_str, recv_buf + i - v, v);
v = 0;
i++;
ch++;
}
i++;
ch++;
headers[h_i].key = key_str;
headers[h_i].value = value_str;
h_i++;
}&lt;/p&gt;
&lt;p&gt;return (i + 2);
}&lt;/p&gt;
&lt;h3 id=&quot;%E8%A7%A3%E6%9E%90%E6%80%9D%E6%83%B3&quot; tabindex=&quot;-1&quot;&gt;解析思想&lt;/h3&gt;
&lt;p&gt;遍历recv接受到的请求字符串，检查是否遇到回车符**&#92;r**判断一行数据。&lt;/p&gt;
&lt;p&gt;对于起始行，检查是否遇到空格分隔不同的字段；对于首部，检查是否遇到冒号分隔键值对的字段值；对于实体的主体部分，则先判断是否遇到CRLF字符串，然后将剩余内容全部作为实体的主体部分。&lt;/p&gt;
&lt;p&gt;返回值是告知程序下一次遍历的起始位置。&lt;/p&gt;
&lt;p&gt;如果遇到非法请求行则返回400的响应。&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;解析报文的过程就是遵循HTTP协议规定的内容去解析报文，获取报文包含的信息。&lt;/p&gt;
&lt;p&gt;由于基础知识较薄弱，代码还有很多错误以及很多地方需要优化。如果有看到错误的地方或有其它建议望各位大侠不吝赐教。^_^&lt;/p&gt;
&lt;p&gt;这个http server的实现源代码我放在了&lt;a href=&quot;https://github.com/hoohack/Makehttpd&quot;&gt;我的github上&lt;/a&gt;，有兴趣的话可以点击查看哦。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点下推荐吧，谢谢^_^&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>[计算机网络]简易http server程序</title>
    <link href="https://hoohack.me/blog/2016/2016-10-28-lcn-simple-server/"/>
    <updated>2016-10-28T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-10-28-lcn-simple-server/</id>
    <content type="html">&lt;p&gt;这个http server的实现源代码我放在了&lt;a href=&quot;https://github.com/hoohack/Makehttpd&quot;&gt;我的github上&lt;/a&gt;，有兴趣的话可以点击查看哦。&lt;/p&gt;
&lt;p&gt;好久没输出了，知识还是要写下总结才能让思路更加清晰。最近在学习计算机网络相关的知识，来聊聊如何编写一个建议的HTTP服务器。&lt;/p&gt;
&lt;h2 id=&quot;http-%E6%9C%8D%E5%8A%A1%E5%99%A8&quot; tabindex=&quot;-1&quot;&gt;HTTP 服务器&lt;/h2&gt;
&lt;p&gt;HTTP服务器，就是一个运行在主机上的程序。程序启动了之后，会一直在等待其他所有客户端的请求，接收到请求之后，处理请求，然后发送响应给客户端。客户端和服务器之间使用HTTP协议进行通信，所有遵循HTTP协议的程序都可以作为客户端。&lt;/p&gt;
&lt;p&gt;先直接上代码，然后再详细说明实现细节。&lt;/p&gt;
&lt;p&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;ctype.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;&lt;/p&gt;
&lt;p&gt;#define PORT 9001
#define QUEUE_MAX_COUNT 5
#define BUFF_SIZE 1024&lt;/p&gt;
&lt;p&gt;#define SERVER_STRING &amp;quot;Server: hoohackhttpd/0.1.0&#92;r&#92;n&amp;quot;&lt;/p&gt;
&lt;p&gt;int main()
{
/* 定义server和client的文件描述符 */
int server_fd = -1;
int client_fd = -1;&lt;/p&gt;
&lt;p&gt;u_short port = PORT;
struct sockaddr_in client_addr;
struct sockaddr_in server_addr;
socklen_t client_addr_len = sizeof(client_addr);&lt;/p&gt;
&lt;p&gt;char buf[BUFF_SIZE];
char recv_buf[BUFF_SIZE];
char hello_str[] = &amp;quot;Hello world!&amp;quot;;&lt;/p&gt;
&lt;p&gt;int hello_len = 0;&lt;/p&gt;
&lt;p&gt;/* 创建一个socket &lt;em&gt;/
server_fd = socket(AF_INET, SOCK_STREAM, 0);
if (server_fd == -1) {
perror(&amp;quot;socket&amp;quot;);
exit(-1);
}
memset(&amp;amp;server_addr, 0, sizeof(server_addr));
/&lt;/em&gt; 设置端口，IP，和TCP/IP协议族 */
server_addr.sin_family = AF_INET;
server_addr.sin_port = htons(PORT);
server_addr.sin_addr.s_addr = htonl(INADDR_ANY);&lt;/p&gt;
&lt;p&gt;/* 绑定套接字到端口 */
if (bind(server_fd, (struct sockaddr *)&amp;amp;server_addr,
sizeof(server_addr)) &amp;lt; 0) {
perror(&amp;quot;bind&amp;quot;);
exit(-1);
}&lt;/p&gt;
&lt;p&gt;/* 启动socket监听请求，开始等待客户端发来的请求 */
if (listen(server_fd, QUEUE_MAX_COUNT) &amp;lt; 0) {
perror(&amp;quot;listen&amp;quot;);
exit(-1);
}&lt;/p&gt;
&lt;p&gt;printf(&amp;quot;http server running on port %d&#92;n&amp;quot;, port);&lt;/p&gt;
&lt;p&gt;while (1) {
/* 调用了accept函数，阻塞了程序，直到接收到客户端的请求 */
client_fd = accept(server_fd, (struct sockaddr *)&amp;amp;client_addr,
&amp;amp;client_addr_len);
if (client_fd &amp;lt; 0) {
perror(&amp;quot;accept&amp;quot;);
exit(-1);
}
printf(&amp;quot;accept a client&#92;n&amp;quot;);&lt;/p&gt;
&lt;p&gt;printf(&amp;quot;client socket fd: %d&#92;n&amp;quot;, client_fd);
/* 调用recv函数接收客户端发来的请求信息 */
hello_len = recv(client_fd, recv_buf, BUFF_SIZE, 0);&lt;/p&gt;
&lt;p&gt;printf(&amp;quot;receive %d&#92;n&amp;quot;, hello_len);&lt;/p&gt;
&lt;p&gt;/* 发送响应给客户端 */
sprintf(buf, &amp;quot;HTTP/1.0 200 OK&#92;r&#92;n&amp;quot;);
send(client_fd, buf, strlen(buf), 0);
strcpy(buf, SERVER_STRING);
send(client_fd, buf, strlen(buf), 0);
sprintf(buf, &amp;quot;Content-Type: text/html&#92;r&#92;n&amp;quot;);
send(client_fd, buf, strlen(buf), 0);
strcpy(buf, &amp;quot;&#92;r&#92;n&amp;quot;);
send(client_fd, buf, strlen(buf), 0);
sprintf(buf, &amp;quot;Hello World&#92;r&#92;n&amp;quot;);
send(client_fd, buf, strlen(buf), 0);&lt;/p&gt;
&lt;p&gt;/* 关闭客户端套接字 */
close(client_fd);
}&lt;/p&gt;
&lt;p&gt;close(server_fd);&lt;/p&gt;
&lt;p&gt;return 0;
}&lt;/p&gt;
&lt;h2 id=&quot;%E6%B5%8B%E8%AF%95%E8%BF%90%E8%A1%8C&quot; tabindex=&quot;-1&quot;&gt;测试运行&lt;/h2&gt;
&lt;p&gt;代码写好之后，运行测试一下，将上面代码保存到server.c，然后编译程序：&lt;/p&gt;
&lt;p&gt;gcc server.c -o server&lt;/p&gt;
&lt;p&gt;./server运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/runserver.jpg&quot; alt=&quot;runserver&quot; /&gt;&lt;/p&gt;
&lt;p&gt;服务器运行，监听9001端口。再用&lt;code&gt;netstat&lt;/code&gt;命令查看：
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/server_netstat.jpg&quot; alt=&quot;server_netstat&quot; /&gt;&lt;/p&gt;
&lt;p&gt;server程序在监听9001端口，运行正确。接着用浏览器访问http://localhost:9001&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/browser_server.jpg&quot; alt=&quot;browser_server&quot; /&gt;&lt;/p&gt;
&lt;p&gt;成功输出了Hello World&lt;/p&gt;
&lt;p&gt;再尝试用&lt;code&gt;telnet&lt;/code&gt;去模拟HTTP请求：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/telnet_http.jpg&quot; alt=&quot;telnet_http&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、成功连接&lt;/li&gt;
&lt;li&gt;2、发送HTTP请求&lt;/li&gt;
&lt;li&gt;3、HTTP响应结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面是一个最简单的server程序，代码比较简单，省去一些细节，下面通过代码来学习一下socket的编程细节。&lt;/p&gt;
&lt;h2 id=&quot;%E5%90%AF%E5%8A%A8server%E7%9A%84%E6%B5%81%E7%A8%8B&quot; tabindex=&quot;-1&quot;&gt;启动server的流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/server.png&quot; alt=&quot;server流程&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;socket-%E5%87%BD%E6%95%B0&quot; tabindex=&quot;-1&quot;&gt;socket 函数&lt;/h2&gt;
&lt;p&gt;创建一个套接字，通过各参数指定套接字的类型。&lt;/p&gt;
&lt;p&gt;int socket(int family, int type, int protocol);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;family：协议族。AF_INET：IPV4协议；AF_INET6：IPv6协议；AF_LOCAL：Unix域协议；AF_ROUTE：路由套接字；AF_KEY：密钥套接字&lt;/li&gt;
&lt;li&gt;type：套接字类型。SOCK_STREAM ： 字节流套接字；SOCK_DGRAM：数据包套接字；SOCK_SEGPACKET：有序分组套接字；SOCK_RAW：原始套接字&lt;/li&gt;
&lt;li&gt;protocol：某个协议类型常量。TCP：0，UDP ：1， SCTP ：2&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84&quot; tabindex=&quot;-1&quot;&gt;套接字地址结构&lt;/h3&gt;
&lt;p&gt;在socket编程中，大部分函数都用到一个指向套接字地址结构的指针作为参数。针对不同的协议类型，会有不同的结构体定义格式，对于ipv4，结构如下所示：&lt;/p&gt;
&lt;p&gt;struct sockaddr_in {
uint8_t            sin_len;        /* 结构体的长度 &lt;em&gt;/
sa_family_t        sin_family;     /&lt;/em&gt; IP协议族，IPV4是AF_INET &lt;em&gt;/
in_port_t          sin_port;       /&lt;/em&gt; 一个16比特的TCP/UDP端口地址 &lt;em&gt;/
struct in_addr     sin_addr;       /&lt;/em&gt; 32比特的IPV4地址，网络字节序 &lt;em&gt;/
char               sin_zero[8];    /&lt;/em&gt; 未使用字段 */
};
注：sockaddr_in是&lt;strong&gt;Internet socket address structure&lt;/strong&gt;的缩写。&lt;/p&gt;
&lt;h3 id=&quot;ip%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84&quot; tabindex=&quot;-1&quot;&gt;ip地址结构&lt;/h3&gt;
&lt;p&gt;struct in_addr {
in_addr_t      s_addr;
};&lt;/p&gt;
&lt;p&gt;套接字地址结构的作用是为了将ip地址和端口号传递到socket函数，写成结构体的方式是为了抽象。当作为一个参数传递进任何套接字函数时，套接字地址结构总是以引用方式传递。然而，协议族有很多，因此以这样的指针作为参数之一的任何套接字函数必须处理来自所有支持的任何协议族的套接字地址结构。使用&lt;code&gt;void *&lt;/code&gt;作为通用的指针类型，因此，套接字函数被定义为以指向某个通用套接字结构的一个指针作为其参数之一，正如下面的bind函数原型一样。&lt;/p&gt;
&lt;p&gt;int bind(int, struct sockaddr *, socklen_t);&lt;/p&gt;
&lt;p&gt;这就要求，对这些函数的任何调用都必须要将指向特定于协议的套接字地址结构的指针进行强制类型转换，变成某个通用套接字地址结构的指针。例如：&lt;/p&gt;
&lt;p&gt;struct sockaddr_in addr;
bind(sockfd, (struct sockaddr *)&amp;amp;addr , sizeof(addr));&lt;/p&gt;
&lt;p&gt;对于所有socket函数而言，sockaddr的唯一用途就是对指向特定协议的套接字地址结构的指针执行强制类型转换，指向要绑定给sockfd的协议地址。&lt;/p&gt;
&lt;h2 id=&quot;bind%E5%87%BD%E6%95%B0&quot; tabindex=&quot;-1&quot;&gt;bind函数&lt;/h2&gt;
&lt;p&gt;将套接字地址结构绑定到套接字&lt;/p&gt;
&lt;p&gt;int bind(sockfd, (struct sockaddr *)&amp;amp;addr, sizeof(addr));&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sockfd：socket描述符，唯一标识一个socket。bind函数就是将这个描述字绑定一个名字。&lt;/li&gt;
&lt;li&gt;addr：一个sockaddr指针，指向要绑定给sockfd的协议地址。一个socket由ip和端口号唯一确定，而sockaddr就包含了ip和端口的信息
地址的长度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;绑定了socket之后，就可以使用该socket开始监听请求了。&lt;/p&gt;
&lt;h2 id=&quot;listen%E5%87%BD%E6%95%B0&quot; tabindex=&quot;-1&quot;&gt;listen函数&lt;/h2&gt;
&lt;p&gt;将sockfd从未连接的套接字转换成一个被动套接字，指示内核应接受指向该套接字的连接请求。&lt;/p&gt;
&lt;p&gt;int listen(int sockfd, int backlog);
listen函数会将套接字从CLOSED状态转换到LISTEN状态，第二个参数规定内核应该为相应套接字排队的最大连接个数。&lt;/p&gt;
&lt;p&gt;关于backlog参数，内核为任何一个给定的监听套接字维护两个队列：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1、未完成连接队列，在队列里面的套接字处于SYN_RCVD状态&lt;/li&gt;
&lt;li&gt;2、已完成队列，处于ESTABLISHED状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;两个队列之和不超过backlog的大小。&lt;/p&gt;
&lt;p&gt;listen完成之后，socket就处于LISTEN状态，此时的socket调用accept函数就可以接受客户端发来的请求了。&lt;/p&gt;
&lt;h2 id=&quot;accept%E5%87%BD%E6%95%B0&quot; tabindex=&quot;-1&quot;&gt;accept函数&lt;/h2&gt;
&lt;p&gt;int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen);
用于从已完成连接队列头返回下一个已完成连接，如果已完成连接队列为空，那么进程就会被阻塞。因此调用了accept函数之后，进程就会被阻塞，直到有新的请求到来。&lt;/p&gt;
&lt;p&gt;第一个参数sockfd是客户端的套接字描述符，第二个是客户端的套接字地址结构，第三个是套接字地址结构的长度。&lt;/p&gt;
&lt;p&gt;如果accept成功，那么返回值是由内核自动生成的全新描述符，代表所返回的客户端的TCP连接。&lt;/p&gt;
&lt;p&gt;对于accept函数，第一个参数称为监听套接字描述符，返回值称为已连接套接字。服务器仅创建监听套接字，它一直存在。已连接套接字由服务器进程接受的客户连接创建，当服务器完成某个连接的响应后，相应的已连接套接字就被关闭了。&lt;/p&gt;
&lt;p&gt;accept函数返回时，会返回套接字描述符或出错指示的整数，以及引用参数中的套接字地址和该地址的大小。如果对返回值不感兴趣，可以把两个引用参数设为空。&lt;/p&gt;
&lt;p&gt;accept之后，一个TCP连接就建立起来了，接着，服务器就接受客户端的请求信息，然后做出响应。&lt;/p&gt;
&lt;h2 id=&quot;recv%E5%92%8Csend%E5%87%BD%E6%95%B0&quot; tabindex=&quot;-1&quot;&gt;recv和send函数&lt;/h2&gt;
&lt;p&gt;ssize_t recv(int sockfd, void *buff, size_t nbytes, int flags);
ssize_t send(int sockfd, const void *buff, size_t nbytes, int flags);&lt;/p&gt;
&lt;p&gt;分别用于从客户端读取信息和发送信息到客户端。在此不做过多的解释。&lt;/p&gt;
&lt;h2 id=&quot;%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E5%A4%A7%E5%B0%8F%E5%92%8C%E5%80%BC-%E7%BB%93%E6%9E%9C%E5%8F%82%E6%95%B0&quot; tabindex=&quot;-1&quot;&gt;套接字地址结构大小和值-结果参数&lt;/h2&gt;
&lt;p&gt;可以看到，在bind函数和accept函数里面，都有一个套接字地址结构长度的参数，区别在于一个是值形式，另一个是引用形式。套接字地址结构的传递方式取决于该结构的传递方向：是从进程到内核，还是从内核到进程。&lt;/p&gt;
&lt;p&gt;1、从进程到内核：bind、connect、sendto。
函数将指针和指针所指内容的大小都传给了内核，于是内核知道到底需要从进程复制多少数据进来。&lt;/p&gt;
&lt;p&gt;2、从内核到进程：
accept、recvfrom、getsockname、getperrname。
这四个函数的结构大小是以只引用的方式传递。
因为当函数被调用时，结构大小是一个值，它告诉内核该结构的大小，这样内核在写该结构时不至于越界；当函数返回时，结构大小又是一个结果，它告诉内核在该结构中究竟存储了多少信息。&lt;/p&gt;
&lt;h2 id=&quot;http%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87&quot; tabindex=&quot;-1&quot;&gt;HTTP响应报文&lt;/h2&gt;
&lt;p&gt;发送响应给客户端时，发送的报文要遵循HTTP协议，HTTP的响应报文格式如下：&lt;/p&gt;
&lt;p&gt;&amp;lt;status-line&amp;gt;
&amp;lt;headers&amp;gt;
&amp;lt;blank line&amp;gt;
[&amp;lt;response-body&amp;gt;]&lt;/p&gt;
&lt;p&gt;第一行status-line，状态栏，格式：&lt;code&gt;HTTP版本 状态码 状态码代表文字&lt;/code&gt;headers是返回报文的类型，长度等信息，接着是一个空行，然后是响应报文的实体。&lt;/p&gt;
&lt;p&gt;一个HTTP响应报文例子：&lt;/p&gt;
&lt;p&gt;HTTP/1.1 200 OK
Content-Type: text/html;charset=utf-8
Content-Length: 122&lt;/p&gt;
&lt;p&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;Hello Server&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
Hello Server
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/p&gt;
&lt;p&gt;最后close函数关闭套接字，时刻保持关闭文件描述符是一个很好的编程习惯。&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;虽然很多东西看起来很简单，但只有自己真正动手做一遍，才发现其中的简单，之后才能说这些基础是最简单的。要更好和更深入地理解系统的知识，你必须重新一点一点地重新构建一次。&lt;/p&gt;
&lt;p&gt;这个http server的实现源代码我放在了&lt;a href=&quot;https://github.com/hoohack/Makehttpd&quot;&gt;我的github上&lt;/a&gt;，有兴趣的话可以点击查看哦。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>[代码大全读书笔记]如何定义一个好的变量名</title>
    <link href="https://hoohack.me/blog/2016/2016-07-25-how-to-define-great-variable-name/"/>
    <updated>2016-07-25T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-07-25-how-to-define-great-variable-name/</id>
    <content type="html">&lt;p&gt;在日常编程中最烦恼的就是给变量取名，一段好代码，既要能完美地运行，还要能较容易地维护。这就意味着需要让日后维护代码的人能很快地看懂你的代码，而且，在团队合作中，其他开发者也会经常阅读你那部分代码。如果你的代码中充满了a,b,c,a1,a2,a3...那简直就是一个噩梦。因此，好的变量名非常重要。&lt;/p&gt;
&lt;h2 id=&quot;%E9%80%89%E6%8B%A9%E5%A5%BD%E5%8F%98%E9%87%8F%E5%90%8D%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9&quot; tabindex=&quot;-1&quot;&gt;选择好变量名的注意事项&lt;/h2&gt;
&lt;p&gt;变量和变量名本质上是同一件事物，因此，变量的好与坏就在很大程度上取决于它的命名的好与坏。&lt;/p&gt;
&lt;p&gt;下面举一个糟糕命名的例子&lt;/p&gt;
&lt;p&gt;$pp = ($cp &amp;gt; 1) ? ($cp - 1) : $cp;
$np = ($cp &amp;lt; $tp) ? ($cp + 1) : $tp;&lt;/p&gt;
&lt;p&gt;$p = new P($pp, $cp, $np, $tp);&lt;/p&gt;
&lt;p&gt;这段代码在做什么呢？也许可以大概知道是在计算一些信息，但是，计算的是什么信息呢？$p,$pp,np,$tp等等这些变量代表的是什么呢？讲真，如果没有任何注释，任何人都无法看不懂这段代码想表达的意思。如果写这段代码的人告诉你，这段代码是在计算分页信息，然后实例化一个分页类，那么你应该如何命名呢？&lt;/p&gt;
&lt;p&gt;下面是这段代码的另一种写法，看起来更加清晰：&lt;/p&gt;
&lt;p&gt;$prev_page_num = ($curr_page_num &amp;gt; 1) ? ($curr_page_num - 1) : $curr_page_num);
$next_page_num = ($next_page_num &amp;lt; $total_page_num) ? ($curr_page_num + 1) : $total_page_num);&lt;/p&gt;
&lt;p&gt;$page = new Page($prev_page_num, $curr_page_num, $next_page_num, $total_page_num);&lt;/p&gt;
&lt;p&gt;从上面两段代码可以看出，一个好的变量名在可读性和可维护性上是极其重要的。而且好的变量名是易记的。可以通过应用多条原则来实现这些目标。&lt;/p&gt;
&lt;h3 id=&quot;%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E5%91%BD%E5%90%8D%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9&quot; tabindex=&quot;-1&quot;&gt;最重要的命名注意事项&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;名字要完全、准确地描述出该变量所代表的事物&lt;/li&gt;
&lt;li&gt;用名字表达变量所代表的是什么，不包含晦涩的缩写，同时也没有歧义&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;下表给出一些变量名称的例子，其中有好的也有差的。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;变量用途&lt;/th&gt;
&lt;th&gt;好名字，好描述&lt;/th&gt;
&lt;th&gt;坏名字，差描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;到期的支票累计额&lt;/td&gt;
&lt;td&gt;runningTotal,checkTotal&lt;/td&gt;
&lt;td&gt;written,ct,checks,CHKTTL,x,x1,x2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;高速列车的运行速度&lt;/td&gt;
&lt;td&gt;velocity,trainVelocity,velocityInMph&lt;/td&gt;
&lt;td&gt;velt,v,tv,x,x1,x2,train&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;当前日期&lt;/td&gt;
&lt;td&gt;currentDate,todaysDate&lt;/td&gt;
&lt;td&gt;cd,current,c,x,x1,x2,date&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每页的行数&lt;/td&gt;
&lt;td&gt;linesPerPage&lt;/td&gt;
&lt;td&gt;lpp,lines,l,x,x1,x2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;currentDate和todaysDate都是很好的名字，因为它们都完全而且准确地描述出了“当前日期”这一概念。&lt;/p&gt;
&lt;p&gt;cd和c是很糟糕的命名，因为它们用了太短的缩写，而且又不具有描述性。&lt;/p&gt;
&lt;p&gt;current也很糟，因为它并没有告诉你是当前什么。&lt;/p&gt;
&lt;p&gt;date看上去不错，但经过最后推敲它也只是个坏名字，因为这里所说的日期并不是所有的日期均可，而只是特指当前日期，而date本身并未表达出这层含义。&lt;/p&gt;
&lt;p&gt;x,x1和x2永远都是坏名字--传统上用x代表一个未知量，如果不希望你的变量所代表的是一个未知量，那么请考虑取一个更好的名字吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;名字应该尽可能地明确。像x、temp、i这些名字都泛泛可得可以用于多种目的，它们并没有像应该的那样提供足够信息，因此通常是命名上的败笔。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;%E4%BB%A5%E9%97%AE%E9%A2%98%E4%B8%BA%E5%AF%BC%E5%90%91&quot; tabindex=&quot;-1&quot;&gt;以问题为导向&lt;/h3&gt;
&lt;p&gt;一个好记的名字反映的通常都是问题，而不是解决方案。即，一个好名字通常表达的是什么（What），而不是怎么样（How）。通常来说，如果一个名字反映了计算机的某些方面而不是问题本身，那么它反映的就是“How”而非“What”了。&lt;/p&gt;
&lt;p&gt;比如，考虑下面这两个变量命名：inputRec和employeeData。inputRec是一个反映输入、记录这些计算概念的计算机术语。employeeData则直指问题领域，与计算机无关。
类似地，printerReady比bitFlag更能表达打印机的状态；在财务软件里，calcVar比sum来得更准确。&lt;/p&gt;
&lt;h3 id=&quot;%E6%9C%80%E9%80%82%E5%BD%93%E7%9A%84%E5%90%8D%E5%AD%97%E9%95%BF%E5%BA%A6&quot; tabindex=&quot;-1&quot;&gt;最适当的名字长度&lt;/h3&gt;
&lt;p&gt;经研究发现，变量名的平均长度在10到16个字符的时候，调试花的力气是最小的。平均名字长度在8到20隔字符的程序也几乎同样容易调试。这并不意味着你的变量名一定要在8到20个字符，它强调的是，如果你查看自己写的代码时发现了很多更短的名字，那么你就需要认真检查，确保这些名字含义足够清晰。&lt;/p&gt;
&lt;p&gt;下面展示变量名太长、太短或刚好的示例：&lt;/p&gt;
&lt;p&gt;太长 : numberOfPeopleOnTheUsOlympicTeam; numberOfSeatsInTheStadium; maximumNumberOfPointsInModernOlympics&lt;/p&gt;
&lt;p&gt;太短 : n, np, ntm; n, ms, nsisd; m, mp, max, points&lt;/p&gt;
&lt;p&gt;正好 : numTeamMembers, teamMemberCount; numSeatsInStadium, seatCount; teamPointsMax, pointsRecord&lt;/p&gt;
&lt;h3 id=&quot;%E5%8F%98%E9%87%8F%E5%90%8D%E4%B8%AD%E7%9A%84%E8%AE%A1%E7%AE%97%E5%80%BC%E9%99%90%E5%AE%9A%E8%AF%8D&quot; tabindex=&quot;-1&quot;&gt;变量名中的计算值限定词&lt;/h3&gt;
&lt;p&gt;很多程序都有表示计算结果的变量：总额、平均值、最大值，等等。如果你要用类似Total、Sum、Average、Max、Min、Record、String、Pointer这样的限定词来修改某个名字，那么请记住把限定词加到名字的最后。&lt;/p&gt;
&lt;p&gt;这种方法的优点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;变量名中最重要的那部分，即为这一变量赋予主要含义的部分应当位于最前面，这样，这一部分就可以显得最为突出，并会被首先阅读到；&lt;/li&gt;
&lt;li&gt;避免了由于同时在程序中使用totalRevenue和revenueTotal而产生的歧义&lt;/li&gt;
&lt;li&gt;使用统一的编码规范可以提高可读性，简化维护工作。比如，revenueTotal、expenseTotal、revenueAverage、expenseAverage这组名字具有非常优雅的对称性。而totalRevenue、expenseTotal、revenueAverage、averageRevenue这组名字中则看不出什么规律来。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;这条规则也有例外，那就是Num的限定词的位置已经是约定俗成的。Num放在变量名的开始位置代表一个总数，比如：numCustomers表示员工的总数。Num放在变量名的结束位置代表一个下标：customerNum表示的是当前员工的序号。这样使用Num常常会带来麻烦，因此，最好的方法是避开这些问题，使用Count或者Total来代表总数，使用Index来指代某个特定的员工。这样，customerCount就代表员工的总数，customerIndex代表某个特定的员工。&lt;/p&gt;
&lt;h3 id=&quot;%E5%8F%98%E9%87%8F%E5%90%8D%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%AF%B9%E4%BB%97%E8%AF%8D&quot; tabindex=&quot;-1&quot;&gt;变量名中的常用对仗词&lt;/h3&gt;
&lt;p&gt;对仗词要使用正确，不然会产生歧义。&lt;/p&gt;
&lt;p&gt;常用对仗词如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;begin/end&lt;/li&gt;
&lt;li&gt;first/last&lt;/li&gt;
&lt;li&gt;locked/unlocked&lt;/li&gt;
&lt;li&gt;min/max&lt;/li&gt;
&lt;li&gt;next/previous&lt;/li&gt;
&lt;li&gt;old/new&lt;/li&gt;
&lt;li&gt;opened/closed&lt;/li&gt;
&lt;li&gt;visible/invisible&lt;/li&gt;
&lt;li&gt;source/target&lt;/li&gt;
&lt;li&gt;source/destination&lt;/li&gt;
&lt;li&gt;up/down&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E4%B8%BA%E7%89%B9%E5%AE%9A%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%91%BD%E5%90%8D&quot; tabindex=&quot;-1&quot;&gt;为特定类型的数据命名&lt;/h2&gt;
&lt;p&gt;为变量命名，除了通常的考虑事项之外，为一些特定类型数据的命名还要求作出一些特殊的考虑。比如，循环变量、状态变量、临时变量等等。&lt;/p&gt;
&lt;h3 id=&quot;%E4%B8%BA%E5%BE%AA%E7%8E%AF%E4%B8%8B%E6%A0%87%E5%91%BD%E5%90%8D&quot; tabindex=&quot;-1&quot;&gt;为循环下标命名&lt;/h3&gt;
&lt;p&gt;在循环中，最常见的下标变量就是i,j,k，如：&lt;/p&gt;
&lt;p&gt;for(i = 0; i &amp;lt; arrLen; i++) {
// ...
}&lt;/p&gt;
&lt;p&gt;如果循环下标变量只在循环内部使用，那么如此使用是没问题的，但是，如果该变量需要在循环之外使用，那么就应该为它取一个比i,j,k更有意义的名字。举个栗子，如果你从文件中读取记录，并且需要记下所读取记录的数量，那么类似于redcordCount这样的名字就更合适：&lt;/p&gt;
&lt;p&gt;recordCount = 0;
while ( moreScores() ) {
score[recordCount] = GetNextScore();
recordCount++;
}&lt;/p&gt;
&lt;p&gt;// using recordCount&lt;/p&gt;
&lt;p&gt;另一种情况就是嵌套循环，比较常犯的错误就是在想写j的时候写了i，想用i的时候却写了j。&lt;/p&gt;
&lt;p&gt;如果你使用了多个嵌套的循环，那么就应该给循环变量赋予更长的名字以提高可读性：&lt;/p&gt;
&lt;p&gt;for ( teamIndex = 0; teamIndex &amp;lt; teamCount; teamIndex++) {
for ( eventIndex = 0; eventIndex &amp;lt; eventCount[teamIndex]; eventIndex++) {
score[teamIndex][eventIndex] = 0;
}
}&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;score[teamIndex][eventIndex] 比 score[i][j]给出的信息更多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意：如果你一定要用i、j、k，那么不要把它们用于简单循环的循环下标之外的任何场合，避免造成误解。要想避免这种问题，最简单的方法就是使用更好的命名而不是i，j，k。&lt;/p&gt;
&lt;h3 id=&quot;%E4%B8%BA%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D&quot; tabindex=&quot;-1&quot;&gt;为状态变量命名&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;为状态变量取一个比flag更好的名字。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最好是把标记看作是状态变量。标记的名字中不应该含有flag，因为你从中丝毫看不出该标记是做什么的。&lt;/p&gt;
&lt;p&gt;为清楚可见，标记应该使用枚举变量、具名常量，或用作具名常量的全局变量来对其赋值。&lt;/p&gt;
&lt;p&gt;看看下面比较差的标记命名：&lt;/p&gt;
&lt;p&gt;if ( flag ) ...
if ( statusFlag &amp;amp; 0x0F ) ...
if ( printFlag == 16 ) ...
if ( computeFlag == 0 ) ...&lt;/p&gt;
&lt;p&gt;flag = 0x1;
statusFlag = 0x80;
printFlag = 16;
computeFlag = 0;&lt;/p&gt;
&lt;p&gt;上面这段代码反映不出能做什么，如果没有文档，不知道statusFlag = 0x80的含义是什么。下面是作用相同但更为清晰的代码：&lt;/p&gt;
&lt;p&gt;if ( dataReady ) ...
if ( characterType &amp;amp; PRINTABLE_CHAR ) ...
if ( reportType == ReportTyoe_Annual ) ...
if ( recalcNeeded == false ) ...&lt;/p&gt;
&lt;p&gt;dataReady = true;
characterType = CONTRAL_CHARACTER;
reportType = ReportType_Annual;
recalNeeded = false;&lt;/p&gt;
&lt;p&gt;这段代码更加清晰。而且说明你可以结合枚举类型和预定义的具名常量来使用这种方法。&lt;/p&gt;
&lt;p&gt;如果你发现自己需要猜测某段代码的含义的时候，就该考虑为变量重新命名。代码应该尽可能直接读懂。&lt;/p&gt;
&lt;h3 id=&quot;%E4%B8%BA%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D&quot; tabindex=&quot;-1&quot;&gt;为临时变量命名&lt;/h3&gt;
&lt;p&gt;临时变量常用于存储计算的中间结果，作为临时占位符，以及存储内部值。它们常被赋予temp，tmp，x或者其他一些模糊且缺乏描述性的名字。通常，临时变量是一个信号，表明程序缘还没有完全把问题弄清楚。而且，由于这些变量被正式地赋予了一种“临时”状态，因此程序员会倾向于比其他变量更为随意地对待这些变量，从而增加了出错的可能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;警惕临时变量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;临时地保存一些变量是很有必要的。但无论从哪种角度看，程序中的大多数变量都是临时性的。把其中几个称为临时的，可能表明你还没有弄清它们的实际用途。看看下面的示例：&lt;/p&gt;
&lt;p&gt;temp = sqrt( b^2 - 4&lt;em&gt;a&lt;/em&gt;c );
root[0] = ( -b + temp ) / ( 2&lt;em&gt;a );
root[1] = ( -b - temp ) / ( 2&lt;/em&gt;a );&lt;/p&gt;
&lt;p&gt;更好的做法：&lt;/p&gt;
&lt;p&gt;discriminant = sqrt( b^2 - 4&lt;em&gt;a&lt;/em&gt;c );
root[0] = ( -b + discriminant ) / ( 2&lt;em&gt;a );
root[1] = ( -b - discriminant ) / ( 2&lt;/em&gt;a );&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;discriminant，判别式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;%E4%B8%BA%E5%B8%83%E5%B0%94%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D&quot; tabindex=&quot;-1&quot;&gt;为布尔变量命名&lt;/h3&gt;
&lt;p&gt;典型的布尔变量名：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;done&lt;/li&gt;
&lt;li&gt;error&lt;/li&gt;
&lt;li&gt;found&lt;/li&gt;
&lt;li&gt;success/ok&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;给布尔变量赋予隐含“真/假”含义的名字&lt;/strong&gt;。像done和success一样，它们的值不是true就是false，表示某件事情完成了或者没有完成；成功或者失败。另一方面，想status这样的名字却是很糟的布尔变量名，因为它们没有明确的true或者false。status是true反映的是什么含义呢？表示某件事情拥有一个状态吗？然而，每件事情都有状态。true表明某件事情的状态是OK吗？或者说false表明没有任何错误吗？对于status，你什么都说不出。&lt;/p&gt;
&lt;p&gt;为了更好的效果，可以把status命名为error或者statusOK。&lt;/p&gt;
&lt;p&gt;有时，也可以在布尔变量名前加上Is。这样，变量名就成了一个问题：isDone?isError?isFound?用true或false回答问题也就为该变量给出了取值。优点是不能用于那些模糊不清的名字，比如：isStatus?毫无意义。缺点就是降低了简单逻辑表达式的可读性：if(isFound)的可读性要略差于if(Found)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用肯定的布尔变量名&lt;/strong&gt;。避免双重否定：not notFound。&lt;/p&gt;
&lt;h3 id=&quot;%E4%B8%BA%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%91%BD%E5%90%8D&quot; tabindex=&quot;-1&quot;&gt;为枚举类型命名&lt;/h3&gt;
&lt;p&gt;在使用枚举类型的时候，可以通过使用组前缀，如Color_，Planet_或者Month_来明确标识该类型的成员都同属于一个组。比如：&lt;/p&gt;
&lt;p&gt;Public Enum Color
Color_Red
Color_Green
Color_Blue
End Enum&lt;/p&gt;
&lt;p&gt;Public Enum Planet
Planet_Earth
Planet_Mars
Planet_Venus
End Enum&lt;/p&gt;
&lt;p&gt;在有些编程语言里，枚举类型的处理很像类，枚举类型也总是被冠以枚举名字前缀，比如Color.Color_Red或者Planet.Planet_Earth。如果你正在使用这样的编程语言，那么重复上述前缀的意义就不大了，可以简化为Color.Red和Planet.Earth。&lt;/p&gt;
&lt;h3 id=&quot;%E4%B8%BA%E5%B8%B8%E9%87%8F%E5%91%BD%E5%90%8D&quot; tabindex=&quot;-1&quot;&gt;为常量命名&lt;/h3&gt;
&lt;p&gt;在具名常量时，应该根据该常量所表示的含义，而不是该常量所具有的数值为该抽象事物命名。比如FIVE是个很糟糕的常量名，CYCLES_NEEDED是个不错的名字。&lt;/p&gt;
&lt;h2 id=&quot;%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E7%9A%84%E5%8A%9B%E9%87%8F&quot; tabindex=&quot;-1&quot;&gt;命名规则的力量&lt;/h2&gt;
&lt;p&gt;很多程序员会抵制标准和约定（有时我也会这样），并且有很好的理由：有些标准和约定非常刻板并且低效--它们会毁坏创造性和程序质量。&lt;/p&gt;
&lt;h3 id=&quot;%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%A7%84%E5%88%99&quot; tabindex=&quot;-1&quot;&gt;为什么要有规则&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;要求你更多地按规矩行事。集中精力关注代码更重要的特征；&lt;/li&gt;
&lt;li&gt;有助于在项目之间传递知识；&lt;/li&gt;
&lt;li&gt;有助于在新项目中更快速地学习代码；&lt;/li&gt;
&lt;li&gt;有助于减少名字增生，在没有规则下，很容易给同一个对象起两个不同的名字；&lt;/li&gt;
&lt;li&gt;弥补编程语言的不足之处；&lt;/li&gt;
&lt;li&gt;强调相关变量之间的关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;关键是，采用任何一项规则都要好于没有规则。规则可能是武断的。命名规则的威力并非来源于你所采取的某个特定规则，而是来源于以下事实：规则的存在为你的代码增加了结构，减少了你需要考虑的事情。&lt;/p&gt;
&lt;h3 id=&quot;%E4%BD%95%E6%97%B6%E9%87%87%E7%94%A8%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99&quot; tabindex=&quot;-1&quot;&gt;何时采用命名规则&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;多个程序员合作开发一个项目时&lt;/li&gt;
&lt;li&gt;计划把一个程序转交给另一位程序员来修改和维护的时候&lt;/li&gt;
&lt;li&gt;你所在组织中的其他程序员评估你写的程序的时候&lt;/li&gt;
&lt;li&gt;当你写的程序规模过大，以致于你无法在脑海里同时了解事情的全貌，而必须分而治之的时候&lt;/li&gt;
&lt;li&gt;你写的程序生命期足够长，长到你可能会在把它搁置几个星期或几个月之后又重新启动有关该程序的工作时&lt;/li&gt;
&lt;li&gt;当在一个项目中存在一些不常见的术语，并且你希望在编写代码阶段使用标准的术语或缩写的时候&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E9%9D%9E%E6%AD%A3%E5%BC%8F%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99&quot; tabindex=&quot;-1&quot;&gt;非正式命名规则&lt;/h2&gt;
&lt;p&gt;尽管上面介绍了很多比较标准的命名规则，但是大多数项目采用的都是相对非正式的命名规则。&lt;/p&gt;
&lt;h3 id=&quot;%E4%B8%8E%E8%AF%AD%E8%A8%80%E6%97%A0%E5%85%B3%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E7%9A%84%E6%8C%87%E5%AF%BC%E5%8E%9F%E5%88%99&quot; tabindex=&quot;-1&quot;&gt;与语言无关的命名规则的指导原则&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;区分变量名和子程序名字&lt;/li&gt;
&lt;li&gt;区分类和对象&lt;/li&gt;
&lt;li&gt;标识全局变量&lt;/li&gt;
&lt;li&gt;标识成员变量&lt;/li&gt;
&lt;li&gt;标识类型声明&lt;/li&gt;
&lt;li&gt;标识具名常量&lt;/li&gt;
&lt;li&gt;标识枚举类型的元素&lt;/li&gt;
&lt;li&gt;在不能保证输入参数只读的语言里标识只读参数&lt;/li&gt;
&lt;li&gt;格式化命名以提高可读性&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽量不要混用上述方法，那样会使代码更难阅读。老老实实地坚持使用其中任意一种提高可读性的方法，你的代码质量一定会有所改善。&lt;/p&gt;
&lt;h3 id=&quot;%E4%B8%8E%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E7%9A%84%E6%8C%87%E5%AF%BC%E5%8E%9F%E5%88%99&quot; tabindex=&quot;-1&quot;&gt;与语言相关的命名规则的指导原则&lt;/h3&gt;
&lt;p&gt;应该遵循你所用语言的命名规则。对于大多数语言，你都可以找到描述其风格原则的参考书，下面给出C的指导原则。&lt;/p&gt;
&lt;h4 id=&quot;c%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99&quot; tabindex=&quot;-1&quot;&gt;C的命名规则&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;c和ch是字符变量&lt;/li&gt;
&lt;li&gt;i和j是整数下标&lt;/li&gt;
&lt;li&gt;n表示某物的数量&lt;/li&gt;
&lt;li&gt;p是指针&lt;/li&gt;
&lt;li&gt;s是字符串&lt;/li&gt;
&lt;li&gt;预处理宏全部大写，通常包括typedef&lt;/li&gt;
&lt;li&gt;变量名和子程序名全部小写&lt;/li&gt;
&lt;li&gt;下划线用作分隔符，如：letters_in_lowercase&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E6%A0%87%E5%87%86%E5%89%8D%E7%BC%80&quot; tabindex=&quot;-1&quot;&gt;标准前缀&lt;/h2&gt;
&lt;p&gt;对具有通用含义的前缀标准化，为数据命名提供了一种简洁、一致并且可读性好的方法。&lt;/p&gt;
&lt;p&gt;标准化的前缀由两部分组成：用户自定义类型（UDT）的缩写和语义前缀。&lt;/p&gt;
&lt;h3 id=&quot;%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E7%BC%A9%E5%86%99&quot; tabindex=&quot;-1&quot;&gt;用户自定义类型缩写&lt;/h3&gt;
&lt;p&gt;UDT缩写可以标识被命名对象或变量的数据类型。UDT缩写通常不会表示任何由编程语言所提供的预置数据类型。下面列出一份UDT示例。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;UDT缩写&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ch&lt;/td&gt;
&lt;td&gt;字符(Character)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;doc&lt;/td&gt;
&lt;td&gt;文档(Document)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pa&lt;/td&gt;
&lt;td&gt;段落(Paragraph)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;scr&lt;/td&gt;
&lt;td&gt;屏幕区域(Screen region)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sel&lt;/td&gt;
&lt;td&gt;选中范围(Selection)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wn&lt;/td&gt;
&lt;td&gt;窗体(Window)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以使用上表列出的UDT类型定义下面这样的数据声明：&lt;/p&gt;
&lt;p&gt;CH chCursorPosition;
SCR srcUserWorkSpace;
DOC docActive;
PA firstPaActiveDocument;
PA lastPaActiveDocument;
WN wnMain;&lt;/p&gt;
&lt;h3 id=&quot;%E8%AF%AD%E4%B9%89%E5%89%8D%E7%BC%80&quot; tabindex=&quot;-1&quot;&gt;语义前缀&lt;/h3&gt;
&lt;p&gt;语义前缀比UDT更进一步，它描述了变量或者对象是如何使用的。而且语义前缀不会根据项目的不同而不同，对于不同的项目均是标准的。下面列出一组标准的语义前缀。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;语义前缀&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;数量(count)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;first&lt;/td&gt;
&lt;td&gt;数组中需要处理的第一个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;g&lt;/td&gt;
&lt;td&gt;全局变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;数组的下标&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;last&lt;/td&gt;
&lt;td&gt;数组中需要处理的最后一个元素，与first对应&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lim&lt;/td&gt;
&lt;td&gt;数组中需要处理的元素的上限，通常，lim等于last+1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;类一级的变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;max&lt;/td&gt;
&lt;td&gt;数组或其他种类的列表中绝对的最后一个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;min&lt;/td&gt;
&lt;td&gt;数组或其他种类的列表中绝对的第一个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;指针(pointer)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;%E6%A0%87%E5%87%86%E5%89%8D%E7%BC%80%E7%9A%84%E4%BC%98%E5%8A%A3&quot; tabindex=&quot;-1&quot;&gt;标准前缀的优劣&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;能更为精确地描述一些含义比较模糊的名字&lt;/li&gt;
&lt;li&gt;使名字变得更加紧凑&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;缺陷：程序员在使用前缀的同时忽略给变量其有意义的名字。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E5%88%9B%E5%BB%BA%E5%85%B7%E5%A4%87%E5%8F%AF%E8%AF%BB%E6%80%A7%E7%9A%84%E7%9F%AD%E5%90%8D%E5%AD%97&quot; tabindex=&quot;-1&quot;&gt;创建具备可读性的短名字&lt;/h2&gt;
&lt;p&gt;如果环境真的要求你创建简短的名字，请注意有些缩短名字的方法要好于其他的方法。&lt;/p&gt;
&lt;h3 id=&quot;%E7%BC%A9%E5%86%99%E7%9A%84%E4%B8%80%E8%88%AC%E6%8C%87%E5%AF%BC%E5%8E%9F%E5%88%99&quot; tabindex=&quot;-1&quot;&gt;缩写的一般指导原则&lt;/h3&gt;
&lt;p&gt;下面列出几项用于创建缩写的指导原则。其中一些原则彼此冲突，所以不要试图同时应用所有的原则。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;使用标准的缩写&lt;/li&gt;
&lt;li&gt;去掉所有非前置元音（computer =&amp;gt; cmptr, screen =&amp;gt; scrn, apple =&amp;gt; appl, interger =&amp;gt; intgr）&lt;/li&gt;
&lt;li&gt;去掉虚词and，or，the等&lt;/li&gt;
&lt;li&gt;使用每个单词的第一个或前几个字母&lt;/li&gt;
&lt;li&gt;统一在每个单词的第一、第二或者第三个字母后截断&lt;/li&gt;
&lt;li&gt;保留每个单词的第一个和最后一个字母&lt;/li&gt;
&lt;li&gt;使用名字中的每一个重要单词，最多不超过三个&lt;/li&gt;
&lt;li&gt;去掉无用的后缀--ing，ed等&lt;/li&gt;
&lt;li&gt;保留每个音节中最引人注意的发音&lt;/li&gt;
&lt;li&gt;确保不要改变变量的含义&lt;/li&gt;
&lt;li&gt;反复使用上述技术，直到把每个变量名的长度缩减到了8-20个字符。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;%E8%AF%AD%E9%9F%B3%E7%BC%A9%E5%86%99&quot; tabindex=&quot;-1&quot;&gt;语音缩写&lt;/h3&gt;
&lt;p&gt;有些人倡导基于单词的发音而不是拼写来创建缩写，比如skating =&amp;gt; sk8ing, before =&amp;gt; b4...但是不提倡这么做。&lt;/p&gt;
&lt;h3 id=&quot;%E6%9C%89%E5%85%B3%E7%BC%A9%E5%86%99%E7%9A%84%E8%AF%84%E8%AE%BA&quot; tabindex=&quot;-1&quot;&gt;有关缩写的评论&lt;/h3&gt;
&lt;p&gt;下面是一些能够用来避免犯错的规则&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;不要用从每个单词中删除一个字符的方式来缩写，要么删除不止一个字符，要么就把单词拼写完整&lt;/li&gt;
&lt;li&gt;缩写要一致，比如：要么全部使用Num，要么全用No，不要两个都用&lt;/li&gt;
&lt;li&gt;创建你能读出来到的名字，比如：用xPos而不用xPstn。可以借助电话来测试--如果你无法在电话中向他人读出你的代码，就请重新给变量起一个更清晰的名字吧&lt;/li&gt;
&lt;li&gt;避免使用容易看错或者读错的字符组合，比如ENDB和BEND，为了表示B的结尾，可以用一种好的分隔技术来命名：b_end/BEnd&lt;/li&gt;
&lt;li&gt;使用辞典来解决命名冲突，使用近义词来解决命名冲突&lt;/li&gt;
&lt;li&gt;在代码里用缩写对照表解释极短的名字的含义&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E5%BA%94%E8%AF%A5%E9%81%BF%E5%85%8D%E7%9A%84%E5%90%8D%E5%AD%97&quot; tabindex=&quot;-1&quot;&gt;应该避免的名字&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;避免使用令人误解的名字或缩写，比如将&amp;quot;Fig and Almond Season&amp;quot;缩写为FALSE&lt;/li&gt;
&lt;li&gt;避免使用具有相似含义的名字&lt;/li&gt;
&lt;li&gt;避免使用具有不同含义但却有相似名字的变量&lt;/li&gt;
&lt;li&gt;避免使用发音相近的名字&lt;/li&gt;
&lt;li&gt;避免在名字中使用数字&lt;/li&gt;
&lt;li&gt;避免在名字中拼错单词&lt;/li&gt;
&lt;li&gt;避免使用英语中常常拼错的单词&lt;/li&gt;
&lt;li&gt;不要仅靠大小写来区分变量名&lt;/li&gt;
&lt;li&gt;避免使用多种自然语言&lt;/li&gt;
&lt;li&gt;避免使用标准类型、变量和子程序的名字&lt;/li&gt;
&lt;li&gt;不要使用与变量含义完全无关的名字&lt;/li&gt;
&lt;li&gt;避免在名字中包含易混淆的字符，比如1(数字1)和l(字母l),0(数字0)和O(字母O)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;好的变量名是提高程序可读性的一项关键要素。代码阅读的次数远远多于编写的次数，确保代码中所取的名字更侧重于阅读方便而不是编写方便。选择一种规则，并坚持遵循该规则。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点下推荐吧，谢谢^_^&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>[PHP内核探索]PHP中的哈希表</title>
    <link href="https://hoohack.me/blog/2016/2016-07-06-php-internal-hashtable/"/>
    <updated>2016-07-06T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-07-06-php-internal-hashtable/</id>
    <content type="html">&lt;p&gt;在PHP内核中，其中一个很重要的数据结构就是HashTable。我们常用的数组，在内核中就是用HashTable来实现。那么，PHP的HashTable是怎么实现的呢？最近在看HashTable的数据结构，但是算法书籍里面没有具体的实现算法，刚好最近也在阅读PHP的源码，于是参考PHP的HashTable的实现，自己实现了一个简易版的HashTable，总结了一些心得，下面给大家分享一下。&lt;/p&gt;
&lt;p&gt;笔者github上有一个简易版的HashTable的实现：&lt;a href=&quot;https://github.com/hoohack/KeepCoding/tree/master/DataStructure/Hash&quot;&gt;HashTable实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外，我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/read-php-src/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/read-php-src/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
&lt;h1 id=&quot;hashtable%E7%9A%84%E4%BB%8B%E7%BB%8D&quot; tabindex=&quot;-1&quot;&gt;HashTable的介绍&lt;/h1&gt;
&lt;p&gt;哈希表是实现字典操作的一种有效数据结构。&lt;/p&gt;
&lt;h2 id=&quot;%E5%AE%9A%E4%B9%89&quot; tabindex=&quot;-1&quot;&gt;定义&lt;/h2&gt;
&lt;p&gt;简单地说，HashTable(哈希表)就是一种键值对的数据结构。支持插入，查找，删除等操作。在一些合理的假设下，在哈希表中的所有操作的时间复杂度是O(1)(对相关证明感兴趣的可以自行查阅)。&lt;/p&gt;
&lt;h2 id=&quot;%E5%AE%9E%E7%8E%B0%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%85%B3%E9%94%AE&quot; tabindex=&quot;-1&quot;&gt;实现哈希表的关键&lt;/h2&gt;
&lt;p&gt;在哈希表中，不是使用关键字做下标，而是通过哈希函数计算出key的哈希值作为下标，然后查找/删除时再计算出key的哈希值，从而快速定位元素保存的位置。&lt;/p&gt;
&lt;p&gt;在一个哈希表中，不同的关键字可能会计算得到相同的哈希值，这叫做“哈希冲突”，就是处理两个或多个键的哈希值相同的情况。解决哈希冲突的方法有很多，开放寻址法，拉链法等等。&lt;/p&gt;
&lt;p&gt;因此，实现一个好的哈希表的关键就是一个好的哈希函数和处理哈希冲突的方法。&lt;/p&gt;
&lt;h3 id=&quot;hash%E5%87%BD%E6%95%B0&quot; tabindex=&quot;-1&quot;&gt;Hash函数&lt;/h3&gt;
&lt;p&gt;判断一个哈希算法的好坏有以下四个定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;一致性，等价的键必然产生相等的哈希值；&lt;/li&gt;
&lt;li&gt;高效性，计算简便；&lt;/li&gt;
&lt;li&gt;均匀性，均匀地对所有的键进行哈希。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;哈希函数建立了关键值与哈希值的对应关系，即：h = hash_func(key)。对应关系见下图：
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/hash-exam.png&quot; alt=&quot;hash-exam&quot; /&gt;&lt;/p&gt;
&lt;p&gt;设计一个完美的哈希函数就交由专家去做吧，我们只管用已有的较成熟的哈希函数就好了。PHP内核使用的哈希函数是time33函数，又叫DJBX33A，其实现如下：&lt;/p&gt;
&lt;p&gt;static inline ulong zend_inline_hash_func(const char *arKey, uint nKeyLength)
{
register ulong hash = 5381;&lt;/p&gt;
&lt;p&gt;/* variant with the hash unrolled eight times */
for (; nKeyLength &amp;gt;= 8; nKeyLength -= 8) {
hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++;
hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++;
hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++;
hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++;
hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++;
hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++;
hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++;
hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++;
}&lt;/p&gt;
&lt;p&gt;switch (nKeyLength) {
case 7: hash = ((hash &amp;lt;&amp;lt; 5) + hash) + &lt;em&gt;arKey++; /&lt;/em&gt; fallthrough... */
case 6: hash = ((hash &amp;lt;&amp;lt; 5) + hash) + &lt;em&gt;arKey++; /&lt;/em&gt; fallthrough... */
case 5: hash = ((hash &amp;lt;&amp;lt; 5) + hash) + &lt;em&gt;arKey++; /&lt;/em&gt; fallthrough... */
case 4: hash = ((hash &amp;lt;&amp;lt; 5) + hash) + &lt;em&gt;arKey++; /&lt;/em&gt; fallthrough... */
case 3: hash = ((hash &amp;lt;&amp;lt; 5) + hash) + &lt;em&gt;arKey++; /&lt;/em&gt; fallthrough... */
case 2: hash = ((hash &amp;lt;&amp;lt; 5) + hash) + &lt;em&gt;arKey++; /&lt;/em&gt; fallthrough... */
case 1: hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++; break;
case 0: break;
EMPTY_SWITCH_DEFAULT_CASE()
}
return hash;
}&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：函数使用了一个8次循环+switch来实现，是对for循环的优化，减少循环的运行次数，然后在switch里面执行剩下的没有遍历到的元素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;%E6%8B%89%E9%93%BE%E6%B3%95&quot; tabindex=&quot;-1&quot;&gt;拉链法&lt;/h3&gt;
&lt;p&gt;将所有具有相同哈希值的元素都保存在一条链表中的方法叫拉链法。查找的时候通过先计算key对应的哈希值，然后根据哈希值找到对应的链表，最后沿着链表顺序查找相应的值。
具体保存后的结构图如下：
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/hashtable-exam.png&quot; alt=&quot;hashtable-exam&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;php%E7%9A%84hashtable%E7%BB%93%E6%9E%84&quot; tabindex=&quot;-1&quot;&gt;PHP的HashTable结构&lt;/h1&gt;
&lt;p&gt;简单地介绍了哈希表的数据结构之后，继续看看PHP中是如何实现哈希表的。&lt;/p&gt;
&lt;p&gt;(图片源自网络，侵权即删)&lt;/p&gt;
&lt;h2 id=&quot;php%E5%86%85%E6%A0%B8hashtable%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A&quot; tabindex=&quot;-1&quot;&gt;PHP内核hashtable的定义：&lt;/h2&gt;
&lt;p&gt;typedef struct _hashtable {
uint nTableSize;
uint nTableMask;
uint nNumOfElements;
ulong nNextFreeElement;
Bucket *pInternalPointer;
Bucket *pListHead;
Bucket *pListTail;
Bucket **arBuckets;
dtor_func_t pDestructor;
zend_bool persistent;
unsigned char nApplyCount;
zend_bool bApplyProtection;
#if ZEND_DEBUG
int inconsistent;
#endif
} HashTable;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;nTableSize，HashTable的大小，以2的倍数增长&lt;/li&gt;
&lt;li&gt;nTableMask，用在与哈希值做与运算获得该哈希值的索引取值，arBuckets初始化后永远是nTableSize-1&lt;/li&gt;
&lt;li&gt;nNumOfElements，HashTable当前拥有的元素个数，count函数直接返回这个值&lt;/li&gt;
&lt;li&gt;nNextFreeElement，表示数字键值数组中下一个数字索引的位置&lt;/li&gt;
&lt;li&gt;pInternalPointer，内部指针，指向当前成员，用于遍历元素&lt;/li&gt;
&lt;li&gt;pListHead，指向HashTable的第一个元素，也是数组的第一个元素&lt;/li&gt;
&lt;li&gt;pListTail，指向HashTable的最后一个元素，也是数组的最后一个元素。与上面的指针结合，在遍历数组时非常方便，比如reset和endAPI&lt;/li&gt;
&lt;li&gt;arBuckets，包含bucket组成的双向链表的数组，索引用key的哈希值和nTableMask做与运算生成&lt;/li&gt;
&lt;li&gt;pDestructor，删除哈希表中的元素使用的析构函数&lt;/li&gt;
&lt;li&gt;persistent，标识内存分配函数，如果是TRUE，则使用操作系统本身的内存分配函数，否则使用PHP的内存分配函数&lt;/li&gt;
&lt;li&gt;nApplyCount，保存当前bucket被递归访问的次数，防止多次递归&lt;/li&gt;
&lt;li&gt;bApplyProtection，标识哈希表是否要使用递归保护，默认是1，要使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;举一个哈希与mask结合的例子：&lt;/p&gt;
&lt;p&gt;例如，”foo”真正的哈希值（使用DJBX33A哈希函数）是193491849。如果我们现在有64容量的哈希表，我们明显不能使用它作为数组的下标。取而代之的是通过应用哈希表的mask，然后只取哈希表的低位。&lt;/p&gt;
&lt;p&gt;hash           |        193491849  |     0b1011100010000111001110001001
&amp;amp; mask         | &amp;amp;             63  | &amp;amp;   0b0000000000000000000000111111
----------------------------------------------------------------------
= index        | = 9               | =   0b0000000000000000000000001001&lt;/p&gt;
&lt;p&gt;因此，在哈希表中，foo是保存在arBuckets中下标为9的bucket向量中。&lt;/p&gt;
&lt;h3 id=&quot;bucket%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89&quot; tabindex=&quot;-1&quot;&gt;bucket结构体的定义&lt;/h3&gt;
&lt;p&gt;typedef struct bucket {
ulong h;
uint nKeyLength;
void *pData;
void *pDataPtr;
struct bucket *pListNext;
struct bucket *pListLast;
struct bucket *pNext;
struct bucket *pLast;
const char *arKey;
} Bucket;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;h，哈希值（或数字键值的key&lt;/li&gt;
&lt;li&gt;nKeyLength，key的长度&lt;/li&gt;
&lt;li&gt;pData，指向数据的指针&lt;/li&gt;
&lt;li&gt;pDataPtr，指针数据&lt;/li&gt;
&lt;li&gt;pListNext，指向HashTable中的arBuckets链表中的下一个元素&lt;/li&gt;
&lt;li&gt;pListLast，指向HashTable中的arBuckets链表中的上一个元素&lt;/li&gt;
&lt;li&gt;pNext，指向具有相同hash值的bucket链表中的下一个元素&lt;/li&gt;
&lt;li&gt;pLast，指向具有相同hash值的bucket链表中的上一个元素&lt;/li&gt;
&lt;li&gt;arKey，key的名称&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;PHP中的HashTable是采用了向量加双向链表的实现方式，向量在arBuckets变量保存，向量包含多个bucket的指针，每个指针指向由多个bucket组成的双向链表，新元素的加入使用前插法，即新元素总是在bucket的第一个位置。由上面可以看到，PHP的哈希表实现相当复杂。这是它使用超灵活的数组类型要付出的代价。&lt;/p&gt;
&lt;p&gt;一个PHP中的HashTable的示例图如下所示：
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/php-hashtable-exam.png&quot; alt=&quot;php-hash-table-exam&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;hashtable%E7%9B%B8%E5%85%B3api&quot; tabindex=&quot;-1&quot;&gt;HashTable相关API&lt;/h1&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;zend_hash_init&lt;/li&gt;
&lt;li&gt;zend_hash_add_or_update&lt;/li&gt;
&lt;li&gt;zend_hash_find&lt;/li&gt;
&lt;li&gt;zend_hash_del_key_or_index&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;zend_hash_init&quot; tabindex=&quot;-1&quot;&gt;zend_hash_init&lt;/h2&gt;
&lt;p&gt;函数执行步骤&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;设置哈希表大小&lt;/li&gt;
&lt;li&gt;设置结构体其他成员变量的初始值 (包括释放内存用的析构函数pDescructor)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;详细代码注解点击：&lt;a href=&quot;https://github.com/hoohack/read-php-src/blob/master/Zend/zend_hash.c#L175&quot;&gt;zend_hash_init源码&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;1、pHashFunction在此处并没有用到，php的哈希函数使用的是内部的&lt;a href=&quot;https://github.com/hoohack/read-php-src/blob/master/Zend/zend_hash.h#L261&quot;&gt;zend_inline_hash_func&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、zend_hash_init执行之后并没有真正地为arBuckets分配内存和计算出nTableMask的大小，真正分配内存和计算nTableMask是在插入元素时进行CHECK_INIT检查初始化时进行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;zend_hash_add_or_update&quot; tabindex=&quot;-1&quot;&gt;zend_hash_add_or_update&lt;/h2&gt;
&lt;p&gt;函数执行步骤&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;检查键的长度&lt;/li&gt;
&lt;li&gt;检查初始化&lt;/li&gt;
&lt;li&gt;计算哈希值和下标&lt;/li&gt;
&lt;li&gt;遍历哈希值所在的bucket，如果找到相同的key且值需要更新，则更新数据，否则继续指向bucket的下一个元素，直到指向bucket的最后一个位置&lt;/li&gt;
&lt;li&gt;为新加入的元素分配bucket，设置新的bucket的属性值，然后添加到哈希表中&lt;/li&gt;
&lt;li&gt;如果哈希表空间满了，则重新调整哈希表的大小&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE&quot; tabindex=&quot;-1&quot;&gt;函数执行流程图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/zend_hash_add_or_update.png&quot; alt=&quot;zend_hash_add_or_update&quot; /&gt;&lt;/p&gt;
&lt;p&gt;CONNECT_TO_BUCKET_DLLIST是将新元素添加到具有相同hash值的bucket链表。&lt;/p&gt;
&lt;p&gt;CONNECT_TO_GLOBAL_DLLIST是将新元素添加到HashTable的双向链表。&lt;/p&gt;
&lt;p&gt;详细代码和注解请点击：&lt;a href=&quot;https://github.com/hoohack/read-php-src/blob/master/Zend/zend_hash.c#L226&quot;&gt;zend_hash_add_or_update代码注解&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;zend_hash_find&quot; tabindex=&quot;-1&quot;&gt;zend_hash_find&lt;/h2&gt;
&lt;p&gt;函数执行步骤&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;计算哈希值和下标&lt;/li&gt;
&lt;li&gt;遍历哈希值所在的bucket，如果找到key所在的bucket，则返回值，否则，指向下一个bucket，直到指向bucket链表中的最后一个位置&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;详细代码和注解请点击：&lt;a href=&quot;https://github.com/hoohack/read-php-src/blob/master/Zend/zend_hash.c#L1033&quot;&gt;zend_hash_find代码注解&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;zend_hash_del_key_or_index&quot; tabindex=&quot;-1&quot;&gt;zend_hash_del_key_or_index&lt;/h2&gt;
&lt;p&gt;函数执行步骤&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;计算key的哈希值和下标&lt;/li&gt;
&lt;li&gt;遍历哈希值所在的bucket，如果找到key所在的bucket，则进行第三步，否则，指向下一个bucket，直到指向bucket链表中的最后一个位置&lt;/li&gt;
&lt;li&gt;如果要删除的是第一个元素，直接将arBucket[nIndex]指向第二个元素；其余的操作是将当前指针的last的next执行当前的next&lt;/li&gt;
&lt;li&gt;调整相关指针&lt;/li&gt;
&lt;li&gt;释放数据内存和bucket结构体内存&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;详细代码和注解请点击：&lt;a href=&quot;https://github.com/hoohack/read-php-src/blob/master/Zend/zend_hash.c#L578&quot;&gt;zend_hash_del_key_or_index代码注解&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&quot;%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90&quot; tabindex=&quot;-1&quot;&gt;性能分析&lt;/h1&gt;
&lt;p&gt;PHP的哈希表的优点：PHP的HashTable为数组的操作提供了很大的方便，无论是数组的创建和新增元素或删除元素等操作，哈希表都提供了很好的性能，但其不足在数据量大的时候比较明显，从时间复杂度和空间复杂度看看其不足。&lt;/p&gt;
&lt;p&gt;不足如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;保存数据的结构体zval需要单独分配内存，需要管理这个额外的内存，每个zval占用了16bytes的内存；&lt;/li&gt;
&lt;li&gt;在新增bucket时，bucket也是额外分配，也需要16bytes的内存；&lt;/li&gt;
&lt;li&gt;为了能进行顺序遍历，使用双向链表连接整个HashTable，多出了很多的指针，每个指针也要16bytes的内存；&lt;/li&gt;
&lt;li&gt;在遍历时，如果元素位于bucket链表的尾部，也需要遍历完整个bucket链表才能找到所要查找的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;PHP的HashTable的不足主要是其双向链表多出的指针及zval和bucket需要额外分配内存，因此导致占用了很多内存空间及查找时多出了不少时间的消耗。&lt;/p&gt;
&lt;h1 id=&quot;%E5%90%8E%E7%BB%AD&quot; tabindex=&quot;-1&quot;&gt;后续&lt;/h1&gt;
&lt;p&gt;上面提到的不足，在PHP7中都很好地解决了，PHP7对内核中的数据结构做了一个大改造，使得PHP的效率高了很多，因此，推荐PHP开发者都将开发和部署版本更新吧。看看下面这段PHP代码：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$size = pow(2, 16);&lt;/p&gt;
&lt;p&gt;$startTime = microtime(true);
$array = array();
for ($key = 0, $maxKey = ($size - 1) * $size; $key &amp;lt;= $maxKey; $key += $size) {
$array[$key] = 0;
}
$endTime = microtime(true);
echo &#39;插入 &#39;, $size, &#39; 个恶意的元素需要 &#39;, $endTime - $startTime, &#39; 秒&#39;, &amp;quot;&#92;n&amp;quot;;&lt;/p&gt;
&lt;p&gt;$startTime = microtime(true);
$array = array();
for ($key = 0, $maxKey = $size - 1; $key &amp;lt;= $maxKey; ++$key) {
$array[$key] = 0;
}
$endTime = microtime(true);
echo &#39;插入 &#39;, $size, &#39; 个普通元素需要 &#39;, $endTime - $startTime, &#39; 秒&#39;, &amp;quot;&#92;n&amp;quot;;&lt;/p&gt;
&lt;p&gt;上面这个demo是有多个hash冲突时和无冲突时的时间消耗比较。笔者在PHP5.4下运行这段代码，结果如下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;插入 65536 个恶意的元素需要 43.72204709053 秒&lt;/p&gt;
&lt;p&gt;插入 65536 个普通元素需要 0.009843111038208 秒&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而在PHP7上运行的结果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;插入 65536 个恶意的元素需要 4.4028408527374 秒&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;插入 65536 个普通元素需要 0.0018510818481445 秒&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可见不论在有冲突和无冲突的数组操作，PHP7的性能都提升了不少，当然，有冲突的性能提升更为明显。至于为什么PHP7的性能提高了这么多，值得继续深究。&lt;/p&gt;
&lt;p&gt;最后，笔者github上有一个简易版的HashTable的实现：&lt;a href=&quot;https://github.com/hoohack/KeepCoding/tree/master/DataStructure/Hash&quot;&gt;HashTable实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外，我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/read-php-src/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/read-php-src/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点下推荐吧，谢谢^_^&lt;/p&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.laruence.com/2011/12/30/2435.html&quot;&gt;PHP数组的Hash冲突实例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://nikic.github.io/2012/03/28/Understanding-PHPs-internal-array-implementation.html&quot;&gt;Understanding PHP&#39;s internal array implementation (PHP&#39;s Source Code for PHP Developers - Part 4) &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://nikic.github.io/2014/12/22/PHPs-new-hashtable-implementation.html&quot;&gt;PHP&#39;s new hashtable implementation&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>[PHP源码阅读]array_slice和array_splice函数</title>
    <link href="https://hoohack.me/blog/2016/2016-07-05-php-source-code-array-slice-array-splice/"/>
    <updated>2016-07-05T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-07-05-php-source-code-array-slice-array-splice/</id>
    <content type="html">&lt;p&gt;array_slice和array_splice函数是用在取出数组的一段切片，array_splice还有用新的切片替换原删除切片位置的功能。类似javascript中的Array.prototype.splice和Array.prototype.slice方法。&lt;/p&gt;
&lt;p&gt;我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/hoohack/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/hoohack/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
&lt;h1 id=&quot;array_slice&quot; tabindex=&quot;-1&quot;&gt;array_slice&lt;/h1&gt;
&lt;p&gt;array array_slice ( array $array , int $offset [, int $length = NULL [, bool $preserve_keys = false ]] )&lt;/p&gt;
&lt;p&gt;返回数组中指定下标offset和长度length的子数组切片。&lt;/p&gt;
&lt;h2 id=&quot;%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E&quot; tabindex=&quot;-1&quot;&gt;参数说明&lt;/h2&gt;
&lt;p&gt;设第一个参数数组的长度为num_in。&lt;/p&gt;
&lt;h3 id=&quot;offset&quot; tabindex=&quot;-1&quot;&gt;offset&lt;/h3&gt;
&lt;p&gt;如果offset是正数且小于length，则返回数组会从offset开始；如果offset大于length，则不操作，直接返回。如果offset是负数，则offset = num_in+offset，如果num_in+offset == 0，则将offset设为0。&lt;/p&gt;
&lt;h3 id=&quot;length&quot; tabindex=&quot;-1&quot;&gt;length&lt;/h3&gt;
&lt;p&gt;如果length小于0，那么会将length转为num_in - offset + length；否则，如果offset+length &amp;gt; array_count，则length = num_in - offset。如果处理后length还是小于0，则直接返回。&lt;/p&gt;
&lt;h3 id=&quot;preserve_keys&quot; tabindex=&quot;-1&quot;&gt;preserve_keys&lt;/h3&gt;
&lt;p&gt;默认是false，默认不保留数字键值原顺序，设为true的话会保留数组原来的数字键值顺序。&lt;/p&gt;
&lt;h2 id=&quot;%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B&quot; tabindex=&quot;-1&quot;&gt;使用实例&lt;/h2&gt;
&lt;p&gt;&amp;lt;?php
$input = array(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;);&lt;/p&gt;
&lt;p&gt;$output = array_slice($input, 2);      // returns &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, and &amp;quot;e&amp;quot;
$output = array_slice($input, -2, 1);  // returns &amp;quot;d&amp;quot;
$output = array_slice($input, 0, 3);   // returns &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, and &amp;quot;c&amp;quot;&lt;/p&gt;
&lt;p&gt;print_r(array_slice($input, 2, -1)); // array(0 =&amp;gt; &#39;c&#39;, 1 =&amp;gt; &#39;d&#39;);
print_r(array_slice($input, 2, -1, true)); // array(2 =&amp;gt; &#39;c&#39;, 1 =&amp;gt; &#39;d&#39;);&lt;/p&gt;
&lt;h2 id=&quot;%E8%BF%90%E8%A1%8C%E6%AD%A5%E9%AA%A4&quot; tabindex=&quot;-1&quot;&gt;运行步骤&lt;/h2&gt;
&lt;p&gt;处理参数：offset、length&lt;/p&gt;
&lt;p&gt;移动指针到offset指向的位置&lt;/p&gt;
&lt;p&gt;从offset开始，拷贝length个元素到返回数组&lt;/p&gt;
&lt;p&gt;运行流程图如下
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/array_slice_and_array_splice.png&quot; alt=&quot;array_splice&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;array_splice&quot; tabindex=&quot;-1&quot;&gt;array_splice&lt;/h1&gt;
&lt;p&gt;array array_splice ( array &amp;amp;$input , int $offset [, int $length = 0 [, mixed $replacement = array() ]] )&lt;/p&gt;
&lt;p&gt;删除input中从offset开始length个元素，如果有replacement参数的话用replacement数组替换删除掉的元素。&lt;/p&gt;
&lt;h2 id=&quot;%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-1&quot; tabindex=&quot;-1&quot;&gt;参数说明&lt;/h2&gt;
&lt;p&gt;array_splice函数中的offset和length参数跟array_slice函数中的用法一样。&lt;/p&gt;
&lt;h3 id=&quot;replacement&quot; tabindex=&quot;-1&quot;&gt;replacement&lt;/h3&gt;
&lt;p&gt;如果这个参数设置了，那么函数将使用replacement数组来替换。&lt;/p&gt;
&lt;p&gt;如果offset和length指定了没有任何元素需要移除，那么replacement会被插入到offset的位置。&lt;/p&gt;
&lt;p&gt;如果replacement只有一个元素，可以不用array()去包着它。&lt;/p&gt;
&lt;h2 id=&quot;%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B&quot; tabindex=&quot;-1&quot;&gt;使用示例&lt;/h2&gt;
&lt;p&gt;&amp;lt;?php
$input = array(&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;yellow&amp;quot;);
array_splice($input, 2);
// $input变为 array(&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;)&lt;/p&gt;
&lt;p&gt;$input = array(&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;yellow&amp;quot;);
array_splice($input, 1, -1);
// $input变为 array(&amp;quot;red&amp;quot;, &amp;quot;yellow&amp;quot;)&lt;/p&gt;
&lt;p&gt;$input = array(&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;yellow&amp;quot;);
array_splice($input, 1, count($input), &amp;quot;orange&amp;quot;);
// $input变为 array(&amp;quot;red&amp;quot;, &amp;quot;orange&amp;quot;)&lt;/p&gt;
&lt;p&gt;$input = array(&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;yellow&amp;quot;);
array_splice($input, -1, 1, array(&amp;quot;black&amp;quot;, &amp;quot;maroon&amp;quot;));
// $input为 array(&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;,
//          &amp;quot;blue&amp;quot;, &amp;quot;black&amp;quot;, &amp;quot;maroon&amp;quot;)&lt;/p&gt;
&lt;p&gt;$input = array(&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;yellow&amp;quot;);
array_splice($input, 3, 0, &amp;quot;purple&amp;quot;);
// $input为 array(&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;,
//          &amp;quot;blue&amp;quot;, &amp;quot;purple&amp;quot;, &amp;quot;yellow&amp;quot;);&lt;/p&gt;
&lt;h1 id=&quot;%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB&quot; tabindex=&quot;-1&quot;&gt;源码解读&lt;/h1&gt;
&lt;p&gt;在array_splice中，有这么一段代码：&lt;/p&gt;
&lt;p&gt;if (return_value_used) { // 如果有用到函数返回值则创建返回数组，否则不创建返回数组
int size = length;&lt;/p&gt;
&lt;p&gt;/* Clamp the offset.. */
if (offset &amp;gt; num_in) {
offset = num_in;
} else if (offset &amp;lt; 0 &amp;amp;&amp;amp; (offset = (num_in + offset)) &amp;lt; 0) {
offset = 0;
}&lt;/p&gt;
&lt;p&gt;/* ..and the length */
if (length &amp;lt; 0) {
size = num_in - offset + length;
} else if (((unsigned long) offset + (unsigned long) length) &amp;gt; (unsigned) num_in)         {
size = num_in - offset;
}&lt;/p&gt;
&lt;p&gt;/* Initialize return value */
array_init_size(return_value, size &amp;gt; 0 ? size : 0);
rem_hash = &amp;amp;Z_ARRVAL_P(return_value);
}&lt;/p&gt;
&lt;p&gt;array_splice函数返回的是被删除的切片。这段代码的意思是，如果array_splice需要返回值，那么才创建返回数组，否则不创建，以免浪费空间。这也是一个编程小技巧，仅当需要的时候才返回。比如在函数中使用$result = array_splice(...)，那么return_value_used就是true。&lt;/p&gt;
&lt;h1 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h1&gt;
&lt;p&gt;到此本文结束，在平时编程中，应当像这两个函数实现时的做法一样，将最特殊的情况先处理掉，然后再继续，以免做了多余的判断；有需要保存新变量的时候才申请新的空间，不然会造成浪费。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点下推荐吧，谢谢^_^&lt;/p&gt;
&lt;p&gt;最后再安利一下，我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/hoohack/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/hoohack/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
&lt;p&gt;更多源码文章，欢迎访问个人主页继续查看：&lt;a href=&quot;https://www.hoohack.me/&quot;&gt;hoohack&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>红黑树探索笔记</title>
    <link href="https://hoohack.me/blog/2016/2016-06-27-red-black-study-note/"/>
    <updated>2016-06-27T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-06-27-red-black-study-note/</id>
    <content type="html">&lt;p&gt;最近花了些时间重拾数据结构的基础知识，先尝试了红黑树，花了大半个月的时间研究其原理和实现，下面是学习到的知识和一些笔记的分享。望各位多多指教。本次代码的实现请点击：&lt;a href=&quot;https://github.com/hoohack/KeepCoding/tree/master/DataStructure/RBTree&quot;&gt;红黑树实现代码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E7%BA%A2%E9%BB%91%E6%A0%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&quot; tabindex=&quot;-1&quot;&gt;红黑树基础知识&lt;/h2&gt;
&lt;h3 id=&quot;%E5%AE%9A%E4%B9%89&quot; tabindex=&quot;-1&quot;&gt;定义&lt;/h3&gt;
&lt;p&gt;红黑树是带有 color 属性的二叉搜索树，color 的值为红色或黑色，因此叫做红黑树。&lt;/p&gt;
&lt;p&gt;对红黑树的每个结点的结构体定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct RBNode {
     int color;
     void *key;
     void *value;
     struct RBNode *left;
     struct RBNode *right;
     struct RBNode *parent;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设根结点的 parent 指针指向 NULL，新结点的左右孩子 left 和 right 指向 NULL。叶子结点是 NULL。&lt;/p&gt;
&lt;p&gt;定义判断红黑树颜色的宏为&lt;/p&gt;
&lt;p&gt;#define ISRED(x) ((x) != NULL &amp;amp;&amp;amp; (x)-&amp;gt;color == RED)&lt;/p&gt;
&lt;p&gt;因此，叶子结点 NULL 的颜色为非红色，在红黑树中，它就是黑色，包括黑色的叶子结点。&lt;/p&gt;
&lt;p&gt;黑高的定义，从某个结点 x 触发（不含该结点）到达一个叶结点的任意一条简单路径上的黑色结点个数称为该结点的黑高（black-height），记作 bh(x)。&lt;/p&gt;
&lt;h3 id=&quot;%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8&quot; tabindex=&quot;-1&quot;&gt;红黑树的性质&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;每个节点不是红色就是黑色；&lt;/li&gt;
&lt;li&gt;根节点是黑色；&lt;/li&gt;
&lt;li&gt;每个叶子节点是黑色；&lt;/li&gt;
&lt;li&gt;如果节点是红色，那么它的两个孩子节点都是黑色的；&lt;/li&gt;
&lt;li&gt;对每个节点来说，从节点到叶子节点的路径包含相同数目的黑色节点。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是一个红黑树的例子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/red-black-tree.png&quot; alt=&quot;red-black-tree-demo&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%97%8B%E8%BD%AC&quot; tabindex=&quot;-1&quot;&gt;红黑树的旋转&lt;/h3&gt;
&lt;p&gt;旋转操作在树的数据结构里面很经常出现，比如 AVL 树，红黑树等等。很多人都了解旋转的操作是怎么进行的（HOW），在网上能找到很多资料描述旋转的步骤，但是却没有人告诉我为什么要进行旋转（WHY）？为什么要这样旋转？通过与朋友交流，对于红黑树来说，之所以要旋转是因为左右子树的高度不平衡，即左子树比右子树高或者右子树比左子树高。那么，以左旋为例，通过左旋转，就可以将左子树的黑高 +1，同时右子树的黑高 -1，从而恢复左右子树黑高平衡。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/rotate.png&quot; alt=&quot;rotate-demo&quot; /&gt;&lt;/p&gt;
&lt;p&gt;以右旋为例，α 和 β 为 x 的左右孩子，γ 为 y 的右孩子，因为 y 的左子树比右子树高度多一，因此以 y 为根的子树左右高度不平衡，那么以 y-x 为轴左旋使其左右高度平衡，左旋之后 y 和 β 同时成为 x 的右孩子，然而因为要旋转的是 x 和 y 结点，因此就让 β 成为 y 的左孩子即可。&lt;/p&gt;
&lt;p&gt;旋转的算法复杂度：从图示可知，旋转的操作只是做了修改指针的操作，因此算法复杂度是 O(1)。&lt;/p&gt;
&lt;h3 id=&quot;%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90&quot; tabindex=&quot;-1&quot;&gt;红黑树的算法复杂度分析&lt;/h3&gt;
&lt;p&gt;红黑树的所有操作的算法复杂度都是 O(lgn)。这是因为红黑树的最大高度是 2lg(n+1)。&lt;/p&gt;
&lt;p&gt;证明如下：&lt;/p&gt;
&lt;p&gt;设每个路径的黑色节点的数量为 bh(x)`，要证明红黑树的最大高度是 2lg(n+1)，首先证明任何子树包含 2^bh(x) - 1 个内部节点。&lt;/p&gt;
&lt;p&gt;下面使用数学归纳法证明。&lt;/p&gt;
&lt;p&gt;当 bh(x) 等于 0 时，即有 0 个节点，那么子树包含 2^0 - 1 = 0 个内部节点，得证。&lt;/p&gt;
&lt;p&gt;对于其他节点，其黑高为 bh(x) 或 bh(x) - 1，当 x 是红节点时，黑高为 bh(x)，否则，为 bh(x) - 1。对于下一个节点，因为每个孩子节点都比父节点的高度低，因此归纳假设每个子节点至少有 2^bh(x)-1 - 1 个内部节点，因此，以 x 为根的子树至少有 2^(bh(x)-1) - 1 + 2^(bh(x)-1) - 1 = 2^bh(x) - 1个内部节点。&lt;/p&gt;
&lt;p&gt;设 h 是树高，根据性质 4 可知道，每一条路径至少有一半的节点是黑的，因此 bh(x) - 1 = h/2。&lt;/p&gt;
&lt;p&gt;那么红黑树节点个数就为 n &amp;gt;= 2^h/2 - 1。&lt;/p&gt;
&lt;p&gt;可得 n + 1 &amp;gt;= 2^h/2。两边取对数得：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    log(n+1) &amp;gt;= h/2

=&amp;gt;  2log(n+1) &amp;gt;= h

=&amp;gt;  h &amp;lt;= 2log(n+1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由上面的证明可得，红黑树的高度最大值是 2log(n+1)，因此红黑树查找的复杂度为 O(lgn)。对于红黑树的插入和删除操作，算法复杂度也是 O(lgn)，因此红黑树的所有操作都是 O(lgn)`的复杂度。&lt;/p&gt;
&lt;h2 id=&quot;%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C%E5%88%86%E6%9E%90&quot; tabindex=&quot;-1&quot;&gt;红黑树的插入操作分析&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;红黑树的插入操作，先找到要新节点插入的位置，将节点赋予红色，然后插入新节点。最后做红黑树性质的修复。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;%E6%96%B0%E8%8A%82%E7%82%B9%E8%B5%8B%E4%BA%88%E7%BA%A2%E8%89%B2%E7%9A%84%E5%8E%9F%E5%9B%A0&quot; tabindex=&quot;-1&quot;&gt;新节点赋予红色的原因&lt;/h3&gt;
&lt;p&gt;因为插入操作只可能会违反性质 2、4、5，对于性质 2，只需要直接将根节点变黑即可；那么需要处理的就有性质 4 和性质 5，如果插入的是黑节点，那么就会影响新节点所在子树的黑高，这样一来就会违反性质 5，如果新节点是红色，那么新插入的节点就不会违反性质 5，只需要处理违反性质 2 或性质 4 的情况。即根节点为红色或者存在两个连续的红节点。简而言之，就是减少修复红黑性质被破坏的情况。&lt;/p&gt;
&lt;h3 id=&quot;%E6%8F%92%E5%85%A5%E7%AE%97%E6%B3%95%E4%BC%AA%E4%BB%A3%E7%A0%81&quot; tabindex=&quot;-1&quot;&gt;插入算法伪代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;RB-INSERT(T, node)
    walk = T.root
    prev = NULL
    while (walk != NULL)
        prev = walk
        if (node.key &amp;lt; walk.key)
            walk = walk.left
        else walk = walk.right
    node.parent = walk
    if (walk == NULL)
        T.root = node
    else if (node.key &amp;lt; walk.key)
        walk.left = node
    else walk.right = node
    RB-INSERT-FIXUP(T, node)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;%E6%8F%92%E5%85%A5%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE&quot; tabindex=&quot;-1&quot;&gt;插入算法流程图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/red-black-tree-insert.png&quot; alt=&quot;red-black-tree-insert&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;%E6%8F%92%E5%85%A5%E7%9A%84%E4%BF%AE%E5%A4%8D&quot; tabindex=&quot;-1&quot;&gt;插入的修复&lt;/h3&gt;
&lt;p&gt;插入之后，如果新结点（node）的父结点（parent）或者根节点（root）是红色，那么就会违反了红黑树的性质 4 或性质 2。对于后者，只需要直接将 root 变黑即可。&lt;/p&gt;
&lt;p&gt;而前者，违反了性质 4 的，即红黑树出现了连续两个红结点的情况。修复的变化还要看父结点是祖父结点的左孩子还是右孩子，左右两种情况是对称的，此处看父结点是祖父结点的左孩子的情况。要恢复红黑树的性质，那么就需要将 parent 的其中一个变黑，这样的话，该结点所在的子树的黑高 +1，这样就会破坏了性质 5，违背了初衷。因此需要将 parent-&amp;gt;parent(grandparent)的另一个结点（uncle 结点）的黑高也 +1 来维持红黑树的性质。&lt;/p&gt;
&lt;p&gt;如果 uncle 是红色，那么直接将 uncle 变为黑色，同时 parent 也变黑。但是这样一来，以 grandparent 为根所在的子树的黑高就 +1，因此将 grandparent 变红使其黑高减一，然后将 node 指向 grandparent，让修复结点上升两个 level，直到遇到根结点为止。&lt;/p&gt;
&lt;p&gt;如果 uncle 是黑色，那么就不能将 uncle 变黑了。那么只能将红节点上升给祖父节点，即将祖父结点变红，然后将父结点变黑，这样一来，以父结点为根的子树的左右子树就不平衡了，此时左子树比右子树的黑高多 1，那么就需要通过将祖父结点右旋以调整左右平衡。&lt;/p&gt;
&lt;h3 id=&quot;%E6%8F%92%E5%85%A5%E4%BF%AE%E5%A4%8D%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%AA%E4%BB%A3%E7%A0%81&quot; tabindex=&quot;-1&quot;&gt;插入修复算法的伪代码&lt;/h3&gt;
&lt;p&gt;RB-INSERT-FIXUP(T, node)
while IS_RED(node)
parent = node-&amp;gt;parent
if !IS_RED(parent) break
grandparent = parent-&amp;gt;parent
if parent == grandparent.left
uncle = grandparent.right
if IS_RED(uncle)
parent.color = BLACK
uncle.color = BLACK
grandparent.color = RED
node = grandparent
elseif node == parent.right
LEFT_ROTATE(T, parent)
swap(node, parent)
else
parent.color = BLACK
grandparent.color = RED
RIGHT_ROTATE(T, grandparent)
else
same as then clause with &amp;quot;right&amp;quot; and &amp;quot;left&amp;quot; exchanged&lt;/p&gt;
&lt;p&gt;T.root.color = BLACK&lt;/p&gt;
&lt;h3 id=&quot;%E6%8F%92%E5%85%A5%E4%BF%AE%E5%A4%8D%E7%AE%97%E6%B3%95%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE&quot; tabindex=&quot;-1&quot;&gt;插入修复算法的流程图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/red-black-tree-insert-fixup.png&quot; alt=&quot;red-black-insert-fixup&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;%E6%8F%92%E5%85%A5%E7%9A%84%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90&quot; tabindex=&quot;-1&quot;&gt;插入的算法复杂度分析&lt;/h3&gt;
&lt;p&gt;插入的步骤主要有两步&lt;/p&gt;
&lt;p&gt;a. 找到新结点的插入位置
b. 进行插入修复。而插入修复包括旋转和使修复结点上升。&lt;/p&gt;
&lt;p&gt;对于 a，从上面可知，查找的算法复杂度是 O(lgn)。&lt;/p&gt;
&lt;p&gt;对于 b，插入修复中，每一次修复结点上升 2 个 level，直到遇到根结点，走过的路径最大值是树的高度，算法复杂度是 O(lgn)；由旋转的描述可得其算法复杂度是 O(1)，因此插入修复的算法复杂度是 O(lgn)。&lt;/p&gt;
&lt;p&gt;综上所述，插入的算法复杂度 O(INSERT) = O(lgn) + O(lgn) = O(lgn)。&lt;/p&gt;
&lt;h2 id=&quot;%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E5%88%86%E6%9E%90&quot; tabindex=&quot;-1&quot;&gt;红黑树的删除操作分析&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;红黑树的删除操作，先找到要删除的结点，然后找到要删除结点的后继，用其后继替换要删除的结点的位置，最后再做红黑树性质的修复。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;红黑树的删除操作比插入操作更复杂一些。&lt;/p&gt;
&lt;p&gt;要删除一个结点（node），首先要找到该结点所在的位置，接着，判断 node 的子树情况。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果 node 只有一个子树，那么将其后继（successor）替换掉 node 即可；&lt;/li&gt;
&lt;li&gt;如果 node 有两个子树，那么就找到 node 的 successor 替换掉 node；&lt;/li&gt;
&lt;li&gt;如果 successor 是 node 的右孩子，那么直接将 successor 替换掉 node 即可，但是需要将 successor 的颜色变为 node 的颜色；&lt;/li&gt;
&lt;li&gt;如果 successor 不是 node 的右孩子，而因为 node 的后继是没有左孩子的（这个可以查看相关证明），所以删除掉 node 的后继 successor 之后，需要将 successor 的右孩子 successor.right 补上 successor 的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;删除过程中需要保存 successor 的颜色 color，因为删除操作可能会导致红黑树的性质被破坏，而删除操作删除的是 successor。因此，每一次改变 successor 的时候，都要更新 color。&lt;/p&gt;
&lt;h3 id=&quot;%E5%88%A0%E9%99%A4%E6%97%B6%E7%94%A8%E5%88%B0%E7%9A%84-transplant-%E6%93%8D%E4%BD%9C&quot; tabindex=&quot;-1&quot;&gt;删除时用到的 TRANSPLANT 操作&lt;/h3&gt;
&lt;p&gt;TRANSPLANT(T, u, v) 是移植结点的操作，此函数的功能是使结点 v 替换结点 u 的位置。在删除操作中用来将后继结点替换到要删除结点的位置。&lt;/p&gt;
&lt;h3 id=&quot;%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E7%9A%84%E5%90%8E%E7%BB%A7%E7%BB%93%E7%82%B9%E6%B2%A1%E6%9C%89%E5%B7%A6%E5%AD%A9%E5%AD%90%E8%AF%81%E6%98%8E&quot; tabindex=&quot;-1&quot;&gt;删除结点的后继结点没有左孩子证明&lt;/h3&gt;
&lt;p&gt;用 x 表示有非空左右孩子的结点。在树的中序遍历中，在 x 的左子树的结点在 x 的前面，在 x 的右子树的结点都在 x 的后面。因此，x 的前驱在其左子数，后继在其右子树。&lt;/p&gt;
&lt;p&gt;假设 s 是 x 的后继。那么 s 不能有左子树，因为在中序遍历中，s 的左子树会在 x 和 s 的中间。（在 x 的后面是因为其在 x 的右子树中，在 s 的前面是因为其在 x 的左子树中。）在中序遍历中，与前面的假设一样，如果任何结点在 x 和 s 之间，那么该结点就不是 x 的后继。&lt;/p&gt;
&lt;h3 id=&quot;%E5%88%A0%E9%99%A4%E7%AE%97%E6%B3%95%E4%BC%AA%E4%BB%A3%E7%A0%81&quot; tabindex=&quot;-1&quot;&gt;删除算法伪代码&lt;/h3&gt;
&lt;p&gt;RB-DELETE(T, node)
color = node.color
walk_node = node
if IS_NULL(node.left)
need_fixup_node = node.right
transplant(T, node, need_fixup_node)
elseif IS_NULL(node.right)
need_fixup_node = node.left
transplant(T, node, need_fixup_node)
else
walk_node = minimum(node.right)
color = walk_node.color
need_fixup_node = walk_node.right
if walk_node.parent != node
transplant(T, walk_node, walk_node.right)
walk_node.right = node.right
walk_node.right.parent = walk_node
transplant(T, node, walk_node)
walk_node.left = node.left
walk_node.left.parent = walk_node
walk_node.color = node.color&lt;/p&gt;
&lt;p&gt;if color == BLACK
RB-DELETE-FIXUP(T, need_fixup_node)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：笔者参考的是算法导论的伪代码，但是在实现的时候，因为用 NULL 表示空结点，如果需要修复的结点 need_fixup_node为空时无法拿到其父结点，因此保存了其父结点 need_fixup_node_parent 及其所在方向 direction，为删除修复时访问其父结点及其方向时做调整。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE&quot; tabindex=&quot;-1&quot;&gt;删除操作流程图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/red-black-tree-delete.png&quot; alt=&quot;red-black-delete&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;%E5%88%A0%E9%99%A4%E7%9A%84%E4%BF%AE%E5%A4%8D%E6%93%8D%E4%BD%9C%E5%88%86%E6%9E%90&quot; tabindex=&quot;-1&quot;&gt;删除的修复操作分析&lt;/h3&gt;
&lt;p&gt;删除过程中需要保存 successor 的颜色 color，因为删除操作可能会导致红黑树的性质被破坏，而删除操作删除的是 successor。因此，每一次改变 successor 的时候，都要更新 color。&lt;/p&gt;
&lt;p&gt;会导致红黑树性质被破坏的情况就是 successor 的颜色是黑色，当 successor 的颜色是红色的时候，不会破坏红黑树性质，理由如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;性质 1，删除的是红结点，不会改变其他结点颜色，因此不会破坏。&lt;/li&gt;
&lt;li&gt;性质 2，如果删除的是红结点，那么该结点不可能是根结点，因此根结点的性质不会被破坏。&lt;/li&gt;
&lt;li&gt;性质 3，叶子结点的颜色保持不变。&lt;/li&gt;
&lt;li&gt;性质 4，删除的是红结点，因为原来的树是红黑树，所以不可能出现连续两个结点为红色的情况。因为删除是 successor 只是替换 node 的位置，但是颜色被改为 node 的颜色。另外，如果 successor 不是node 的右孩子，那么就需要先将 successor 的右孩子 successor-&amp;gt;right 替换掉 successor，如果 successor 是红色，那么 successor-&amp;gt;right 肯定是黑色，因此也不会造成两个连续红结点的情况。性质 4 不被破坏。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;性质 5，删除的是红结点，不会影响黑高，因此性质 5 不被破坏。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果删除的是黑结点，可能破坏的性质是 2、4、5。理由及恢复方法如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果 node 是黑，其孩子是红，且 node 是 root，那么就会违反性质 2；（修复此性质只需要将 root 直接变黑即可）&lt;/li&gt;
&lt;li&gt;如果删除后 successor 和 successor-&amp;gt;right 都是红，那么会违反性质 4；（直接将 successor-&amp;gt;right 变黑就可以恢复性质）&lt;/li&gt;
&lt;li&gt;如果黑结点被删除，会导致路径上的黑结点 -1，违反性质 5。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么剩下性质 5 较难恢复，不妨假设 successor-&amp;gt;right 有一层额外黑色，那么性质 5 就得以维持，而这样做就会破坏了性质 1。因为此时 new_successor 就为 double black（BB）或 red-black（RB）。那么就需要修复new_successor 的颜色，将其“额外黑”上移，使其红黑树性质完整恢复。&lt;/p&gt;
&lt;p&gt;注意：该假设只是加在 new_successor 的结点上，而不是该结点的颜色属性。&lt;/p&gt;
&lt;p&gt;如果是 R-B 情况，那么只需要将 new_successor 直接变黑，那么“额外黑”就上移到 new_successor 了，修复结束。&lt;/p&gt;
&lt;p&gt;如果是 BB 情况，就需要将多余的一层“额外黑”继续上移。此处还要看 new_successor 是原父结点的左孩子还是右孩子，这里设其为左孩子，左右孩子的情况是对称的。&lt;/p&gt;
&lt;p&gt;如果直接将额外黑上移给父结点，那么以 new_successor 的父结点为根的子树就会失去平衡，因为左子树的黑高 -1 了。因此需要根据 new_successor 的兄弟结点 brother 的颜色来考虑调整。&lt;/p&gt;
&lt;p&gt;如果 brother 是红色，那么 brother 的两个孩子和 parent 都是黑色，此时额外黑就无法上移给父结点了，那么就需要做一些操作，将 brother 和 parent 的颜色交换，使得 brother 变黑， parent 变红，这样的话，brother 所在的子树黑高就 +1 了，以 parent 为根做一次左旋恢复黑高平衡。旋转之后，parent 是红色的，且 brother 的其中一个孩子成为了 parent 的新的右孩子结点，将 brother 重新指向新的兄弟结点，然后接着考虑其他情况。&lt;/p&gt;
&lt;p&gt;如果 brother 是黑色，那么就需要通过将 brother 的黑色和 successor 的额外黑组成的一重黑色上移达到目的，而要上移 brother 的黑色，还需要考虑其孩子结点的颜色。&lt;/p&gt;
&lt;p&gt;如果 brother-&amp;gt;right 和 brother-&amp;gt;right 都是黑色，那么好办，直接将黑色上移，即 brother-&amp;gt;color = RED。此时包含额外黑的结点就变成了 parent。parent 为 RB 或 BB，循环继续。&lt;/p&gt;
&lt;p&gt;如果 brother-&amp;gt;left-&amp;gt;color =RED，brother-&amp;gt;right-&amp;gt;color = BLACK，将其转为最后一种情况一起考虑。即将 brother-&amp;gt;right 变红。转换步骤为：将 brother-&amp;gt;left-&amp;gt;color = BLACK; brother-&amp;gt;color = RED。这样的话 brother 的左子树多了一层黑，右旋 brother，恢复属性。然后将 brother 指向现在的 parent 的右结点，那么现在的 brother-&amp;gt;right 就是红色。转为最后一种情况考虑。&lt;/p&gt;
&lt;p&gt;如果 brother-&amp;gt;right-&amp;gt;color = RED。那么就要将 brother-&amp;gt;right 变黑，使得 brother 的黑色可以上移而不破坏红黑树属性，上移步骤是使 brother 变成 brother-&amp;gt;parent 的颜色，brother-&amp;gt;parent 变黑这样一来，黑色就上移了。然后左旋 parent，这样 successor 的额外黑就通过左旋加进来的黑色抵消了。但是 parent 的右子树的黑高就 -1 了，而通过刚刚将 brother-&amp;gt;right 变黑就弥补了右子树减去的黑高。现在就不存在额外黑了，结束修复，然后让 successor 指向 root，判断 root 是否为红色。&lt;/p&gt;
&lt;h3 id=&quot;%E5%88%A0%E9%99%A4%E4%BF%AE%E5%A4%8D%E7%AE%97%E6%B3%95%E4%BC%AA%E4%BB%A3%E7%A0%81&quot; tabindex=&quot;-1&quot;&gt;删除修复算法伪代码&lt;/h3&gt;
&lt;p&gt;while node != root &amp;amp;&amp;amp; node.color == BLACK)
parent = node.parent
if node = parent.left
brother = parent.right
if IS_RED(brother)
brother.color = BLACK
parent.color = RED
LEFT_ROTATE(T, parent)
brother = parent.right&lt;/p&gt;
&lt;p&gt;if brother.left.color == BLACK and brother.right.color == BLACK
brother.color = RED
node = parent
elseif brother.right.color = BLACK
brother.left.color = BLACK
brother.color = RED
RIGHT_ROTATE(T, brother)
brother = parent.right
else
brother.color = parent.color
parent.color = BLACK
brother.right.color = BLACK
LEFT_ROTATE(T, parent)
node = root
else (same as then clause with “right” and “left” exchanged)
node.color = BLACK&lt;/p&gt;
&lt;h3 id=&quot;%E5%88%A0%E9%99%A4%E4%BF%AE%E5%A4%8D%E7%AE%97%E6%B3%95%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE&quot; tabindex=&quot;-1&quot;&gt;删除修复算法的流程图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/red-black-tree-delete-fixup.png&quot; alt=&quot;red-black-delete-fixup&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E7%9A%84%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90&quot; tabindex=&quot;-1&quot;&gt;删除操作的算法复杂度分析&lt;/h3&gt;
&lt;p&gt;删除的操作主要有查找要删除的结点，删除之后的修复。&lt;/p&gt;
&lt;p&gt;修复红黑树性质主要是旋转和结点上移。对于查找来说，查找的算法复杂度是O(lgn)，旋转的复杂度是O(1)，结点上移，走过的路径最大值就是红黑树的高，因此上移结点的复杂度就是O(lgn)。&lt;/p&gt;
&lt;p&gt;综上所述，删除算法的复杂度是 &lt;code&gt;O(DELETE) = O(lgn) + O(1) + O(lgn) = O(lgn)&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB&quot; tabindex=&quot;-1&quot;&gt;资源分享&lt;/h2&gt;
&lt;p&gt;如果对部分步骤不理解，可以到这个网站看看红黑树每一步操作的可视化过程：&lt;a href=&quot;http://www.cs.usfca.edu/~galles/visualization/RedBlack.html&quot;&gt;红黑树可视化网站&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本次代码的实现请点击：&lt;a href=&quot;https://github.com/hoohack/KeepCoding/tree/master/DataStructure/RBTree&quot;&gt;红黑树实现代码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;因为基础知识比较薄弱，所以想补一下自己的基础，无奈悟性较低，花了大半个月时间才把红黑树给理解和实现出来。中途跟朋友讨论了很多次，因此有以上的这些总结。之前一直不敢去实现红黑树，因为觉得自己根本无法理解和实现，内心的恐惧一直压抑着自己，但经过几次挣扎之后，终于鼓起勇气去研究一番，发现，只要用心去研究，就没有解决不了的问题。纠结了很久要不要发这篇博文，这只是一篇知识笔记的记录，并不敢说指导任何人，只想把自己在理解过程中记录下来的笔记分享出来，给有需要的人。但其实想想，纠结个蛋，让笔记作为半成品躺在印象笔记里沉睡，还不如花时间完善好发布出来，然后有兴趣的继续探讨一下。&lt;/p&gt;
&lt;p&gt;如果真的要问我红黑树有什么用？为什么要学它？我真的回答不上，但是我觉得，基础的东西，多学一些也无妨。只有学了，有个思路在脑海里，以后才能用得上，不然等真正要用才来学的话，似乎会浪费了很多学习成本。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点下推荐吧，谢谢^_^&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>[PHP源码阅读]strtolower和strtoupper函数</title>
    <link href="https://hoohack.me/blog/2016/2016-06-02-php-source-code-strtolower-strtoupper/"/>
    <updated>2016-06-02T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-06-02-php-source-code-strtolower-strtoupper/</id>
    <content type="html">&lt;p&gt;字符串的操作函数中，字符串的大小写转换也算是比较常用的函数，其底层实现也比较简单，下面来一探究竟。&lt;/p&gt;
&lt;p&gt;我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/read-php-src/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/read-php-src/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
&lt;h2 id=&quot;strtolower&quot; tabindex=&quot;-1&quot;&gt;strtolower&lt;/h2&gt;
&lt;p&gt;string strtolower ( string $string )&lt;/p&gt;
&lt;p&gt;将字符串转换成小写字符。&lt;/p&gt;
&lt;h2 id=&quot;strtoupper&quot; tabindex=&quot;-1&quot;&gt;strtoupper&lt;/h2&gt;
&lt;p&gt;string strtoupper ( string $string )&lt;/p&gt;
&lt;p&gt;将字符串转换成大写字符。&lt;/p&gt;
&lt;h2 id=&quot;%E8%BF%90%E8%A1%8C%E7%A4%BA%E4%BE%8B&quot; tabindex=&quot;-1&quot;&gt;运行示例&lt;/h2&gt;
&lt;p&gt;$str = &#39;Hello World&#39;;
$new_str = strtolower($str); // hello world&lt;/p&gt;
&lt;p&gt;$str = &#39;hello world&#39;;
$new_str = strupper($str); // HELLO WORLD&lt;/p&gt;
&lt;h2 id=&quot;%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E6%AD%A5%E9%AA%A4&quot; tabindex=&quot;-1&quot;&gt;代码运行步骤&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;拷贝一份字符串&lt;/p&gt;
&lt;p&gt;php_strtolower/php_strtoupper进行转换&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB&quot; tabindex=&quot;-1&quot;&gt;源码解读&lt;/h2&gt;
&lt;p&gt;两个函数的核心操作都差不多，讲一下strtolower，另一个是类似的。
php_strtolower函数的核心代码如下：&lt;/p&gt;
&lt;p&gt;c = (unsigned char *)s;
e = c+len;&lt;/p&gt;
&lt;p&gt;// 遍历s，逐个变为小写
while (c &amp;lt; e) {
　　*c = tolower(*c);
　　c++;
}
return s;&lt;/p&gt;
&lt;p&gt;这个函数就是遍历整个字符串，逐个转成小写字符。这也是一个经典的指针操作。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点下推荐吧，谢谢^_^&lt;/p&gt;
&lt;p&gt;最后再安利一下，我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/read-php-src/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/read-php-src/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
&lt;p&gt;更多源码文章，欢迎访问个人主页继续查看：&lt;a href=&quot;https://www.hoohack.me/&quot;&gt;hoohack&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>[PHP源码阅读]count函数</title>
    <link href="https://hoohack.me/blog/2016/2016-05-31-php-source-code-count/"/>
    <updated>2016-05-31T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-05-31-php-source-code-count/</id>
    <content type="html">&lt;p&gt;在PHP编程中，在遍历数组的时候经常需要先计算数组的长度作为循环结束的判断条件，而在PHP里面对数组的操作是很频繁的，因此count也算是一个常用函数，下面研究一下count函数的具体实现。&lt;/p&gt;
&lt;p&gt;我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/read-php-src/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/read-php-src/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
&lt;h2 id=&quot;count&quot; tabindex=&quot;-1&quot;&gt;count&lt;/h2&gt;
&lt;p&gt;int count ( mixed $array_or_countable [, int $mode = COUNT_NORMAL ] )&lt;/p&gt;
&lt;p&gt;count函数计算数组或者对象里面的所有元素个数。&lt;/p&gt;
&lt;p&gt;对于对象来说，如果你安装了SPL扩展，可以通过实现Countable接口来调用count函数。Countable接口有且仅有一个方法Countable::count()，该方法的返回count()函数的返回值。&lt;/p&gt;
&lt;h2 id=&quot;%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E&quot; tabindex=&quot;-1&quot;&gt;参数说明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;mode&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果参数mode设为COUNT_RECURSIVE(或1)，count()会递归地计算该数组。在计算多维数组的时候特别有用。&lt;/p&gt;
&lt;p&gt;如果第一个参数不是数组或者实现Countable接口的对象，count函数将返回1。&lt;/p&gt;
&lt;p&gt;注意：count函数可以检测递归避免无限循环，但会在遇到无限递归或得到比期望值大的时候返回E_WARNING提示。&lt;/p&gt;
&lt;h2 id=&quot;%E8%BF%90%E8%A1%8C%E7%A4%BA%E4%BE%8B&quot; tabindex=&quot;-1&quot;&gt;运行示例&lt;/h2&gt;
&lt;h3 id=&quot;%E6%99%AE%E9%80%9A%E5%BA%94%E7%94%A8&quot; tabindex=&quot;-1&quot;&gt;普通应用&lt;/h3&gt;
&lt;p&gt;$arr1 = array(1, 2, 3, 4, 5);
$val1 = count($arr1); // 5&lt;/p&gt;
&lt;h3 id=&quot;%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84&quot; tabindex=&quot;-1&quot;&gt;多维数组&lt;/h3&gt;
&lt;p&gt;$arr2 = array(&#39;apple&#39;, &#39;banana&#39;, array(&#39;cat&#39;, &#39;camel&#39;), &#39;dog&#39;);
$val2_1 = count($arr2); // 4
$val2_2 = count($arr2, 1); // 6&lt;/p&gt;
&lt;h3 id=&quot;%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2&quot; tabindex=&quot;-1&quot;&gt;数字和字符串&lt;/h3&gt;
&lt;p&gt;$str = &amp;quot;hello world&amp;quot;;
$int_val = 1;
$val3 = count($str); // 1
$val4 = count($int_val); // 1&lt;/p&gt;
&lt;h3 id=&quot;%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1&quot; tabindex=&quot;-1&quot;&gt;普通对象&lt;/h3&gt;
&lt;p&gt;class User {
private $name;
private $address;
}&lt;/p&gt;
&lt;p&gt;$user = new User();
$val5 = count($user); // 1
$val6 = count((array) $user); // 2&lt;/p&gt;
&lt;h3 id=&quot;array-like%E5%AF%B9%E8%B1%A1&quot; tabindex=&quot;-1&quot;&gt;array-like对象&lt;/h3&gt;
&lt;p&gt;class User extends ArrayObject {
private $name;&lt;/p&gt;
&lt;p&gt;public function __construct() {
$this-&amp;gt;name = &#39;hhq&#39;;
}&lt;/p&gt;
&lt;p&gt;public function getName() {
return $this-&amp;gt;name;
}&lt;/p&gt;
&lt;p&gt;public function count() {
return 2;
}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;$user2 = new User();
$val7 = count($user2); // 2&lt;/p&gt;
&lt;h3 id=&quot;%E5%AE%9E%E7%8E%B0countable%E6%8E%A5%E5%8F%A3%E5%AF%B9%E8%B1%A1&quot; tabindex=&quot;-1&quot;&gt;实现Countable接口对象&lt;/h3&gt;
&lt;p&gt;class User implements Countable {
public function count() {
return 3;
}
}&lt;/p&gt;
&lt;p&gt;$user3 = new User();
$val8 = count($user3); // 3&lt;/p&gt;
&lt;h3 id=&quot;%E8%BF%90%E8%A1%8C%E6%AD%A5%E9%AA%A4&quot; tabindex=&quot;-1&quot;&gt;运行步骤&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;进入switch语句检测参数类型&lt;/p&gt;
&lt;p&gt;如果是NULL，直接返回0&lt;/p&gt;
&lt;p&gt;如果是数组，调用php_count_recursive函数机选数组元素个数&lt;/p&gt;
&lt;p&gt;如果是对象，先检查是否为数组对象（array-like object），如果是，则计算数组对象的数量&lt;/p&gt;
&lt;p&gt;否则，如果对象实现了Countable接口，则调用Countable的count方法&lt;/p&gt;
&lt;p&gt;最后，其他类型比如整型数组或字符串，都返回1。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB&quot; tabindex=&quot;-1&quot;&gt;源码解读&lt;/h2&gt;
&lt;p&gt;如果是普通数组，count函数会调用php_count_recursive函数实现其功能的运行步骤如下：&lt;/p&gt;
&lt;p&gt;如果当前hash Bucket被递归访问的次数大于1，说明重复递归，染回E_WARNING错误&lt;/p&gt;
&lt;p&gt;否则计算当前数组层数的数组元素个数&lt;/p&gt;
&lt;p&gt;如果有递归参数选项，则继续递归访问&lt;/p&gt;
&lt;p&gt;如果参数是对象类型，实现时会先判断handler是否被定义。而handler是PHP内核中对象的结构体，其中包含有&lt;strong&gt;count_elements&lt;/strong&gt;字段，实际上是一个函数。如果某个对象表现得想数组一样，即通常说的&lt;strong&gt;array-like object&lt;/strong&gt;，那么就会执行count_elements函数。具体实现是类继承PHP的ArrayObject，并在类里面实现count函数，具体调用的就是count函数，如果类没有实现count函数，则count返回0，否则返回对象的count函数的返回值。&lt;/p&gt;
&lt;p&gt;如果是其他的数据类型
1、字符串&lt;/p&gt;
&lt;p&gt;2、数字&lt;/p&gt;
&lt;p&gt;3、对象分支中两个if判断都为false的情况，即没有继承ArrayObject且没有实现Countable接口。&lt;/p&gt;
&lt;p&gt;这些类型通通返回1。&lt;/p&gt;
&lt;p&gt;需要注意的是，如果需要计算的是对象的属性数量，可以先将对象转换成数组，然后调用count函数。如：
$count_value = count((array) $user);&lt;/p&gt;
&lt;h2 id=&quot;%E5%B0%8F%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;阅读count函数的源码过程中，在其中一步卡住了，就是if (Z_OBJ_HT_P(array)-&amp;gt;count_elements)这一步，因为始终无法写出进入这个分支的demo，在网上搜索了很多资料也未果，因此请教了TIPI的reeze，最终得到了想要的答案。不懂就要问，哈哈。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点下推荐吧，谢谢^_^&lt;/p&gt;
&lt;p&gt;最后再安利一下，我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/read-php-src/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/read-php-src/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
&lt;p&gt;更多源码文章，欢迎访问个人主页继续查看：&lt;a href=&quot;https://www.hoohack.me/&quot;&gt;hoohack&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>[PHP源码阅读]array_pop和array_shift函数</title>
    <link href="https://hoohack.me/blog/2016/2016-05-30-php-source-code-array-pop-array-shift/"/>
    <updated>2016-05-30T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-05-30-php-source-code-array-pop-array-shift/</id>
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://www.hoohack.me/2016/05/27/php-source-code-array-push-array-unshift&quot;&gt;上篇文章&lt;/a&gt;介绍了PHP添加元素到数组的函数，那么当然有从数组中删除元素。array_pop和array_shift只从数组的头或尾删除一个元素。经过阅读源码，发现这两个函数的实现都是调用了同一个函数--_phpi_pop来实现从数组中删除一个数组元素的功能。因此解读时将这两个函数一并讲了。&lt;/p&gt;
&lt;p&gt;我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/read-php-src/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/read-php-src/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
&lt;h2 id=&quot;%E5%87%BD%E6%95%B0%E8%AF%AD%E6%B3%95&quot; tabindex=&quot;-1&quot;&gt;函数语法&lt;/h2&gt;
&lt;h3 id=&quot;array_pop&quot; tabindex=&quot;-1&quot;&gt;array_pop&lt;/h3&gt;
&lt;p&gt;mixed array_pop ( array $&amp;amp;array )&lt;/p&gt;
&lt;p&gt;array_pop函数弹出并返回数组的最后一个单元，并将数组长度减一。如果array为空则返回NULL。&lt;/p&gt;
&lt;h3 id=&quot;array_shift&quot; tabindex=&quot;-1&quot;&gt;array_shift&lt;/h3&gt;
&lt;p&gt;mixed array_shift ( array &amp;amp;$array )&lt;/p&gt;
&lt;p&gt;将数组开头的单元移出数组并作为结果返回，将array长度减一并将所有数字键值改为从0开始计数，文字键值不变。&lt;/p&gt;
&lt;h2 id=&quot;%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B&quot; tabindex=&quot;-1&quot;&gt;代码示例&lt;/h2&gt;
&lt;p&gt;下面代码展示了array_pop和array_shift的使用方法&lt;/p&gt;
&lt;p&gt;$arr = array(‘apple’, ‘banana’, ‘cat’);
$val = array_pop($arr); // val == cat
$arr = array(‘apple’, ‘banana’, ‘cat’);
$val = array_shift($arr); // val == apple&lt;/p&gt;
&lt;h2 id=&quot;%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4&quot; tabindex=&quot;-1&quot;&gt;执行步骤&lt;/h2&gt;
&lt;p&gt;两个函数都是调用了_phpi_pop函数，区别不同的是调用_phpi_pop函数时传递的第二个参数off_the_end的不同，如果off_the_end是1，则是array_pop，否则是array_shift。下面是_phpi_pop这个函数执行的详细步骤：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、如果数组长度为0，则返回NULL。&lt;/p&gt;
&lt;p&gt;2、根据off_the_end参数移动内部指针指向需要删除的数组元素。&lt;/p&gt;
&lt;p&gt;3、设置返回值为第二步指针指向的元素。&lt;/p&gt;
&lt;p&gt;4、从数组中移出第一个或最后一个值并将长度减一。&lt;/p&gt;
&lt;p&gt;5、如果是array_shift操作，则需要重置数组下标，将数字下标改为从0开始计数，文字键值不变；否则只需要修改下一个数字索引的位置。&lt;/p&gt;
&lt;p&gt;6、重置array指针。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;函数执行的过程可以用下面的流程图描述：
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/phpi_pop.png&quot; alt=&quot;phpi_pop&quot; /&gt;&lt;/p&gt;
&lt;p&gt;下面两个图展示了根据上面的示例代码执行时数组元素和内部指针的变化的效果图：
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/array_pop.png&quot; alt=&quot;array_pop&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;array_pop&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/array_shift.png&quot; alt=&quot;array_shift&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;array_shift&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;array_pop和array_shift调用此函数执行的步骤都大同小异，不同之处在于：&lt;/p&gt;
&lt;p&gt;1、在移动指针时，前者移动到数组尾部，后者移动指针到数组第一个单元。&lt;/p&gt;
&lt;p&gt;2、删除操作完成后，前者只需修改下一个数字索引的位置，而后者需要重置数组下标。&lt;/p&gt;
&lt;h2 id=&quot;%E5%B0%8F%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;如果两个函数实现的步骤差不多，可以用一个参数区别执行的是哪一个函数以减少程序中重复的代码。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点下推荐吧，谢谢^_^&lt;/p&gt;
&lt;p&gt;最后再安利一下，我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/read-php-src/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/read-php-src/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
&lt;p&gt;更多源码文章，欢迎访问个人主页继续查看：&lt;a href=&quot;https://www.hoohack.me/&quot;&gt;hoohack&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>[PHP源码阅读]array_push和array_unshift函数</title>
    <link href="https://hoohack.me/blog/2016/2016-05-27-php-source-code-array-push-array-unshift/"/>
    <updated>2016-05-27T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-05-27-php-source-code-array-push-array-unshift/</id>
    <content type="html">&lt;p&gt;在PHP中，在数组中添加元素也是一种很常用的操作，分别有在数组尾部和头部添加元素，看看PHP内部是如何实现数组插入的操作。&lt;/p&gt;
&lt;p&gt;我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/read-php-src/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/read-php-src/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
&lt;h2 id=&quot;array_push&quot; tabindex=&quot;-1&quot;&gt;array_push&lt;/h2&gt;
&lt;p&gt;int array_push ( array &amp;amp;$array , mixed $value1 [ , mixed $... ] )&lt;/p&gt;
&lt;p&gt;array_push函数将array参数看做一个栈，将传递进来的变量压倒array的尾部。array的长度随着被压进去的变量个数增加。下面的代码有意义的效果：&lt;/p&gt;
&lt;p&gt;$array[] = $var;&lt;/p&gt;
&lt;p&gt;如果只需要添加一个元素到数组，使用$array[] 这种方式更好，因为这样做不用调用函数。&lt;/p&gt;
&lt;h3 id=&quot;%E8%BF%90%E8%A1%8C%E7%A4%BA%E4%BE%8B&quot; tabindex=&quot;-1&quot;&gt;运行示例&lt;/h3&gt;
&lt;p&gt;$arr = array();
array_push($arr, 1, 2, 3); // return 3; $arr = [1, 2, 3]&lt;/p&gt;
&lt;h3 id=&quot;%E8%BF%90%E8%A1%8C%E6%AD%A5%E9%AA%A4&quot; tabindex=&quot;-1&quot;&gt;运行步骤&lt;/h3&gt;
&lt;p&gt;array_push函数相对比较简单，就相当于压栈操作，把array看做一个栈，然后对每一个参数，让其变成引用，引用数加一，然后添加它到数组的尾部。&lt;/p&gt;
&lt;p&gt;内部实现的流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/array_push.png&quot; alt=&quot;array_push流程图&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB&quot; tabindex=&quot;-1&quot;&gt;源码解读&lt;/h3&gt;
&lt;p&gt;添加元素使用了&lt;strong&gt;zend_hash_next_index_insert&lt;/strong&gt;函数，此函数是_zend_hash_next_index_insert函数的宏定义，这个函数是PHP内部实现数组的数据结构--哈希表包含的一些API，这个API用于追加元素到哈希表或者更新哈希表中已有的哈希值。此函数实现的流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/zend_insert.png&quot; alt=&quot;zend_insert&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;array_unshift&quot; tabindex=&quot;-1&quot;&gt;array_unshift&lt;/h2&gt;
&lt;p&gt;int arrat_unshift ( array &amp;amp;$array , mixed $value1 [ , mixed $... ] )&lt;/p&gt;
&lt;p&gt;array_unshift函数将数据元素插入到数组的头部，插入时是作为整体插入，因此后面的参数将保持同样的顺序。插入后所有的数值键名将修改为从零开始计数，所有的文字键名不变。&lt;/p&gt;
&lt;h3 id=&quot;%E8%BF%90%E8%A1%8C%E7%A4%BA%E4%BE%8B-1&quot; tabindex=&quot;-1&quot;&gt;运行示例&lt;/h3&gt;
&lt;p&gt;$arr = array(1, 2, 3);
array_unshift($arr, 4, 5, 6); // 4 5 6 1 2 3&lt;/p&gt;
&lt;h3 id=&quot;%E8%BF%90%E8%A1%8C%E6%AD%A5%E9%AA%A4-1&quot; tabindex=&quot;-1&quot;&gt;运行步骤&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;1、调用php_splice将数据元素插入到数组头部，用新的哈希表替换就得哈希表并将其销毁&lt;/p&gt;
&lt;p&gt;2、如果操作后的stack等于运行时的符号表，则重置哈希表的内部指针&lt;/p&gt;
&lt;p&gt;3、stack指向新的哈希表，释放新的哈希表红箭，销毁就得哈希表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-1&quot; tabindex=&quot;-1&quot;&gt;源码解读&lt;/h3&gt;
&lt;p&gt;由上面的步骤可知，array_unshift的核心步骤是php_splice函数。对于array_unshift函数，php_splice实现时新建一个哈希表out_hash，将需要插入的list数据先插入到out_hash中，然后再把原来的数组数据写入到out_hash中，这样实现在数组前面插入数据元素的功能。&lt;/p&gt;
&lt;p&gt;实现的效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/php_splice.png&quot; alt=&quot;php_splice&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E5%B0%8F%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;要理解array_push函数的执行过程主要理解栈的思想即可，而array_unshift则是新建一个数组，然后将两数组合并为结果数组。
这次阅读源码过程中，同时也研究了PHP中的哈希表数据结构及一些API，也给自己补充了一些哈希表的知识。学习到了PHP底层是使用双向链表做哈希冲突的处理，获益匪浅。日后再做关于PHP数据结构的分享。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，&lt;strong&gt;点收藏的同时也请点下推荐吧&lt;/strong&gt;，谢谢^_^&lt;/p&gt;
&lt;p&gt;我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/read-php-src/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/read-php-src/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
&lt;p&gt;更多源码文章，欢迎访问个人主页继续查看：&lt;a href=&quot;https://www.hoohack.me/&quot;&gt;hoohack&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>[PHP源码阅读]empty和isset函数</title>
    <link href="https://hoohack.me/blog/2016/2016-05-26-php-source-code-empty-isset/"/>
    <updated>2016-05-26T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-05-26-php-source-code-empty-isset/</id>
    <content type="html">&lt;p&gt;近日被问到PHP中empty和isset函数时怎么判断变量的，刚开始我是一脸懵逼的，因为我自己也只是一知半解，为了弄懂其真正的原理，赶紧翻开源码研究研究。经过分析可发现两个函数调用的都是同一个函数，因此本文将对两个函数一起分析。&lt;/p&gt;
&lt;p&gt;我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/read-php-src/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/read-php-src/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
&lt;h2 id=&quot;%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%A0%BC%E5%BC%8F&quot; tabindex=&quot;-1&quot;&gt;函数使用格式&lt;/h2&gt;
&lt;h3 id=&quot;empty&quot; tabindex=&quot;-1&quot;&gt;empty&lt;/h3&gt;
&lt;p&gt;bool empty ( mixed $var )&lt;/p&gt;
&lt;p&gt;判断变量是否为空。&lt;/p&gt;
&lt;h3 id=&quot;isset&quot; tabindex=&quot;-1&quot;&gt;isset&lt;/h3&gt;
&lt;p&gt;bool isset ( mixed $var [ , mixed $... ] )&lt;/p&gt;
&lt;p&gt;判断变量是否被设置且不为NULL。&lt;/p&gt;
&lt;h2 id=&quot;%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E&quot; tabindex=&quot;-1&quot;&gt;参数说明&lt;/h2&gt;
&lt;p&gt;对于empty，在PHP5.5版本以前，empty只支持变量参数，其他类型的参数会导致解析错误，比如函数调用的结果不能作为参数。&lt;/p&gt;
&lt;p&gt;对于isset，如果变量被如unset的函数设为NULL，则函数会返回false。如果多个参数被传递到isset函数，那么只有所有参数都被设置isset函数才会返回true。从左到右计算，一旦遇到没被设置的变量就停止。&lt;/p&gt;
&lt;p&gt;运行示例&lt;/p&gt;
&lt;p&gt;$result = empty(0); // true
$result = empty(null); // true
$result = empty(false); // true
$result = empty(array()); // true
$result = empty(&#39;0&#39;); // true
$result = empty(1); // false
$result = empty(callback function); // 报错&lt;/p&gt;
&lt;p&gt;$a = null;
$result = isset($a); // false;&lt;/p&gt;
&lt;p&gt;$a = 1;
$result = isset($a); // true;&lt;/p&gt;
&lt;p&gt;$a = 1;$b = 2;$c = 3;
$result = isset($a, $b, $c); // true&lt;/p&gt;
&lt;p&gt;$a = 1;$b = null;$c = 3;
$result = isset($a, $b, $c); // false&lt;/p&gt;
&lt;p&gt;找到函数的定义位置&lt;/p&gt;
&lt;p&gt;实际上，empty不是一个函数，而是一个语言结构。语言结构是在PHP程序运行前编译好的，因此不能像之前那样简单地搜索&lt;strong&gt;PHP_FUNCTION empty&lt;/strong&gt;或&lt;strong&gt;ZEND_FUNCTION empty&lt;/strong&gt;查看其源码。要想看empty等语言结构的源码，先要理解PHP代码执行的机制。&lt;/p&gt;
&lt;p&gt;PHP执行代码会经过4个步骤，其流程图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/PHP%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4.png&quot; alt=&quot;PHP执行步骤&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在第一个阶段，即Scanning阶段，程序会扫描&lt;strong&gt;zend_language_scanner.l&lt;/strong&gt;文件将代码文件转换成语言片段。对于isset和empty函数来说，在&lt;strong&gt;zend_language_scanner.l&lt;/strong&gt;文件中搜索empty和isset可以得到函数在此文件中的宏定义如下：&lt;/p&gt;
&lt;p&gt;&amp;lt;ST_IN_SCRIPTING&amp;gt;&amp;quot;isset&amp;quot; {
return T_ISSET;
}&lt;/p&gt;
&lt;p&gt;&amp;lt;ST_IN_SCRIPTING&amp;gt;&amp;quot;empty&amp;quot; {
return T_EMPTY;
}&lt;/p&gt;
&lt;p&gt;接下来就到了Parsing阶段，这个阶段，程序将T_ISSET和T_EMPTY等Tokens转换成有意义的表达式，此时会做语法分析，Tokens的yacc保存在zend_language_parser.y文件中，可以找到T_ISSET和T_EMPTY的定义：&lt;/p&gt;
&lt;p&gt;internal_functions_in_yacc:
T_ISSET &#39;(&#39; isset_variables &#39;)&#39; { $$ = $3; }
| T_EMPTY &#39;(&#39; variable &#39;)&#39; { zend_do_isset_or_isempty(ZEND_ISEMPTY, &amp;amp;$$, &amp;amp;$3 TSRMLS_CC); }
| T_INCLUDE expr { zend_do_include_or_eval(ZEND_INCLUDE, &amp;amp;$$, &amp;amp;$2 TSRMLS_CC); }
| T_INCLUDE_ONCE expr { zend_do_include_or_eval(ZEND_INCLUDE_ONCE, &amp;amp;$$, &amp;amp;$2 TSRMLS_CC); }
| T_EVAL &#39;(&#39; expr &#39;)&#39; { zend_do_include_or_eval(ZEND_EVAL, &amp;amp;$$, &amp;amp;$3 TSRMLS_CC); }
| T_REQUIRE expr { zend_do_include_or_eval(ZEND_REQUIRE, &amp;amp;$$, &amp;amp;$2 TSRMLS_CC); }
| T_REQUIRE_ONCE expr { zend_do_include_or_eval(ZEND_REQUIRE_ONCE, &amp;amp;$$, &amp;amp;$2 TSRMLS_CC); }
;&lt;/p&gt;
&lt;p&gt;isset和empty函数最终都执行了&lt;strong&gt;zend_do_isset_or_isempty&lt;/strong&gt;函数，在源码目录中查找&lt;/p&gt;
&lt;p&gt;grep -rn &amp;quot;zend_do_isset_or_isempty&amp;quot;&lt;/p&gt;
&lt;p&gt;可以发现，此函数在zend_compile.c文件中定义。&lt;/p&gt;
&lt;p&gt;函数执行步骤&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、解析参数&lt;/p&gt;
&lt;p&gt;2、检查是否为可写变量&lt;/p&gt;
&lt;p&gt;3、如果是变量的op_type是IS_CV（编译时期的变量），则设置其opcode为ZEND_ISSET_ISEMPTY_VAR；否则从active_op_array中获取下一个op值，根据其op值设置last_op的opcode。&lt;/p&gt;
&lt;p&gt;4、设置了opcode之后，之后会交给zend_excute执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB&quot; tabindex=&quot;-1&quot;&gt;源码解读&lt;/h2&gt;
&lt;p&gt;IS_CV是编译器使用的一种cache机制，这种变量保存着它被引用的变量的地址，当一个变量第一次被引用的时候，就会被CV起来，以后这个变量的引用就不需要再去查找active符号表了。&lt;/p&gt;
&lt;p&gt;对于empty函数，到了opcode的步骤后，参阅opcode处理函数，可以知道，isset和empty在excute的时候执行的是&lt;strong&gt;ZEND_ISSET_ISEMPTY_VAR&lt;/strong&gt;等一系列函数，以&lt;strong&gt;ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_VAR_HANDLER&lt;/strong&gt;为例，找到这个函数的定义在&lt;strong&gt;zend_vm_execute.h&lt;/strong&gt;。查看函数可以知道，empty函数的最终执行函数是&lt;strong&gt;i_zend_is_true()&lt;/strong&gt;，而i_zend_is_true函数定义在&lt;strong&gt;zend_execute.h&lt;/strong&gt;。i_zend_is_true函数的核心代码如下：&lt;/p&gt;
&lt;p&gt;switch (Z_TYPE_P(op)) {
case IS_NULL:
result = 0;
break;
case IS_LONG:
case IS_BOOL:
case IS_RESOURCE:
// empty参数为整数时非0的话就为false
result = (Z_LVAL_P(op)?1:0);
break;
case IS_DOUBLE:
result = (Z_DVAL_P(op) ? 1 : 0);
break;
case IS_STRING:
if (Z_STRLEN_P(op) == 0
|| (Z_STRLEN_P(op)==1 &amp;amp;&amp;amp; Z_STRVAL_P(op)[0]==&#39;0&#39;)) {
// empty(&amp;quot;0&amp;quot;) == true
result = 0;
} else {
result = 1;
}
break;
case IS_ARRAY:
// empty(array) 是根据数组的数量来判断
result = (zend_hash_num_elements(Z_ARRVAL_P(op))?1:0);
break;
case IS_OBJECT:
if(IS_ZEND_STD_OBJECT(*op)) {
TSRMLS_FETCH();&lt;/p&gt;
&lt;p&gt;if (Z_OBJ_HT_P(op)-&amp;gt;cast_object) {
zval tmp;
if (Z_OBJ_HT_P(op)-&amp;gt;cast_object(op, &amp;amp;tmp, IS_BOOL TSRMLS_CC) == SUCCESS) {
result = Z_LVAL(tmp);
break;
}
} else if (Z_OBJ_HT_P(op)-&amp;gt;get) {
zval &lt;em&gt;tmp = Z_OBJ_HT_P(op)-&amp;gt;get(op TSRMLS_CC);
if(Z_TYPE_P(tmp) != IS_OBJECT) {
/&lt;/em&gt; for safety - avoid loop */
convert_to_boolean(tmp);
result = Z_LVAL_P(tmp);
zval_ptr_dtor(&amp;amp;tmp);
break;
}
}
}
result = 1;
break;
default:
result = 0;
break;
}&lt;/p&gt;
&lt;p&gt;这段代码比较直观，函数没有对检测值做任何的转换，通过这段代码来进一步分析示例中的empty函数做分析：
empty(null)，到IS_NULL分支，result=0，i_zend_is_true() == 0，!i_zend_is_true() == 1，因此返回true。&lt;/p&gt;
&lt;p&gt;empty(false)，到IS_BOOL分支，result = ZLVAL_P(false) = 0，i_zend_is_true() == 0，!i_zend_is_true() == 1，因此返回true。&lt;/p&gt;
&lt;p&gt;empty(array())，到IS_ARRAY分支，result = zend_hash_num_elements(Z_ARRVAL_P(op)) ? 1 : 0)，zend_hash_num_elements返回数组元素的数量，array为空，因此result为0，i_zend_is_true() == 0，!i_zend_is_true() == 1，因此返回true。&lt;/p&gt;
&lt;p&gt;empty(&#39;0&#39;)，到IS_STRING分支，因为Z_STRLENP(op) == 1 且 Z_STRVAL_P(op)[0] == &#39;0&#39;，因此result为0，i_zend_is_true() == 0，!i_zend_is_true() == 1，因此返回true。&lt;/p&gt;
&lt;p&gt;empty(1)，到IS_LONG分支，result = Z_LVAL_P(op) = 1，i_zend_is_true == 1，!i_zend_is_true() == 0，因此返回false。&lt;/p&gt;
&lt;p&gt;对于isset函数，最终实现判断的代码是：&lt;/p&gt;
&lt;p&gt;if (isset &amp;amp;&amp;amp; Z_TYPE_PP(value) != IS_NULL) {
ZVAL_BOOL(&amp;amp;EX_T(opline-&amp;gt;result.var).tmp_var, 1);
} else {
ZVAL_BOOL(&amp;amp;EX_T(opline-&amp;gt;result.var).tmp_var, 0);
}&lt;/p&gt;
&lt;p&gt;只要value被设置了且不为NULL，isset函数就返回true。&lt;/p&gt;
&lt;h2 id=&quot;%E5%B0%8F%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;这次阅读这两个函数的源码，学习到了：&lt;/p&gt;
&lt;p&gt;1、PHP代码在编译期间的执行步骤&lt;/p&gt;
&lt;p&gt;2、如何查找PHP语言结构的源码位置&lt;/p&gt;
&lt;p&gt;3、如何查找opcode处理函数的具体函数&lt;/p&gt;
&lt;p&gt;学无止境，每个人都有自己的短板，只有通过不断学习才能将自己的短板补上。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点下推荐吧，谢谢^_^&lt;/p&gt;
&lt;p&gt;我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/read-php-src/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/read-php-src/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
&lt;p&gt;参考文章&lt;/p&gt;
&lt;p&gt;opcode处理函数查找：&lt;a href=&quot;http://www.laruence.com/2008/06/18/221.html&quot;&gt;http://www.laruence.com/2008/06/18/221.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PHPopcode深入理解及PHP代码执行步骤：&lt;a href=&quot;http://www.php-internals.com/book/?p=chapt02/02-03-03-from-opcode-to-handler&quot;&gt;http://www.php-internals.com/book/?p=chapt02/02-03-03-from-opcode-to-handler&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多源码文章，欢迎访问个人主页继续查看：&lt;a href=&quot;https://www.hoohack.me/&quot;&gt;hoohack&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>[PHP源码阅读]trim、rtrim、ltrim函数</title>
    <link href="https://hoohack.me/blog/2016/2016-05-20-php-source-code-trim-ltrim-rtrim/"/>
    <updated>2016-05-20T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-05-20-php-source-code-trim-ltrim-rtrim/</id>
    <content type="html">&lt;p&gt;trim系列函数是用于去除字符串中首尾的空格或其他字符。ltrim函数只去除掉字符串首部的字符，rtrim函数只去除字符串尾部的字符。&lt;/p&gt;
&lt;p&gt;我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/read-php-src/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/read-php-src/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
&lt;h1 id=&quot;trim&quot; tabindex=&quot;-1&quot;&gt;trim&lt;/h1&gt;
&lt;p&gt;string trim ( string $str [, string $character_mask = &amp;quot; &#92;t&#92;n&#92;r&#92;0&#92;x0B&amp;quot; ] )&lt;/p&gt;
&lt;h2 id=&quot;%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E&quot; tabindex=&quot;-1&quot;&gt;参数说明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;character_mask&lt;/strong&gt;
默认是&amp;quot; &#92;t&#92;n&#92;r&#92;0&#92;x0B&amp;quot;等空白字符。&lt;/p&gt;
&lt;p&gt;使用..可以指定一段范围的字符。此处要注意，&amp;quot;..&amp;quot;左右两边是一对合法的范围值，如果传递的是非法的值会报错。&lt;/p&gt;
&lt;h2 id=&quot;%E8%BF%90%E8%A1%8C%E7%A4%BA%E4%BE%8B&quot; tabindex=&quot;-1&quot;&gt;运行示例&lt;/h2&gt;
&lt;p&gt;先来看看用正常的使用：&lt;/p&gt;
&lt;p&gt;$str = &#39;hello..&#39;;
$new_str = trim($str, &#39;.&#39;); // 结果是hello&lt;/p&gt;
&lt;p&gt;一个比较诡异的结果。这里报错是因为php把..左右两边看作是范围值，而此处&#39;..&#39;左边是字符&#39;.&#39;，PHP内部将认为其是一个缺少右边界的范围值。&lt;/p&gt;
&lt;p&gt;$str = &#39;hello...&#39;;
$second_str = trim($str, &#39;...&#39;); // 报错&lt;/p&gt;
&lt;p&gt;第二个参数使用合法的边界值：&lt;/p&gt;
&lt;p&gt;$str = &#39;helloabcdefg&#39;;
$new_str = trim($str, &#39;a..g&#39;); // 输出hello&lt;/p&gt;
&lt;h2 id=&quot;trim%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4&quot; tabindex=&quot;-1&quot;&gt;trim执行步骤&lt;/h2&gt;
&lt;p&gt;trim、ltrim、rtrim三个函数都是调用了php_do_trim函数，区别在于第二个参数mode的不同。本文主要对trim函数进行分析，ltrim和rtrim函数跟trim的类似。然后php_do_trim会调用了php_trim来实现功能，因此trim函数的核心函数时php_trim函数。其执行步骤如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、根据what的值设置保存过滤字符的mask数组&lt;/p&gt;
&lt;p&gt;2、过滤在字符串首部的待过滤字符&lt;/p&gt;
&lt;p&gt;3、过滤在字符串尾部的待过滤字符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;php_trim函数执行的流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/trim.png&quot; alt=&quot;trim流程图&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB&quot; tabindex=&quot;-1&quot;&gt;源码解读&lt;/h2&gt;
&lt;p&gt;php_trim函数先调用了php_charmask，这个函数试将过滤字符设置为mask[char] = 1的形式，这样就是一个哈希数组，然后可用于后面的判断。如果第二个参数是范围值时，调用了memset函数给mask数组赋值。&lt;/p&gt;
&lt;p&gt;在用mode变量判断是哪种过滤时，此处有一个小优化，在PHP内部使用的是与运算，而不是多个的判断条件。该部分代码如下：&lt;/p&gt;
&lt;p&gt;if (mode &amp;amp; 1) {
for (i = 0; i &amp;lt; len; i++) {
if (mask[(unsigned char)c[i]]) {
trimmed++;
} else {
break;
}
}
len -= trimmed;
c += trimmed;
}
if (mode &amp;amp; 2) {
for (i = len - 1; i &amp;gt;= 0; i--) {
if (mask[(unsigned char)c[i]]) {
len--;
} else {
break;
}
}
}&lt;/p&gt;
&lt;p&gt;判断的过程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1 &amp;amp;&amp;amp; 1 == 1 左边需要过滤&lt;/p&gt;
&lt;p&gt;2 &amp;amp;&amp;amp; 1 == 0 左边不需要过滤&lt;/p&gt;
&lt;p&gt;3 &amp;amp;&amp;amp; 1 == 1 左边需要过滤&lt;/p&gt;
&lt;p&gt;1 &amp;amp;&amp;amp; 2 == 0 右边不需要过滤&lt;/p&gt;
&lt;p&gt;2 &amp;amp;&amp;amp; 2 == 1 右边需要过滤&lt;/p&gt;
&lt;p&gt;3 &amp;amp;&amp;amp; 2 == 1 右边需要过滤&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;像这样使用位操作可以提高程序的效率，而且代码更加简洁易读。&lt;/p&gt;
&lt;h2 id=&quot;%E5%B0%8F%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;阅读这个函数的源码，首先学习到在C语言中，如果需要做键值对数组，而且键值是单个字符，可以使用unsigned char的类型做数组下标，这样可以构造类似字符作为下标的映射数组。&lt;/p&gt;
&lt;p&gt;第二个就是使用位运算可以提高程序效率和代码可读性。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点下推荐吧，谢谢^_^&lt;/p&gt;
&lt;p&gt;最后再安利一下，我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/read-php-src/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/read-php-src/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>［PHP源码阅读］explode和implode函数</title>
    <link href="https://hoohack.me/blog/2016/2016-05-20-php-source-code-explode-implode/"/>
    <updated>2016-05-20T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-05-20-php-source-code-explode-implode/</id>
    <content type="html">&lt;p&gt;explode和implode函数主要用作字符串和数组间转换的操作，比如获取一段参数后根据某个字符分割字符串，或者将一个数组的结果使用一个字符合并成一个字符串输出。在PHP中经常会用到这两个函数，因此有必要了解一下其原理。&lt;/p&gt;
&lt;p&gt;我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/read-php-src/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/read-php-src/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
&lt;h2 id=&quot;explode&quot; tabindex=&quot;-1&quot;&gt;explode&lt;/h2&gt;
&lt;p&gt;array explode ( string $delimiter, string $string, [ , $limit ] )&lt;/p&gt;
&lt;p&gt;函数返回由字符串组成的数组，每个元素都是string的一个子串，被字符串$delimiter作为边界点分割出来。&lt;/p&gt;
&lt;h3 id=&quot;%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E&quot; tabindex=&quot;-1&quot;&gt;参数说明&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;limit&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果设置了limit，且为正数，则返回的数组最多包含limit个元素，最后的那个元素将包含string的剩余部分。&lt;/p&gt;
&lt;p&gt;如果limit是负数，则返回除了最后的-$limit个元素外的所有元素。&lt;/p&gt;
&lt;p&gt;如果limit是0，则会被当做1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;delimiter&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果delimiter为空，则函数返回FALSE。如果delimiter不在string中，且limit为负数，则返回空数组。&lt;/p&gt;
&lt;h3 id=&quot;%E8%BF%90%E8%A1%8C%E7%A4%BA%E4%BE%8B&quot; tabindex=&quot;-1&quot;&gt;运行示例&lt;/h3&gt;
&lt;p&gt;$str = &#39;hello,world,heiheihei,php&#39;;&lt;/p&gt;
&lt;p&gt;先来看看不设置limit的情况&lt;/p&gt;
&lt;p&gt;$arr = explode(&#39;,&#39;, $str);
print_r($arr);&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/6796-30c49b2b3d81bfb051e254017e4d76c4.jpg&quot; alt=&quot;运行结果1&quot; /&gt;&lt;/p&gt;
&lt;p&gt;limit为正数时，limit设为1，最多返回1个元素。&lt;/p&gt;
&lt;p&gt;$arr = explode(&#39;,&#39;, $str, 1);
print_r($arr);&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/4358-6ad1b98442b3ef5ea3d67b674b125713.jpg&quot; alt=&quot;运行结果2&quot; /&gt;&lt;/p&gt;
&lt;p&gt;limit为负数，limit为-1，返回最后的1个元素外的所有元素。&lt;/p&gt;
&lt;p&gt;$arr = explode(&#39;,&#39;, $str, -1);
print_r($arr);&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/4967-2e536e38a07189ef6dfc98509247c2c7.jpg&quot; alt=&quot;运行结果3&quot; /&gt;&lt;/p&gt;
&lt;p&gt;limit为0，当作1处理。&lt;/p&gt;
&lt;p&gt;$arr = explode(&#39;,&#39;, $str, 0);
print_r($arr);&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/4358-6ad1b98442b3ef5ea3d67b674b125713.jpg&quot; alt=&quot;运行结果4&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;explode%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4&quot; tabindex=&quot;-1&quot;&gt;explode执行步骤&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;1、接收参数，处理参数为空的情况&lt;/p&gt;
&lt;p&gt;2、创建函数中使用的局部变量&lt;/p&gt;
&lt;p&gt;3、根据limit的值调用不同的函数分隔字符串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/read-php-src/read-php-src/blob/master/ext/standard/string.c#L1094&quot;&gt;explode&lt;/a&gt;函数的核心实现是&lt;a href=&quot;https://github.com/read-php-src/read-php-src/blob/master/ext/standard/string.c#L1015&quot;&gt;php_explode&lt;/a&gt;函数，下面是该函数的执行流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/explode.png&quot; alt=&quot;explode流程&quot; /&gt;&lt;/p&gt;
&lt;p&gt;php_explode函数核心代码：&lt;/p&gt;
&lt;p&gt;if (p2 == NULL) {
// 找不到分隔符，直接返回整个字符串
add_next_index_stringl(return_value, p1, Z_STRLEN_P(str), 1);
} else {
do {
// 将p1添加到return_value数组中
add_next_index_stringl(return_value, p1, p2 - p1, 1);
p1 = p2 + Z_STRLEN_P(delim);
} while ((p2 = php_memnstr(p1, Z_STRVAL_P(delim), Z_STRLEN_P(delim), endp)) != NULL &amp;amp;&amp;amp;
--limit &amp;gt; 1);&lt;/p&gt;
&lt;p&gt;// 将最后一个值添加到return_value
if (p1 &amp;lt;= endp)
add_next_index_stringl(return_value, p1, endp-p1, 1);
}&lt;/p&gt;
&lt;h3 id=&quot;%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB&quot; tabindex=&quot;-1&quot;&gt;源码解读&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;sizeof(&amp;quot;&amp;quot;) == 0&lt;/strong&gt;。sizeof有两种用法，&lt;strong&gt;sizeof(typename)&lt;strong&gt;和&lt;/strong&gt;sizeof(expression)&lt;/strong&gt;，当参数为typename是，即类型名称，sizeof返回类型对应对象的大小；当参数为表达式时，sizeof计算表达式的返回类型对应对象的大小。此处，&amp;quot;&amp;quot;是表达式，sizeof计算编译时编译器分配给&amp;quot;&amp;quot;的空间，此时要算上&#92;0的长度，因此是1，而strlen函数不会计算&lt;code&gt;&#92;0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果不设置limit，limit的默认值是&lt;strong&gt;LONG_MAX&lt;/strong&gt;。在php.h文件中，LONG_MAX定义为2147483647L。&lt;/p&gt;
&lt;p&gt;在实现里面，如果limit大于1，则调用&lt;strong&gt;php_explode&lt;/strong&gt;函数；如果limit小于0，则调用&lt;strong&gt;php_explode_negative_limit&lt;/strong&gt;函数；如果limit等于0，则被当做1处理，此时调用&lt;strong&gt;add_index_stringl&lt;/strong&gt;函数将str添加到数组return_value中。&lt;/p&gt;
&lt;p&gt;在查找分隔符delimiter时，调用了&lt;strong&gt;php_memnstr&lt;/strong&gt;函数
php_memnstr(Z_STRVAL_P(str), Z_STRVAL_P(delim), Z_STRLEN_P(delim), endp);
而php_memnstr是&lt;strong&gt;zend_memnstr&lt;/strong&gt;的宏定义，zend_memnstr实现里面，因此实际上是调用了C里面的memchr来查找字符delimiter。&lt;/p&gt;
&lt;p&gt;找到分隔符的位置之后，就调用&lt;strong&gt;add_next_index_stringl&lt;/strong&gt;函数将分隔得到的字符串插入到返回数组里。&lt;/p&gt;
&lt;h2 id=&quot;implode&quot; tabindex=&quot;-1&quot;&gt;implode&lt;/h2&gt;
&lt;p&gt;string implode ( string $glue, array $pieces )
string implode ( array $pieces )&lt;/p&gt;
&lt;p&gt;将一个一维数组的值转换为字符串&lt;/p&gt;
&lt;h3 id=&quot;%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-1&quot; tabindex=&quot;-1&quot;&gt;参数说明&lt;/h3&gt;
&lt;p&gt;implode函数可以接收两种参数顺序。另外，如果第一个参数为数组而第二个参数为空，则第二个参数为默认值&#39;&#39;。此函数可以看作是explode的逆向过程。&lt;/p&gt;
&lt;p&gt;当然，使用文档规定的顺序可避免混淆。&lt;/p&gt;
&lt;h3 id=&quot;%E8%BF%90%E8%A1%8C%E7%A4%BA%E4%BE%8B-1&quot; tabindex=&quot;-1&quot;&gt;运行示例&lt;/h3&gt;
&lt;p&gt;$arr = array(&#39;hello&#39;, &#39;world&#39;);&lt;/p&gt;
&lt;p&gt;按照文档顺序参数&lt;/p&gt;
&lt;p&gt;$str = implode(&#39;-‘, $arr);// 输出&amp;quot;hello-world&amp;quot;&lt;/p&gt;
&lt;p&gt;第一个参数为数组&lt;/p&gt;
&lt;p&gt;$str = implode($arr); // 输出&amp;quot;helloworld&amp;quot;
$str = implode($arr, &#39;-&#39;); // 输出&amp;quot;hello-world&amp;quot;&lt;/p&gt;
&lt;h3 id=&quot;implode%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4&quot; tabindex=&quot;-1&quot;&gt;implode执行步骤&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;1、接收参数并赋值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;2、如果第二个参数为空，则判断第一个参数的类型是否为数组，如果不是，则报错。否则，则使用&amp;quot;&amp;quot;对glue赋值，使用其作为连接符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;3、如果第二个参数不为空，那么，如果第一个参数是数组类型，则将第二个参数转换成字符串类型；否则，如果第二个参数是数组类型，则将第一个参数转换成字符串类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;4、调用php_implode函数做字符串的连接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;https://github.com/read-php-src/read-php-src/blob/master/ext/standard/string.c#L1235&quot;&gt;implode&lt;/a&gt;函数设置完参数之后，底层就调用&lt;a href=&quot;https://github.com/read-php-src/read-php-src/blob/master/ext/standard/string.c#L1143&quot;&gt;php_implode&lt;/a&gt;函数进行字符串连接，php_implode函数的执行流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/implode.png&quot; alt=&quot;implode流程&quot; /&gt;&lt;/p&gt;
&lt;p&gt;php_implode函数核心代码：&lt;/p&gt;
&lt;p&gt;// 遍历数组的每一个元素，判断其类型，然后调用smart_str_appendl函数将值追加到字符串中
while (zend_hash_get_current_data_ex(Z_ARRVAL_P(arr), (void **) &amp;amp;tmp, &amp;amp;pos) == SUCCESS) {
switch ((*tmp)-&amp;gt;type) {
case IS_STRING:
smart_str_appendl(&amp;amp;implstr, Z_STRVAL_PP(tmp), Z_STRLEN_PP(tmp));
break;&lt;/p&gt;
&lt;p&gt;case IS_LONG: {
char stmp[MAX_LENGTH_OF_LONG + 1];
str_len = slprintf(stmp, sizeof(stmp), &amp;quot;%ld&amp;quot;, Z_LVAL_PP(tmp));
smart_str_appendl(&amp;amp;implstr, stmp, str_len);
}
break;&lt;/p&gt;
&lt;p&gt;case IS_BOOL:
if (Z_LVAL_PP(tmp) == 1) {
smart_str_appendl(&amp;amp;implstr, &amp;quot;1&amp;quot;, sizeof(&amp;quot;1&amp;quot;)-1);
}
break;&lt;/p&gt;
&lt;p&gt;case IS_NULL:
break;&lt;/p&gt;
&lt;p&gt;case IS_DOUBLE: {
char *stmp;
str_len = spprintf(&amp;amp;stmp, 0, &amp;quot;%.*G&amp;quot;, (int) EG(precision), Z_DVAL_PP(tmp));
smart_str_appendl(&amp;amp;implstr, stmp, str_len);
efree(stmp);
}
break;&lt;/p&gt;
&lt;p&gt;case IS_OBJECT: {
int copy;
zval expr;
zend_make_printable_zval(*tmp, &amp;amp;expr, &amp;amp;copy);
smart_str_appendl(&amp;amp;implstr, Z_STRVAL(expr), Z_STRLEN(expr));
if (copy) {
zval_dtor(&amp;amp;expr);
}
}
break;&lt;/p&gt;
&lt;p&gt;default:
tmp_val = **tmp;
zval_copy_ctor(&amp;amp;tmp_val);
convert_to_string(&amp;amp;tmp_val);
smart_str_appendl(&amp;amp;implstr, Z_STRVAL(tmp_val), Z_STRLEN(tmp_val));
zval_dtor(&amp;amp;tmp_val);
break;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;// 添加glue字符
if (++i != numelems) {
smart_str_appendl(&amp;amp;implstr, Z_STRVAL_P(delim), Z_STRLEN_P(delim));
}
zend_hash_move_forward_ex(Z_ARRVAL_P(arr), &amp;amp;pos);
}
// 在尾部添加结束字符0
smart_str_0(&amp;amp;implstr);&lt;/p&gt;
&lt;h3 id=&quot;%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-1&quot; tabindex=&quot;-1&quot;&gt;源码解读&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;php_implode&lt;/code&gt;会逐个获取数组里面的内容，然后判断每个元素的类型，再做必要的数据类型转换之后，调用smart_str_appendl函数将值追加到返回的字符串后面。最后，还要在字符串后面加上结束符，这是个必须的操作，以后编程时也应注意。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/read-php-src/read-php-src/blob/master/ext/standard/php_smart_str.h#L85&quot;&gt;smart_str_appendl&lt;/a&gt;是函数&lt;a href=&quot;https://github.com/read-php-src/read-php-src/blob/master/ext/standard/php_smart_str.h#L112&quot;&gt;smart_str_appendl_ex&lt;/a&gt;的宏定义，该函数调用了&lt;strong&gt;memcpy&lt;/strong&gt;做字符串的复制。&lt;/p&gt;
&lt;h2 id=&quot;%E5%B0%8F%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;暂且写这么多，还有更多的优化和PHP源码中常用的函数，将会在以后的源码阅读中慢慢讲述。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点下推荐吧，谢谢^_^&lt;/p&gt;
&lt;p&gt;最后再安利一下，我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/read-php-src/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/read-php-src/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>［PHP源码阅读］strpos、strstr和stripos、stristr函数</title>
    <link href="https://hoohack.me/blog/2016/2016-05-10-php-source-code-strpos-strstr-stripos-stristr/"/>
    <updated>2016-05-10T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-05-10-php-source-code-strpos-strstr-stripos-stristr/</id>
    <content type="html">&lt;p&gt;我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/read-php-src/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/read-php-src/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
&lt;h1 id=&quot;strpos&quot; tabindex=&quot;-1&quot;&gt;strpos&lt;/h1&gt;
&lt;p&gt;mixed strpos ( string $haystack, mixed $needle [, int $offset = 0 ] )&lt;/p&gt;
&lt;p&gt;如果offset指定了，查找会从offset的位置开始。offset不能为负数。&lt;/p&gt;
&lt;p&gt;返回needle第一次出现在haystack的位置。如果在haystack中找不到needle，则返回FALSE。&lt;/p&gt;
&lt;p&gt;needle，如果needle不是字符串，它会被转换成整型数值并赋值为该数值的ASCII字符。请看下面例子。&lt;/p&gt;
&lt;h2 id=&quot;%E4%BE%8B%E5%AD%90&quot; tabindex=&quot;-1&quot;&gt;例子&lt;/h2&gt;
&lt;p&gt;$str = &amp;quot;hello&amp;quot;;
$pos = strpos($str, 111);
// 111的ASCII值是o，因此$pos = 4&lt;/p&gt;
&lt;h2 id=&quot;strpos%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81&quot; tabindex=&quot;-1&quot;&gt;strpos核心源码&lt;/h2&gt;
&lt;p&gt;if (Z_TYPE_P(needle) == IS_STRING) {
if (!Z_STRLEN_P(needle)) {
php_error_docref(NULL TSRMLS_CC, E_WARNING, &amp;quot;Empty needle&amp;quot;);
RETURN_FALSE;
}&lt;/p&gt;
&lt;p&gt;// 调用php_memnstr函数查找needle
found = php_memnstr(haystack + offset,
Z_STRVAL_P(needle),
Z_STRLEN_P(needle),
haystack + haystack_len);
} else {
// 如果不是字符串，转换成数字并赋值为该数字的ASCII字符。
if (php_needle_char(needle, needle_char TSRMLS_CC) != SUCCESS) {
RETURN_FALSE;
}
//设置结束字符
needle_char[1] = 0;
found = php_memnstr(haystack + offset,
needle_char,
1,
haystack + haystack_len);
　　  }
}&lt;/p&gt;
&lt;p&gt;有一点要注意的是，如果needle不是字符串的话，会调用&lt;strong&gt;php_needle_char&lt;/strong&gt;函数将needle转成整型数字并转换为其ASCII值。&lt;/p&gt;
&lt;h2 id=&quot;%E6%9F%A5%E6%89%BE%E5%87%BD%E6%95%B0&quot; tabindex=&quot;-1&quot;&gt;查找函数&lt;/h2&gt;
&lt;p&gt;函数最后返回的是found，&lt;strong&gt;php_memnstr&lt;/strong&gt;函数实现了查找的方法。那么再继续看看php_memnstr函数做了什么：&lt;/p&gt;
&lt;p&gt;#define php_memnstr zend_memnstr&lt;/p&gt;
&lt;p&gt;php_memnstr是函数&lt;strong&gt;zend_memnstr&lt;/strong&gt;的宏定义，查看zend_memnstr函数如下：&lt;/p&gt;
&lt;p&gt;static inline char *
zend_memnstr(char *haystack, char *needle, int needle_len, char *end)
{
char *p = haystack;
char ne = needle[needle_len-1];
if (needle_len == 1) {
return (char *)memchr(p, *needle, (end-p));
}&lt;/p&gt;
&lt;p&gt;if (needle_len &amp;gt; end-haystack) {
return NULL;
}&lt;/p&gt;
&lt;p&gt;// 第一个优化，只查找end - needle_len次
end -= needle_len;&lt;/p&gt;
&lt;p&gt;while (p &amp;lt;= end) {
// 第二个优化，先判断字符串的开头和结尾是否一样再判断整个字符串
if ((p = (char *)memchr(p, *needle, (end-p+1))) &amp;amp;&amp;amp; ne == p[needle_len-1]) {
if (!memcmp(needle, p, needle_len-1)) {
return p;
}
}&lt;/p&gt;
&lt;p&gt;if (p == NULL) {
return NULL;
}&lt;/p&gt;
&lt;p&gt;p++;
}&lt;/p&gt;
&lt;p&gt;return NULL;
}&lt;/p&gt;
&lt;p&gt;第一个优化，因为&lt;code&gt;(char *)memchr(p, *needle, (end-p+1)&lt;/code&gt;是在end - needle_len + 1（即haystack_len+1）中查找，如果p为空，说明needle的第一个字符在p中从未出现过。&lt;/p&gt;
&lt;h1 id=&quot;strstr&quot; tabindex=&quot;-1&quot;&gt;strstr&lt;/h1&gt;
&lt;p&gt;string strstr ( string $haystack, mixed $needle [, bool $before_needle = false ] )
返回needle在haystack中第一次出现的位置到结束的字符串。&lt;/p&gt;
&lt;p&gt;这个函数的区分大小写的。&lt;/p&gt;
&lt;p&gt;如果needle在haystack中不存在，返回FALSE。&lt;/p&gt;
&lt;p&gt;如果before_needle为true，则返回haystack中needle在haystack第一次出现的位置之前的字符串。&lt;/p&gt;
&lt;h2 id=&quot;strstr%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81&quot; tabindex=&quot;-1&quot;&gt;strstr核心源码&lt;/h2&gt;
&lt;p&gt;if (found) {
// 计算出found的位置
found_offset = found - haystack;
if (part) {
RETURN_STRINGL(haystack, found_offset, 1);
} else {
RETURN_STRINGL(found, haystack_len - found_offset, 1);
}
}&lt;/p&gt;
&lt;p&gt;strstr函数的前半部分跟strpos类似，区别在于strstr函数在找到位置后，需要返回haystack部分的字符串。part变量就是调用strstr函数时传递的before_needle变量。&lt;/p&gt;
&lt;h1 id=&quot;stripos&quot; tabindex=&quot;-1&quot;&gt;stripos&lt;/h1&gt;
&lt;p&gt;mixed stripos ( string $haystack, string $needle [, int $offset = 0 ] )
不区分大小写的strpos。实现方式跟下面的类似，主要是使用一份拷贝然后将需要比较的字符串转换成小写字符后进行再进行查找。&lt;/p&gt;
&lt;h1 id=&quot;stristr&quot; tabindex=&quot;-1&quot;&gt;stristr&lt;/h1&gt;
&lt;p&gt;string stristr ( string $haystack, mixed $needle [, bool $before_needle = false ] )
不区分大小写的strstr。&lt;/p&gt;
&lt;h2 id=&quot;%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81&quot; tabindex=&quot;-1&quot;&gt;核心源码&lt;/h2&gt;
&lt;p&gt;// 拷贝一份haystack
haystack_dup = estrndup(haystack, haystack_len);&lt;/p&gt;
&lt;p&gt;if (Z_TYPE_P(needle) == IS_STRING) {
char *orig_needle;
if (!Z_STRLEN_P(needle)) {
php_error_docref(NULL TSRMLS_CC, E_WARNING, &amp;quot;Empty needle&amp;quot;);
efree(haystack_dup);
RETURN_FALSE;
}
orig_needle = estrndup(Z_STRVAL_P(needle), Z_STRLEN_P(needle));
// 调用php_stristr函数找出orig_needle的值。
found = php_stristr(haystack_dup, orig_needle,    haystack_len, Z_STRLEN_P(needle));
efree(orig_needle);
} else {
if (php_needle_char(needle, needle_char TSRMLS_CC) != SUCCESS) {
efree(haystack_dup);
RETURN_FALSE;
}
needle_char[1] = 0;&lt;/p&gt;
&lt;p&gt;found = php_stristr(haystack_dup, needle_char,    haystack_len, 1);
}&lt;/p&gt;
&lt;p&gt;if (found) {
found_offset = found - haystack_dup;
if (part) {
RETVAL_STRINGL(haystack, found_offset, 1);
} else {
RETVAL_STRINGL(haystack + found_offset, haystack_len - found_offset, 1);
}
} else {
RETVAL_FALSE;
}&lt;/p&gt;
&lt;p&gt;// 释放变量
efree(haystack_dup);&lt;/p&gt;
&lt;p&gt;可以知道，found是从php_stristr中得到的，继续查看php_stristr函数：&lt;/p&gt;
&lt;p&gt;PHPAPI char *php_stristr(char *s, char *t, size_t s_len, size_t t_len)
{
php_strtolower(s, s_len);
php_strtolower(t, t_len);
return php_memnstr(s, t, t_len, s + s_len);
}
这个函数的功能就是将字符串都转成小写之后调用php_mennstr函数来查找needle在haystack第一次出现的位置。&lt;/p&gt;
&lt;h1 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h1&gt;
&lt;p&gt;因为strpos/stripos返回的是位置，位置从0开始计算，所以判断查找失败都用&lt;code&gt;=== FALSE&lt;/code&gt;更适合。&lt;/p&gt;
&lt;p&gt;阅读PHP的源码收获挺多，一方面可以知道某个函数的具体实现原理是怎样的，另一方面可以学习到一些编程优化方案。&lt;/p&gt;
&lt;p&gt;到此本文结束，如果还有什么疑问或者建议，可以多多交流，原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/read-php-src/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/read-php-src/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>［搜索引擎］搜索引擎索引数据结构和算法</title>
    <link href="https://hoohack.me/blog/2016/2016-05-09-datasture-and-algorithm-of-search-engine/"/>
    <updated>2016-05-09T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-05-09-datasture-and-algorithm-of-search-engine/</id>
    <content type="html">&lt;p&gt;最近一直在研究sphinx的工作机制，在［搜索引擎］Sphinx的介绍和原理探索简单地介绍了其工作原理之后，还有很多问题没有弄懂，比如底层的数据结构和算法，于是更进一步地从数据结构层面了解其工作原理。在网上搜了很多资料，发现没有很多介绍这方面的文章，后来找到了一本书，《这就是搜索引擎》，拜读了本书的第三章，介绍了主流搜索引擎用的数据结构及其工作原理，sphinx使用的数据结构也是一样的，用的也是倒排索引。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：本文不会对sphinx和搜索引擎严格区分开，同一作搜索引擎看待。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先附图一枚：
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%B4%A2%E5%BC%95.png&quot; alt=&quot;搜索引擎索引&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;%E7%B4%A2%E5%BC%95%E5%9F%BA%E7%A1%80&quot; tabindex=&quot;-1&quot;&gt;索引基础&lt;/h1&gt;
&lt;p&gt;先介绍与搜索引擎有关的一些基本概念，了解这些概念对后续了解工作机制非常重要。&lt;/p&gt;
&lt;h2 id=&quot;%E5%8D%95%E8%AF%8D-%E6%96%87%E6%A1%A3%E7%9F%A9%E9%98%B5&quot; tabindex=&quot;-1&quot;&gt;单词-文档矩阵&lt;/h2&gt;
&lt;p&gt;单词-文档矩阵是表达两者之间所具有的一种包含关系的概念模型。如下图所示，每列代表一个文档，每行代表一个单词，打对钩的位置代表包含关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E5%8D%95%E8%AF%8D-%E6%96%87%E6%A1%A3%E7%9F%A9%E9%98%B5.png&quot; alt=&quot;单词文档矩阵&quot; /&gt;&lt;/p&gt;
&lt;p&gt;从纵向看，可以得知每列代表文档包含了哪些单词；从横向看，每行代表了哪些文档包含了某个单词。搜索引擎的索引其实就是实现单词-文档矩阵的具体数据结构。可以有不同的方式来实现上述概念模型，比如倒排索引、签名文件、后缀树等方式。但实验数据表明，倒排索引是单词到文档映射关系的最佳实现方式。&lt;/p&gt;
&lt;h2 id=&quot;%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5&quot; tabindex=&quot;-1&quot;&gt;倒排索引基本概念&lt;/h2&gt;
&lt;p&gt;文档（Document）：以文本形式存在的存储对象。如：网页、Word、PDF、XML等不同格式的文件。&lt;/p&gt;
&lt;p&gt;文档集合（Document Collection）：若干文档构成的集合。如：大量的网页。&lt;/p&gt;
&lt;p&gt;文档编号（Document ID）：搜索引擎内部，唯一标识文档的唯一编号。&lt;/p&gt;
&lt;p&gt;单词编号（Word ID）：搜索引擎内部，唯一标识单词的唯一编号。&lt;/p&gt;
&lt;p&gt;倒排索引（Inverted Index）：实现单词--文档矩阵的一种具体存储形式。倒排索引主要有单词词典和倒排文件组成。&lt;/p&gt;
&lt;p&gt;单词词典（Lexicon）：文档集合中出现过的所有单词构成的字符串集合，单词词典内每条索引项记载单
词本身的一些信息及指向倒排列表的指针。&lt;/p&gt;
&lt;p&gt;倒排列表（PostingList）：出现了某个单词的所有文档的文档列表及单词在该文档中出现的位置信息。
列表中每条记录称为一个倒排项（Posting）。&lt;/p&gt;
&lt;p&gt;倒排文件（Inverted File）：保存所有单词的倒排列表的文件，倒排文件是存储倒排索引的物理文件。&lt;/p&gt;
&lt;p&gt;概念之间的关系如图：.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%85%B3%E7%B3%BB%E5%9B%BE.png&quot; alt=&quot;基本概念关系图&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B&quot; tabindex=&quot;-1&quot;&gt;倒排索引简单实例&lt;/h2&gt;
&lt;p&gt;下面举一个实例，这样对倒排索引有一个更直观的感受。&lt;/p&gt;
&lt;p&gt;假设文档集合包含5个文档，每个文档内容如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E6%96%87%E6%A1%A3%E5%86%85%E5%AE%B9.png&quot; alt=&quot;文档内容&quot; /&gt;&lt;/p&gt;
&lt;p&gt;建立的倒排索引如下图：
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E4%BE%8B%E5%AD%90.png&quot; alt=&quot;倒排索引例子&quot; /&gt;&lt;/p&gt;
&lt;p&gt;单词ID：记录每个单词的单词编号；&lt;/p&gt;
&lt;p&gt;单词：对应的单词；&lt;/p&gt;
&lt;p&gt;文档频率：代表再文档集合中有多少个文档包含某个单词&lt;/p&gt;
&lt;p&gt;倒排列表：包含单词ID及其他必要信息&lt;/p&gt;
&lt;p&gt;TF：单词在某个文档中出现的次数&lt;/p&gt;
&lt;p&gt;POS：单词在文档中出现的位置&lt;/p&gt;
&lt;p&gt;以单词“加盟”为例，其单词编号为6，文档频率为3，代表整个文档集合中有三个文档包含这个单词，对应的倒排列表为&lt;code&gt;{(2;1;&amp;lt;4&amp;gt;),(3;1;&amp;lt;7&amp;gt;),(5;1;&amp;lt;5&amp;gt;)}&lt;/code&gt;，含义是在文档2，3，5出现过这个单词，在每个文档的出现过1次，单词“加盟”在第一个文档的POS是4，即文档的第四个单词是“加盟”，其他的类似。&lt;/p&gt;
&lt;p&gt;这个倒排索引已经是一个非常完备的索引系统，实际搜索系统的索引结构基本如此。&lt;/p&gt;
&lt;h1 id=&quot;%E5%8D%95%E8%AF%8D%E8%AF%8D%E5%85%B8&quot; tabindex=&quot;-1&quot;&gt;单词词典&lt;/h1&gt;
&lt;p&gt;单词词典用来维护文档集合中出现过的所有单词的相关信息，同时用来记载某个单词对应的倒排列表在倒排文件中的位置信息。在查询时到单词词典里查询，就能获得相应的倒排列表，并以此作为后序排序的基础。&lt;/p&gt;
&lt;p&gt;常用数据结构：哈希加链表和树形词典结构。&lt;/p&gt;
&lt;h2 id=&quot;%E5%93%88%E5%B8%8C%E5%8A%A0%E9%93%BE%E8%A1%A8&quot; tabindex=&quot;-1&quot;&gt;哈希加链表&lt;/h2&gt;
&lt;p&gt;下图是哈希加链表词典结构的示意图。主体是哈希表，每个哈希表项保存一个指针，指针指向冲突连表，相同哈希值的单词形成链表结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E5%93%88%E5%B8%8C%E5%8A%A0%E9%93%BE%E8%A1%A8%E8%AF%8D%E5%85%B8%E7%BB%93%E6%9E%84.png&quot; alt=&quot;哈希加链表词典结构&quot; /&gt;&lt;/p&gt;
&lt;p&gt;构建过程：&lt;/p&gt;
&lt;p&gt;对文档进行分词；
对于做好的分词，利用哈希函数获取哈希值；
根据哈希值对应的哈希表项找到对应的冲突链表；
如果冲突链表已经存在该单词
　　不处理
否则
　　加入冲突连表&lt;/p&gt;
&lt;h2 id=&quot;%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84&quot; tabindex=&quot;-1&quot;&gt;树形结构&lt;/h2&gt;
&lt;p&gt;使用B树或者B+树的结构。与哈希表不同的是，需要字典项能按照大小排序，即使用数字或字符序。
树形结构中，使用层级查找，中间节点保存一定顺序范围的词典项目存储在哪个子树中，最底层的叶子节点存储单词的地址信息。&lt;/p&gt;
&lt;h1 id=&quot;%E5%80%92%E6%8E%92%E5%88%97%E8%A1%A8&quot; tabindex=&quot;-1&quot;&gt;倒排列表&lt;/h1&gt;
&lt;p&gt;倒排列表用来记录哪些文档包含了某个单词。倒排列表由倒排索引项组成，每个倒排索引项由文档ID，单词出现次数TD以及单词在文档中哪些位置出现过等信息。包含某单词的一些列倒排索引项形成了某个单词对应的倒排列表。下图是倒排列表示意图：
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E5%80%92%E6%8E%92%E5%88%97%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png&quot; alt=&quot;倒排列表示意图&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95&quot; tabindex=&quot;-1&quot;&gt;建立索引&lt;/h1&gt;
&lt;p&gt;前面介绍了索引结构，那么，有了数据之后索引是怎么建立的呢？主要有三种建立索引的方法。&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%A4%E9%81%8D%E6%96%87%E6%A1%A3%E9%81%8D%E5%8E%86%E6%B3%95%EF%BC%882-pass-in-memory-inversion%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;两遍文档遍历法（2-Pass In-Memory Inversion）&lt;/h2&gt;
&lt;p&gt;此方法在内存里完成索引的创建过程。要求内存要足够大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一遍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;收集一些全局的统计信息。包括文档集合包含的文档个数N，文档集合内所包含的不同单词个数M，每个单词在多少个文档中出现过的信息DF。&lt;/p&gt;
&lt;p&gt;将所有单词对应的DF值全部相加，就可以知道建立最终索引所需的内存大小是多少。
获取信息后，根据统计信息分配内存等资源，同事建立好单词相对应倒排列表在内存中的位置信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二遍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;逐个单词建立倒排列表信息。获得包含某个单词的每个文档的文档ID，以及这个单词在文档中的出现次数TF，然后不断填充第一遍扫描时所分配的内存。当第二遍扫描结束的时候，分配的内存正好被填充满，每个单词用指针所指向的内存区域“片段”，其起始位置和终止位置之间的数据就是这个单词对应的倒排列表。&lt;/p&gt;
&lt;h2 id=&quot;%E6%8E%92%E5%BA%8F%E6%B3%95%EF%BC%88sort-based-inversion%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;排序法（Sort-based Inversion）&lt;/h2&gt;
&lt;p&gt;在建立索引过程中，始终在内存中分配固定大小的空间，用来存放词典信息和索引的中间结果，当分配的空间被消耗光的时候，把中间结果写入磁盘，清空内存里中间结果所占空间，以用做下一轮存放索引中间结果的存储区。参考下图：
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E6%8E%92%E5%BA%8F%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png&quot; alt=&quot;排序法示意图&quot; /&gt;&lt;/p&gt;
&lt;p&gt;上图是排序法建立索引中间结果的示意图。建立过程：&lt;/p&gt;
&lt;p&gt;读入文档后，对文档进行编号，赋予唯一的文档ID，并对文档内容解析；
将单词映射为单词ID；
建立（单词ID、文档ID、单词频率）三元组；
将三元组追加进中间结果存储区末尾；
然后依次序处理下一个文档；
当分配的内存定额被占满时，则对中间结果进行排序（根据单词ID-&amp;gt;文档ID的排序原则）；
将排好序的三元组写入磁盘文件中。&lt;/p&gt;
&lt;p&gt;注：在排序法建立索引的过程中，词典是一直存储在内存中的，由于分配内存是固定大小，渐渐地词典占用内存越来越大，那么，越往后，可用来存储三元组的空间越来越少。&lt;/p&gt;
&lt;p&gt;建立好索引后，需要合并。&lt;/p&gt;
&lt;p&gt;合并时，系统为每个中间结果文件在内存中开辟一个数据缓冲区，用来存放文件的部分数据。将不同缓冲区中包含的同一个单词ID的三元组进行合并，如果某个单词ID的所有三元组全部合并完成，说明这个单词的倒排列表已经构建完成，则将其写入最终索引中，同事将各个缓冲区中对应这个单词ID的三元组内容清空。缓冲区继续从中间结果文件读取后续的三元组进行下一轮合并。当所有中间结果文件都依次被读入缓冲区，并合并完成后，形成最终的索引文件。&lt;/p&gt;
&lt;h2 id=&quot;%E5%BD%92%E5%B9%B6%E6%B3%95%EF%BC%88merge-based-inversion%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;归并法（Merge-based Inversion）&lt;/h2&gt;
&lt;p&gt;归并法与排序法类似，不同的是，每次将内存中数据写入磁盘时，包括词典在内的所有中间结果都被写入磁盘，这样内存所有内容都可以被清空，后续建立索引可以使用全部的定额内存。归并法的示意图如下所示：
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E5%BD%92%E5%B9%B6%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png&quot; alt=&quot;归并法示意图&quot; /&gt;&lt;/p&gt;
&lt;p&gt;与排序法的差异：&lt;/p&gt;
&lt;p&gt;1、排序法在内存中存放的是词典信息和三元组数据，词典和三元组数据并没有直接的联系，词典只是为了将单词映射为单词ID。归并法则是在内存中建立一个完整的内存索引结构，是最终文章索引的一部分。&lt;/p&gt;
&lt;p&gt;2、在将中间结果写入磁盘临时文件时，归并法将这个内存的倒排索引写入临时文件，随后彻底清空所占内存。而排序法只是将三元组数据排序后写入磁盘临时文件，词典作为一个映射表一直存储在内存中。&lt;/p&gt;
&lt;p&gt;3、合并时，排序法是对同一单词的三元组依次进行合并；归并法的临时文件则是每个单词对应的部分倒排列表，所以在合并时针对每个单词的倒排列表进行合并，形成这个单词的最终倒排列表。&lt;/p&gt;
&lt;h1 id=&quot;%E5%8A%A8%E6%80%81%E7%B4%A2%E5%BC%95&quot; tabindex=&quot;-1&quot;&gt;动态索引&lt;/h1&gt;
&lt;p&gt;在真实环境中，搜索引擎需要处理的文档集合内有些文档可能被删除或者内容被修改。如果要在内容被删除或修改之后马上在搜索结果中体现出来，动态索引可以实现这种实时性需求。动态索引有三个关键的索引结构：倒排索引、临时索引和已删除文档列表。&lt;/p&gt;
&lt;p&gt;临时索引：在内存中实时建立的倒排索引，当有新文档进入系统时，实时解析文档并将其追加进这个临时索引结构中。&lt;/p&gt;
&lt;p&gt;已删除列表：存储已被删除的文档的相应文档ID，形成一个文档ID列表。当文档被修改时，可以认为先删除旧文档，然后向系统增加一篇新文档，通过这种间接方式实现对内容更改的支持。&lt;/p&gt;
&lt;p&gt;当系统发现有新文档进入时，立即将其加入临时索引中。有新文档被删除时，将其加入删除文档队列。文档被更改时，则将原先文档放入删除队列，解析更改后的文档内容，并将其加入临时索引。这样就可以满足实时性的要求。&lt;/p&gt;
&lt;p&gt;在处理用户的查询请求时，搜索引擎同时从倒排索引和临时索引中读取用户查询单词的倒排列表，找到包含用户查询的文档集合，并对两个结果进行合并，之后利用删除文档列表进行过滤，将搜索结果中那些已经被删除的文档从结果中过滤，形成最终的搜索结果，并返回给用户。&lt;/p&gt;
&lt;h1 id=&quot;%E7%B4%A2%E5%BC%95%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5&quot; tabindex=&quot;-1&quot;&gt;索引更新策略&lt;/h1&gt;
&lt;p&gt;动态索引可以满足实时搜索的需求，但是随着加入文档越来越多，临时索引消耗的内存也会随之增加。因此要考虑将临时索引的内容更新到磁盘索引中，以释放内存空间来容纳后续的文档，此时就需要考虑合理有效的索引更新策略。&lt;/p&gt;
&lt;h2 id=&quot;%E5%AE%8C%E5%85%A8%E9%87%8D%E5%BB%BA%E7%AD%96%E7%95%A5%EF%BC%88complete-re-build%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;完全重建策略（Complete Re-Build）&lt;/h2&gt;
&lt;p&gt;对所有文档重新建立索引。新索引建立完成后，老的索引被遗弃释放，之后对用户查询的响应完全由新的索引负责。在重建过程中，内存中仍然需要维护老的索引对用户的查询做出响应。如图所示
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E5%AE%8C%E5%85%A8%E9%87%8D%E5%BB%BA%E7%AD%96%E7%95%A5.png&quot; alt=&quot;完全重建策略&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E5%86%8D%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5%EF%BC%88re-merge%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;再合并策略（Re-Merge）&lt;/h2&gt;
&lt;p&gt;有新文档进入搜索系统时，搜索系统在内存维护临时倒排索引来记录其信息，当新增文档达到一定数量，或者指定大小的内存被消耗完，则把临时索引和老文档的倒排索引进行合并，以生成新的索引。过程如下图所示：
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E5%86%8D%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5.png&quot; alt=&quot;再合并策略&quot; /&gt;&lt;/p&gt;
&lt;p&gt;更新步骤：&lt;/p&gt;
&lt;p&gt;1、当新增文档进入系统，解析文档，之后更新内存中维护的临时索引，文档中出现的每个单词，在其倒排列表末尾追加倒排列表项，这个临时索引可称为增量索引&lt;/p&gt;
&lt;p&gt;2、一旦增量索引将指定的内存消耗光，增量索引和老的倒排索引内容需要进行合并。&lt;/p&gt;
&lt;p&gt;高效的原因：在对老的倒排索引进行遍历时，因为已经按照索引单词的词典序由低到高排好顺序，所以可以顺序读取文件内容，减少磁盘寻道时间。&lt;/p&gt;
&lt;p&gt;缺点：因为要生成新的倒排索引文件，所以老索引中的倒排列表没发生变化也需要读出来并写入新索引中。增加了I/O的消耗。&lt;/p&gt;
&lt;h2 id=&quot;%E5%8E%9F%E5%9C%B0%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%EF%BC%88in-place%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;原地更新策略（In-Place）&lt;/h2&gt;
&lt;p&gt;原地更新策略的出发点是为了解决再合并策略的缺点。&lt;/p&gt;
&lt;p&gt;在索引合并时，并不生成新的索引文件，而是直接在原先老的索引文件里进行追加操作，将增量索引里单词的倒排列表项追加到老索引相应位置的末尾，这样就可达到上述目标，即只更新增量索引里出现的单词相关信息，其他单词相关信息不变动。&lt;/p&gt;
&lt;p&gt;为了能够支持追加操作，原地更新策略在初始建立的索引中，会在每个单词的倒排列表末尾预留出一定的磁盘空间，这样，在进行索引合并时，可以将增量索引追加到预留空间中。如下图：
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E5%8E%9F%E5%9C%B0%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5.png&quot; alt=&quot;原地更新策略&quot; /&gt;&lt;/p&gt;
&lt;p&gt;实验数据证明，原地更新策略的索引更新效率比再合并策略低，原因：
1、由于需要做快速迁移，此策略需要对磁盘可用空间进行维护和管理，成本非常高。
2、做数据迁移时，某些单词及其对应倒排列表会从老索引中移出，破坏了单词连续性，因此需要维护一个单词到其倒排文件相应位置的映射表。降低了磁盘读取速度及消耗大量内存（存储映射信息）。&lt;/p&gt;
&lt;h2 id=&quot;%E6%B7%B7%E5%90%88%E7%AD%96%E7%95%A5%EF%BC%88hybrid%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;混合策略（Hybrid）&lt;/h2&gt;
&lt;p&gt;将单词根据其不同性质进行分类，不同类别的单词，对其索引采取不同的索引更新策略。常见做法：根据单词的倒排列表长度进行区分，因为有些单词经常在不同文档中出现，所以其对应的倒排列表较长，而有些单词很少见，则其倒排列表就较短。根据这一性质将单词划分为长倒排列表单词和短倒排列表单词。长倒排列表单词采取原地更新策略，而短倒排列表单词则采取再合并策略。&lt;/p&gt;
&lt;p&gt;因为长倒排列表单词的读/写开销明显比短倒排列表单词大很多，所以采用原地更新策略能节省磁盘读/写次数。而大量短倒排列表单词读/写开销相对而言不算太大，所以利用再合并策略来处理，则其顺序读/写优势也能被充分利用。&lt;/p&gt;
&lt;h1 id=&quot;%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86&quot; tabindex=&quot;-1&quot;&gt;查询处理&lt;/h1&gt;
&lt;p&gt;建立好索引之后，如何用倒排索引来响应用户的查询呢？主要有下面三种查询处理机制。&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%80%E6%AC%A1%E4%B8%80%E6%96%87%E6%A1%A3%EF%BC%88doc-at-a-time%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;一次一文档（Doc at a Time）&lt;/h2&gt;
&lt;p&gt;以倒排列表中包含的文档为单位，每次将其中某个文档与查询的最终相似性得分计算完毕，然后开始计算另外一个文档的最终得分，直到所有文档的得分计算完毕为止。然后根据文档得分进行大小排序，输出得分最高的K个文档作为搜索结果输出，即完成了一次用户查询的响应。实际实现中，只需在内存中维护一个大小为K的优先级队列。如下图所示是一次一文档的计算机制示意图：
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E4%B8%80%E6%AC%A1%E4%B8%80%E6%96%87%E6%A1%A3.png&quot; alt=&quot;一次一文档&quot; /&gt;&lt;/p&gt;
&lt;p&gt;虚线箭头标出查询处理计算的前进方向。查询时，对于文档1而言，因为两个单词的倒排列表中都包含这个文档，所以可以根据各自的TF和IDF等参数计算文档和查询单词的相似性，之后将两个分数相加得到文档1和用户查询的相似性得分Score1。其他的也是类似计算。最后根据文档得分进行大小排序，输出得分最高的K隔文档作为搜索结果输出。&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%80%E6%AC%A1%E4%B8%80%E5%8D%95%E8%AF%8D%EF%BC%88term-at-a-time%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;一次一单词（Term at a Time）&lt;/h2&gt;
&lt;p&gt;与一次一文档不同，一次一单词采取“先横向再纵向”的方式，首先将某个单词对应的倒排列表中的每个文档ID都计算一个部分相似性得分，也就是说，在单词-文档矩阵中首先进行横向移动，在计算完某个单词倒排列表中包含的所有文档后，接着计算下一个单词倒排列表中包含的文档ID，即进行纵向计算，如果发现某个文档ID已经有了得分，则在原先得分基础上累加。当所有单词都处理完毕后，每个文档最终的相似性得分计算结束，之后按照大小排序，输出得分最高的K个文档作为搜索结果。 下图是一次一单词的运算机制。
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E4%B8%80%E6%AC%A1%E4%B8%80%E5%8D%95%E8%AF%8D.png&quot; alt=&quot;一次一单词&quot; /&gt;&lt;/p&gt;
&lt;p&gt;虚线箭头指示出了计算的前进方向，为了保存数据，在内存中使用哈希表来保存中间结果及最终计算结果。在查询时，对于文档1，根据TD和IDF等参数计算这个文档对”搜索引擎“的相似性得分，之后根据文档ID在哈希表中查找，并把相似性得分保存在哈希表中。依次对其他文档计算后，开始下一个单词（此处是”技术“）的相似性得分的计算。计算时，对于文档1，计算了相似性得分后，查找哈希表，发现文档1以及存在得分，则将哈希表对应的得分和刚刚计算得到的得分相加作为最终得分，并更新哈希表1中文档1对应的得分，这样就得到文档1和用户查询最终的相似性得分，类似的计算其他文档，最后将结果排序后输出得分最高的K个文档作为搜索结果。&lt;/p&gt;
&lt;h2 id=&quot;%E8%B7%B3%E8%B7%83%E6%8C%87%E9%92%88%EF%BC%88skip-pointers%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;跳跃指针（Skip Pointers）&lt;/h2&gt;
&lt;p&gt;基本思想：将一个倒排列表数据化整为零，切分为若干个固定大小的数据块，一个数据块作为一组，对于每个数据块，增加元信息来记录关于这个块的一些信息，这样即使是面对压缩后的倒排列表，在进行倒排列表合并的时候也能有两个好处：&lt;/p&gt;
&lt;p&gt;1、无须解压所有倒排列表项，只解压部分数据即可&lt;/p&gt;
&lt;p&gt;2、无须比较任意两个文档ID。&lt;/p&gt;
&lt;p&gt;下图是将“Google”这个查询词对应的倒排列表加入跳跃指针后的数据结构。
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E8%B7%B3%E8%B7%83%E6%8C%87%E9%92%88.png&quot; alt=&quot;跳跃指针&quot; /&gt;&lt;/p&gt;
&lt;p&gt;假设对于“Google”这个单词的倒排列表来说，数据块的大小为3。然后在每块数据前加入管理信息，比如第一块的管理信息是&amp;lt;&amp;lt;5,Pos1&amp;gt;&amp;gt;，5表示块中第一个文档ID编号，Pos1是跳跃指针，指向第2块的起始位置。假设要在单词“Google&amp;quot;压缩后的倒排列表里查找文档ID为7的文档。首先，对倒排列表前两个数值进行数据解压缩，读取第一组的跳跃指针数据，发现其值为&amp;lt;5,Pos1&amp;gt;，其中Pos1指出了第2组的跳跃指针在倒排列表中的起始位置，于是可以解压缩Pos1位置处连续两个数值，得到&amp;lt;13,Pos2&amp;gt;。5和13是两组数据中最小的文档ID（即每组数据的第一个文档ID），我们要找的是7，那么如果7号文档包含在单词”Google“的倒排列表中的话，就一定会出现在第一组，否则说明倒排列表中不包含这个文档。解压第1组数据后，根据最小文档编号逆向恢复其原始的文档编号，此处&amp;lt;2,1&amp;gt;的原始文档ID是：5+2=7，与我们要找的文档ID相同，说明7号文档在单词”Google“的倒排列表中，于是可以结束这次查找。&lt;/p&gt;
&lt;p&gt;从上面的查找过程可知，在查找数据时，只需要对其中一个数据块进行解压缩和文档编号查找即可获得结果，而不必解压所有数据，很明显加快查找速度，并节省内存空间。&lt;/p&gt;
&lt;p&gt;缺点：增加指针比较操作的次数。&lt;/p&gt;
&lt;p&gt;实践表明：假设倒排列表的长度为L（即包含L个文档ID），使用根号L作为块大小，则效果较好。&lt;/p&gt;
&lt;h1 id=&quot;%E5%A4%9A%E5%AD%97%E6%AE%B5%E7%B4%A2%E5%BC%95&quot; tabindex=&quot;-1&quot;&gt;多字段索引&lt;/h1&gt;
&lt;p&gt;即对文档的多个字段进行索引。
实现多字段索引的方式：多索引方式、倒排列表方式和扩展列表方式。&lt;/p&gt;
&lt;h2 id=&quot;%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F&quot; tabindex=&quot;-1&quot;&gt;多索引方式&lt;/h2&gt;
&lt;p&gt;针对每个不同的字段，分别建立一个索引，当用户指定某个字段作为搜索范围时，可以从相应的索引里提取结果。当用户没有指定特定字段时，搜索引擎会对所有字段都进行查找并合并多个字段的相关性得分，这样效率较低。多索引方式示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F.png&quot; alt=&quot;多索引方式&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E5%80%92%E6%8E%92%E5%88%97%E8%A1%A8%E6%96%B9%E5%BC%8F&quot; tabindex=&quot;-1&quot;&gt;倒排列表方式&lt;/h2&gt;
&lt;p&gt;将字段信息存储在某个关键词对应的倒排列表内，在倒排列表中每个文档索引项信息的末尾追加字段信息，这样在读出用户查询关键词的倒排列表的同时，就可以根据字段信息，判断关键词是否在某个字段出现，以此来进行过滤。倒排列表方式示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E5%80%92%E6%8E%92%E5%88%97%E8%A1%A8%E6%96%B9%E5%BC%8F.png&quot; alt=&quot;倒排列表方式&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E6%89%A9%E5%B1%95%E5%88%97%E8%A1%A8%E6%96%B9%E5%BC%8F&quot; tabindex=&quot;-1&quot;&gt;扩展列表方式&lt;/h2&gt;
&lt;p&gt;这是用得比较多的支持多字段索引的方法。为每个字段建立一个列表，该列表记录了每个文档这个字段对应的出现位置信息。下图是扩展列表的示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E6%89%A9%E5%B1%95%E5%88%97%E8%A1%A8%E6%96%B9%E5%BC%8F.png&quot; alt=&quot;扩展列表方式&quot; /&gt;&lt;/p&gt;
&lt;p&gt;为方便起见，只针对”标题“字段所建立扩展列表。比如第一项&amp;lt;1,(1,4)&amp;gt;，代表对于文档1而言，其标题的位置为从第一个单词到第4个单词这个范围，其他项含义类似。&lt;/p&gt;
&lt;p&gt;对于查询而言，假设用户在标题字段搜索”搜索引擎“，通过倒排列表可以知道文档1、3、4包含这个查询词，接下来需要判断这些文档是否在标题字段中出现过查询词？对于文档1，”搜索引擎“这个查询词的出现位置是6和10。而通过对应的标题扩展列表可知，文档1的标题范围是1到4，说明文档1的标题内不包含查询词，即文档1不满足要求。对于文档3，”搜索引擎出现的位置是2、8、15，对应的标题扩展列表中，标题出现范围为1到3，说明在位置2出现的这个查询词是在标题范围内的，即满足要求，可以作为搜索结果输出。文档4也是类似的处理。&lt;/p&gt;
&lt;h1 id=&quot;%E7%9F%AD%E8%AF%AD%E6%9F%A5%E8%AF%A2&quot; tabindex=&quot;-1&quot;&gt;短语查询&lt;/h1&gt;
&lt;p&gt;短语查询的本质是如何在索引中维护单词之间的顺序关系或者位置信息。较常见的支持短语查询技术包括：位置信息索引、双词索引和短语索引。也可将三者结合使用。&lt;/p&gt;
&lt;h2 id=&quot;%E4%BD%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E7%B4%A2%E5%BC%95%EF%BC%88position-index%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;位置信息索引（Position Index）&lt;/h2&gt;
&lt;p&gt;在索引中记录单词位置信息，可以很方便地支持短语查询。但是其付出的存储和计算代价很高。示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E4%BD%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E7%B4%A2%E5%BC%95.png&quot; alt=&quot;位置信息索引&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;5,2,[3,7]&amp;gt;&lt;/code&gt;的含义是，5文档包含“爱情“这个单词，且这个单词在文档中出现2次，其对应的位置为3和7，其他的含义与此相同。&lt;/p&gt;
&lt;p&gt;查询时，通过倒排列表可知，文档5和文档9同时包含两个查询词，为了判断在这两个文档中，用户查询是否以短语的形式存在，还要判断位置信息。”爱情“这个单词在5号文档的出现位置是3和7，而”买卖“在5号文档的出现位置是4，可以知道5号文档的位置3和位置4分别对应单词”爱情“和”买卖“，即两者是一个短语形式，而根据同样的分析可知9号文档不是短语，所以5号文档会被作为搜索结果返回。&lt;/p&gt;
&lt;h2 id=&quot;%E5%8F%8C%E8%AF%8D%E7%B4%A2%E5%BC%95%EF%BC%88nextword-index%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;双词索引（Nextword Index）&lt;/h2&gt;
&lt;p&gt;统计数据表明，二词短语在短语中所占比例最大，因此针对二词短语提供快速查询，能解决短语查询的问题。但是这样做的话倒排列表个数会发生爆炸性增长。双词索引的数据结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E5%8F%8C%E8%AF%8D%E7%B4%A2%E5%BC%95.png&quot; alt=&quot;双词索引&quot; /&gt;&lt;/p&gt;
&lt;p&gt;由图可知，内存中包含两个词典，分别是”首词“和”下词“词典，”首词“词典有指向”下词“词典某个位置的指针，”下词“词典存储了紧跟在”首词“词典的常用短语的第2个单词，”下词“词典的指针指向包含这个短语的倒排列表。比如”我的“这个短语，其倒排列表包含文档5和7，”的父亲“这个短语，其倒排列表包含文档5，其余词典也是类似的含义。&lt;/p&gt;
&lt;p&gt;对于查询，用户输入”我的父亲“进行查询，搜索引擎将其进行分词得到”我的“和”的父亲“两个短语，然后分别查找词典信息，发现包含”我的“这个短语的是文档5和文档7，而包含”的父亲“这个短语的有文档5。查看其对应的出现位置，可以知道文档5是符合条件的搜索结果，这样就完成了对短语查询的支持。&lt;/p&gt;
&lt;p&gt;双词索引会使得索引急剧增大，一般实现并非对所有单词都建立双词索引，而是只对计算代价高的短语建立双词索引。&lt;/p&gt;
&lt;h2 id=&quot;%E7%9F%AD%E8%AF%AD%E7%B4%A2%E5%BC%95%EF%BC%88phrase-index%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;短语索引（Phrase Index）&lt;/h2&gt;
&lt;p&gt;直接在词典中加入多次短语并维护短语的倒排列表。缺点就是不可能事先将所有短语都建好索引。通用做法就是挖掘出热门短语。下图是加入短语索引后的整体索引结构：
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E7%9F%AD%E8%AF%AD%E7%B4%A2%E5%BC%95.png&quot; alt=&quot;短语索引&quot; /&gt;&lt;/p&gt;
&lt;p&gt;对于查询，当搜索引擎接收到用户查询后，现在短语索引里查找，如果找到，则计算后返回给用户搜索结果，否则仍然利用常规索引进行查询处理。&lt;/p&gt;
&lt;h2 id=&quot;%E6%B7%B7%E5%90%88%E6%96%B9%E6%B3%95&quot; tabindex=&quot;-1&quot;&gt;混合方法&lt;/h2&gt;
&lt;p&gt;将三者结合起来，接收到用户查询后，系统首先在短语索引中查找，如果找到则返回结果，否则在双词索引中查找，如果找到则返回结果，否则从常规索引中对短语进行处理，充分发挥各自的优势。3种方式的混合索引结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E6%B7%B7%E5%90%88%E7%B4%A2%E5%BC%95.png&quot; alt=&quot;混合方法&quot; /&gt;&lt;/p&gt;
&lt;p&gt;短语查询用来对热门短语和高频短语进行索引，双词索引对包含停用词等高代价短语进行索引。&lt;/p&gt;
&lt;p&gt;对于查询，系统首先在短语索引中查找，如果找到则返回结果，否则在双词索引中查找，如果找到则返回结果，否则从常规索引中对短语进行处理，这样就充分发挥各自的优势。&lt;/p&gt;
&lt;h1 id=&quot;%E5%88%86%E5%B8%83%E5%BC%8F%E7%B4%A2%E5%BC%95%EF%BC%88parallel-indexing%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;分布式索引（Parallel Indexing）&lt;/h1&gt;
&lt;p&gt;当搜索引擎需要处理的文档集合太多的时候，就需要考虑分布式解决方案。每台机器维护整个索引的一部分，有多台机器协作来完成索引的建立和对查询的响应。&lt;/p&gt;
&lt;h2 id=&quot;%E6%8C%89%E6%96%87%E6%A1%A3%E5%88%92%E5%88%86%EF%BC%88document-paritioning%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;按文档划分（Document Paritioning）&lt;/h2&gt;
&lt;p&gt;将整个文档集合切割成若干个子集合，而每台机器负责对某个文档子集合建立索引，并响应查询请求。按文档划分示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E6%8C%89%E6%96%87%E6%A1%A3%E5%88%92%E5%88%86.png&quot; alt=&quot;按文档划分&quot; /&gt;&lt;/p&gt;
&lt;p&gt;工作原理：查询分发服务器接收到用户查询请求后，将查询广播给所有索引服务器。每个索引服务器负责部分文档子集合的索引维护和查询响应。当索引服务器接收到用户查询后，计算相关文档，并将得分最高的K个文档送返查询分发服务器。查询分发服务器综合各个索引服务器的搜索结果后，合并搜索结果，将得分最高的m个文档作为最终搜索结果返回给用户。&lt;/p&gt;
&lt;h2 id=&quot;%E6%8C%89%E5%8D%95%E8%AF%8D%E5%88%92%E5%88%86%EF%BC%88term-paritioning%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;按单词划分（Term Paritioning）&lt;/h2&gt;
&lt;p&gt;每个索引服务器负责词典中部分单词的倒排列表的建立和维护。按单词划分示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E6%8C%89%E5%8D%95%E8%AF%8D%E5%88%92%E5%88%86.png&quot; alt=&quot;按单词划分&quot; /&gt;&lt;/p&gt;
&lt;p&gt;工作原理：一次一个单词。假设查询包含A、B、C三个单词，查询服务器接收到查询后，将查询转发到包含单词A倒排列表的索引服务器节点1，索引服务器节点1提取A的倒排列表，并累计计算搜索结果的中间的分，然后将查询和中间结果传递给包含单词B倒排列表的索引服务器节点，索引服务器节点2也是类似处理，并继续到索引服务器节点3。然后将最终结果返回给查询分发服务器，查询分发服务器计算得分最高的K个文档作为搜索结果输出。&lt;/p&gt;
&lt;h3 id=&quot;%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%A1%88%E6%AF%94%E8%BE%83&quot; tabindex=&quot;-1&quot;&gt;两种方案比较&lt;/h3&gt;
&lt;p&gt;按文档比较常用，按单词划分只在特殊应用场合才使用。
按单词划分的不足：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可扩展性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;搜索引擎处理的文档是经常变动的。如果按文档来对索引划分，只需要增加索引服务器，操作起来很方便。但如果是按单词进行索引划分，则对几乎所有的索引服务器都有直接影响，因为新增文档可能包含所有词典单词，即需要对每个单词的倒排列表进行更新，实现起来相对复杂。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常用单词的倒排列表非常庞大，可能会达到几十M大小。如果按文档划分，这种单词的倒排列表会比较均匀地分布在不同的索引服务器上，而按单词进行索引划分，某个常见单词的倒排列表全部内容都由一台索引服务器维护。如果该单词同时是一个流行词汇，那么该服务器会成为负载过大的性能瓶颈。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;容错性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设某台服务器出现故障。如果按文档进行划分，那么只影响部分文档子集合，其他索引服务器仍然能响应。但如果按单词进行划分，若索引服务器发生故障，则某些单词的倒排列表无法访问，用户查询这些单词的时候，会发现没有搜索结果，直接影响用户体验。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对查询处理方式的支持&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按单词进行索引一次只能查询一个单词，而按文档划分的不受此限制。&lt;/p&gt;
&lt;h1 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h1&gt;
&lt;p&gt;通过了解搜索引擎使用的数据结构和算法，对其工作原理有了进一步的认识。对于sphinx来说，在线上环境可以考虑增量索引和一次全量索引结合达到实时性的效果。&lt;/p&gt;
&lt;p&gt;由于底层基础比较差，花了大半个月重复读了几遍才能弄懂第三章讲的内容，真正体会到数据结构和算法真的很重要。虽然日常工作很少会直接用到数据结构和算法，但是知道了常用的数据结构和算法之后，在遇到问题时就会有更多解决方案的思路，厚积薄发。&lt;/p&gt;
&lt;p&gt;到此本文结束，如果还有什么疑问或者建议，可以多多交流，原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>［井字游戏］做一款回忆童年的游戏</title>
    <link href="https://hoohack.me/blog/2016/2016-04-27-making-tictactoe-game/"/>
    <updated>2016-04-27T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-04-27-making-tictactoe-game/</id>
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;99% of information we read, we forget anyway. The best way to remember
is to &amp;quot;DO&amp;quot;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;体验地址：&lt;a href=&quot;https://www.hoohack.me/assets/tictactoe/&quot;&gt;https://www.hoohack.me/assets/tictactoe/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;游戏完整的代码在我的 github 上，有兴趣也可以围观一下：&lt;a href=&quot;https://github.com/hoohack/TicTacToe&quot;&gt;TicTacToe&lt;/a&gt;，也希望大家可以点个 star。&lt;/p&gt;
&lt;h2 id=&quot;%E7%BC%98%E8%B5%B7&quot; tabindex=&quot;-1&quot;&gt;缘起&lt;/h2&gt;
&lt;p&gt;最近在&lt;a href=&quot;https://www.freecodecamp.com/&quot;&gt;FreeCodeCamp&lt;/a&gt;上面学习前端知识，不知不觉已经学到了319课，现在遇到的一个小project是做一款&lt;a href=&quot;https://www.freecodecamp.com/challenges/build-a-tic-tac-toe-game&quot;&gt;井字游戏&lt;/a&gt;。说起井字游戏，真是满满的童年味道，还记得最疯狂的时候是小时候跟同桌拿着一张草稿纸就能玩一节课，回到家跟弟弟也能继续玩，对于没有太多娱乐节目的童年来说，真是一款玩不厌的小游戏。这款游戏代码比较简单，主要是掌握算法的原理，但是也有一些需要注意的地方，于是想把自己遇到的问题记录下来。&lt;/p&gt;
&lt;h2 id=&quot;%E6%B8%B8%E6%88%8F%E7%95%8C%E9%9D%A2&quot; tabindex=&quot;-1&quot;&gt;游戏界面&lt;/h2&gt;
&lt;p&gt;进入正题。项目的效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E4%BA%95%E5%AD%97%E6%B8%B8%E6%88%8F-%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%95%88%E6%9E%9C%E5%9B%BE&quot; alt=&quot;项目效果图&quot; /&gt;&lt;/p&gt;
&lt;p&gt;FreeCodeCamp上要求不能查看源码来实现，于是便想着先把页面做出来。看到井字格子，就想着用9个li，然后设置li的边框作为井字线。于是用了一个div包住一个ul，里面有9个li。&lt;/p&gt;
&lt;p&gt;游戏有一个开始界面可供选择玩家的角色，然后选择先手是哪一方，接着开始游戏。选择界面做了一个遮罩层，里面提供给用户选择，选择之后便把遮罩层隐藏并开始游戏。&lt;/p&gt;
&lt;h2 id=&quot;%E4%BA%95%E5%AD%97%E6%B8%B8%E6%88%8F%E7%AE%97%E6%B3%95&quot; tabindex=&quot;-1&quot;&gt;井字游戏算法&lt;/h2&gt;
&lt;p&gt;算法参考了&lt;a href=&quot;http://blog.jobbole.com/24719/&quot;&gt;这篇文章&lt;/a&gt;。但里面的图片看不到了，笔者根据自己的理解再解释一遍，并配上一些图片。&lt;/p&gt;
&lt;p&gt;这次做的是人机对战，因此就需要写出比较智能的算法。首先，设计者要懂得玩游戏，有自己的策略，接下来就是将自己的策略付诸实现。&lt;/p&gt;
&lt;p&gt;从下图可以看到，整个棋盘可以连接处8条线，即一共有8种取胜可能：
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E4%BA%95%E5%AD%97%E6%B8%B8%E6%88%8F-8%E7%A7%8D%E5%8F%96%E8%83%9C%E5%8F%AF%E8%83%BD&quot; alt=&quot;8种取胜可能&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;1%E3%80%81%E5%BC%80%E5%B1%80%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%8C%E8%BF%99%E4%B8%80%E6%AD%A5%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%83%85%E5%86%B5&quot; tabindex=&quot;-1&quot;&gt;1、开局第一步，这一步有两种情况&lt;/h3&gt;
&lt;p&gt;A、如果先手是电脑，那么就将棋子下在中心位置，如图：
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E4%BA%95%E5%AD%97%E6%B8%B8%E6%88%8F-%E5%BC%80%E5%B1%80%E7%AC%AC%E4%B8%80%E6%AD%A5&quot; alt=&quot;开局第一步&quot; /&gt;&lt;/p&gt;
&lt;p&gt;B、如果先手是玩家，那么有下面三种情况要考虑
如果玩家在中心位置，那么电脑必须落在四个角位，因为如果不落在角位，那么就会出现必输的情形。假设现在用1-9表示9个棋位。如下图所示，如果玩家第一步在中心位置，第二步电脑落在第2位的棱位（图中的2），第三步玩家只需要在第7或第9位下棋（图中的3），第四步电脑必须在1或3位，第五步玩家跟进在7或9，则第六步电脑必须在1或3，那么第七步玩家只需要在4或者6下棋就可以赢了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E4%BA%95%E5%AD%97%E6%B8%B8%E6%88%8F-%E5%85%88%E6%89%8B%E6%98%AF%E7%8E%A9%E5%AE%B6%E8%80%83%E8%99%91%E6%83%85%E5%86%B5&quot; alt=&quot;先手是玩家考虑情况&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果玩家在棱位/角位，那么电脑需要在中心位置下棋，在保证不输的情况下反击。&lt;/p&gt;
&lt;h3 id=&quot;2%E3%80%81%E7%AC%AC%E4%BA%8C%E6%AD%A5%E6%A3%8B%EF%BC%88%E5%85%88%E8%A7%92%E5%8E%9F%E5%88%99%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;2、第二步棋（先角原则）&lt;/h3&gt;
&lt;p&gt;根据上面的分析，如果先手是玩家且玩家落棋在中心位置，为了避免必输的情形，电脑需要落棋在角上。而如果先手是电脑，那么如果玩家落在棱位，电脑落在角位让必输的情形属于玩家。&lt;/p&gt;
&lt;h3 id=&quot;3%E3%80%81%E6%94%BB%E5%87%BB&quot; tabindex=&quot;-1&quot;&gt;3、攻击&lt;/h3&gt;
&lt;p&gt;检测棋盘，如果有两枚己方的棋子连在一起且连线中仍有空位，那么就落棋在该位。&lt;/p&gt;
&lt;h3 id=&quot;4%E3%80%81%E9%98%B2%E5%AE%88&quot; tabindex=&quot;-1&quot;&gt;4、防守&lt;/h3&gt;
&lt;p&gt;检测棋盘，如果有对方的两枚棋子连在一起且连线中仍有空位，那么就落棋在该位。&lt;/p&gt;
&lt;h3 id=&quot;5%E3%80%81%E5%9E%83%E5%9C%BE%E6%97%B6%E9%97%B4&quot; tabindex=&quot;-1&quot;&gt;5、垃圾时间&lt;/h3&gt;
&lt;p&gt;当不需要攻击也不需要防守的时候，那就随便找个位置下棋，尽可能找到连线中还有两个空位的位置。&lt;/p&gt;
&lt;h3 id=&quot;%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5&quot; tabindex=&quot;-1&quot;&gt;特殊情况&lt;/h3&gt;
&lt;p&gt;有一种特殊情况是不能执行先角原则的，如下图所示，第一步，玩家先下棋在1，第二步，电脑根据开局第一步的规则下棋在中心位置5，第三步，玩家在1的对角位置9下棋，根据先角原则，第四步电脑将落在3或者7的棋位，第五步玩家在7或者3的位置封堵电脑，那么此时电脑就输了。唯有此种情况不能执行先角原则，所以在非攻击且非防守的时候要先排除掉此情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E4%BA%95%E5%AD%97%E6%B8%B8%E6%88%8F-%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5&quot; alt=&quot;特殊情况&quot; /&gt;&lt;/p&gt;
&lt;p&gt;具体实现
说了那么多，可能比较枯燥，下面介绍一下具体的代码实现。
程序使用一个二维数组panel保存棋盘的状态，1是电脑的值，－1是玩家的值。
winArr保存所有可能赢的8个棋位组合；维护computerWin和userWin，初始值等于winArr，当电脑或玩家每次下棋时，都分别更新这两个数组，删除掉不能赢的棋位组合。在更新panel的时候会分别更新computerWin和userWin。&lt;/p&gt;
&lt;p&gt;核心的方法是play，play的执行步骤伪代码如下：&lt;/p&gt;
&lt;p&gt;如果可以攻击
遍历computerWin数组，找到可以攻击的棋位，下棋，显示是否赢了。
不能攻击，如果需要防守
遍历userWin，根据玩家可赢的组合，找出需要防守的棋位，下棋，更新panel；
不需要防守，如果是电脑先手的第一步
在中心位置下棋，更新panel；
不是先手第一步
如果中心位置没有被占去，在中心位置下棋，更新panel；返回
如果是特殊情况，在棱位下棋，更新panel； 返回
如果角位仍有位置，选择一个角位下棋，更新panel； 返回
最后一种情况，找到剩余的空位，优先选择位于computerWin的空位，下棋，更新panel； 返回&lt;/p&gt;
&lt;p&gt;play算法的实现如下：&lt;/p&gt;
&lt;p&gt;if(canAttack()) {
console.log(&amp;quot;attack&amp;quot;);
var attackPos = findAttackPos();
updatePanel(attackPos, computerVal);
} else if(needDefend()) {
console.log(&amp;quot;defend&amp;quot;);
var defendPos = findDefendPos();
updatePanel(defendPos, computerVal);
} else if(firstStep()) {
console.log(&amp;quot;first&amp;quot;);
updatePanel(firstPos, computerVal);
running = true;
} else {
console.log(&amp;quot;other&amp;quot;);
if(panel[1][1] == 0) {
updatePanel(firstPos, computerVal);
return;
}
if(special()) {
console.log(&#39;special&#39;);
var pos = findSpecialPos();
updatePanel(pos, computerVal);
return;
}
var random = Math.floor(Math.random() * 2);
if(panel[0][0] == 0 &amp;amp;&amp;amp; panel[2][2] == 0) {
var pos = (random == 0) ? 0 : 8;
updatePanel(pos, computerVal);
} else if(panel[0][2] == 0 &amp;amp;&amp;amp; panel[2][0] == 0) {
var pos = (random == 0) ? 2: 6;
updatePanel(pos, computerVal);
} else {
var otherPos = findEmptyPos();
updatePanel(otherPos, computerVal);
}
}&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;在编码的过程中遇到的一个难题就是JavaScript的数组对象，我在第一次调用play方法开头输出panel的时候，得到的是play执行后panel的值，后来请教一位大神，发现是因为panel是一个对象，因为对象遍历引用的都是同一块内存地址，所以一旦有改变，就全部改了。如果直接使用下标输出每一个值的话是可以得到初始的值的，也可以用JSON方法将数组字符串，然后打印出来查看结果。&lt;/p&gt;
&lt;p&gt;另外，也学会了如何在JavaScript里面封装一个类，将私有方法写在类的外面，需要暴露的方法写在类里面。当然，还有很多需要学习的地方。继续学习。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有时候一些东西看起来很简单，或者听到了很多次，心里面觉得实现起来应该很简单的，没什么了不起，觉得不以为然，但只有真正去实践出来的时候才能体会到其中的乐趣和思想，才能真正的掌握。所以，尽情的去DO。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文较短，如果还有什么疑问或者建议，可以多多交流，原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，望大力点推荐。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>［PDO绑定参数］使用PHP的PDO扩展进行批量更新操作</title>
    <link href="https://hoohack.me/blog/2016/2016-04-25-multiple-update-database-by-using-pdo/"/>
    <updated>2016-04-25T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-04-25-multiple-update-database-by-using-pdo/</id>
    <content type="html">&lt;p&gt;最近有一个批量更新数据库表中某几个字段的需求，在做这个需求的时候，使用了PDO做参数绑定，其中遇到了一个坑。&lt;/p&gt;
&lt;h2 id=&quot;%E6%96%B9%E6%A1%88%E9%80%89%E6%8B%A9&quot; tabindex=&quot;-1&quot;&gt;方案选择&lt;/h2&gt;
&lt;p&gt;笔者已知的做批量更新有以下几种方案：&lt;/p&gt;
&lt;p&gt;1、逐条更新&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这种是最简单的方案，但无疑也是效率最低的方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、CASE WHEN&lt;/p&gt;
&lt;p&gt;类似如下的语句&lt;/p&gt;
&lt;p&gt;UPDATE tbl_test SET val = CASE id WHEN 1 THEN 2 WHEN 2 THEN 3 END WHERE id IN(1, 2);
PDO绑定参数&lt;/p&gt;
&lt;p&gt;为了防止SQL注入，使用了PDO扩展绑定参数。上面的数字在一般情况下是变量，那么就需要做参数绑定。刚开始是想着在IN的时候将id组成的字符串作为变量绑定过去，第一次实现的代码如下：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$data = array(array(&#39;id&#39; =&amp;gt; 1, &#39;val&#39; =&amp;gt; 2), array(&#39;id&#39; =&amp;gt; 2, &#39;val&#39; =&amp;gt; 3));
$ids = implode(&#39;,&#39;, array_map(function($v) {return $v[&#39;id&#39;];}, $data)); //获取ID数组
$update_sql = &#39;UPDATE tbl_test SET val = CASE id&#39;;
$params = array();
$params[&amp;quot;:ids&amp;quot;] = $ids;
foreach($data as $key =&amp;gt; $item) {
$update_sql .= &amp;quot;WHEN :id_&amp;quot; . $key . &amp;quot;THEN :val_&amp;quot; . $key . &amp;quot; &amp;quot;;
$params[&amp;quot;:id_&amp;quot; . $key] = $item[&#39;id&#39;];
$params[&amp;quot;:val_&amp;quot; . $key] = $item[&#39;val&#39;];
}
$update_sql .= &amp;quot;END WHERE id IN (:_ids)&amp;quot;;
TEST::execute($update_sql, $params);//此处会调用bindParam绑定参数&lt;/p&gt;
&lt;p&gt;后来发现这样是行不通的，而且比较诡异的是这样只能更新第一条记录。查阅资料后，发现这样的绑定方式是不行的，IN语句的参数应该一个一个地绑定。看看文档中对bindParam函数的描述：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/PDO%E6%8F%8F%E8%BF%B0&quot; alt=&quot;PDO描述&quot; /&gt;&lt;/p&gt;
&lt;p&gt;修改后的写法：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$data = array(array(&#39;id&#39; =&amp;gt; 1, &#39;val&#39; =&amp;gt; 2), array(&#39;id&#39; =&amp;gt; 2, &#39;val&#39; =&amp;gt; 3));
$update_sql = &#39;UPDATE tbl_test SET val = CASE id&#39;;
$params = array();
$params[&amp;quot;:ids&amp;quot;] = $ids;
$in_arr = array();&lt;/p&gt;
&lt;p&gt;foreach($data as $key =&amp;gt; $item) {
$update_sql .= &amp;quot;WHEN :id_&amp;quot; . $key . &amp;quot;THEN :val_&amp;quot; . $key . &amp;quot; &amp;quot;;
$params[&amp;quot;:id_&amp;quot; . $key] = $item[&#39;id&#39;];
$params[&amp;quot;:val_&amp;quot; . $key] = $item[&#39;val&#39;];
$params[&amp;quot;:ids_&amp;quot; . $key] = $item[&#39;id&#39;];
array_push($in_arr, &amp;quot;:id_&amp;quot; . $key);
}
$update_sql .= &amp;quot;END WHERE id IN (&amp;quot; . implode(&#39;,&#39; $in_arr) . &amp;quot;)&amp;quot;;
TEST::execute($update_sql, $params);//此处会调用bindParam绑定参数&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这是最近遇到的一个小问题，其实更多的是说明在MySQL的IN语句里面做参数绑定时应该一个一个的绑定。&lt;/p&gt;
&lt;p&gt;参考链接：
&lt;a href=&quot;http://www.ghugo.com/update-multiple-rows-with-different-values-and-a-single-sql-query/&quot;&gt;mysql语句：批量更新多条记录的不同值&lt;/a&gt;
&lt;a href=&quot;http://stackoverflow.com/questions/920353/can-i-bind-an-array-to-an-in-conditionhttp://stackoverflow.com/questions/920353/can-i-bind-an-array-to-an-in-condition&quot;&gt;Can I bind an array to an IN() condition?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点下推荐，写文章不容易。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>［搜索引擎］Sphinx的介绍和原理探索</title>
    <link href="https://hoohack.me/blog/2016/2016-04-21-introduce-sphinx-and-study-theory/"/>
    <updated>2016-04-21T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-04-21-introduce-sphinx-and-study-theory/</id>
    <content type="html">&lt;h2 id=&quot;what%2Fsphinx%E6%98%AF%E4%BB%80%E4%B9%88&quot; tabindex=&quot;-1&quot;&gt;What/Sphinx是什么&lt;/h2&gt;
&lt;p&gt;定义：Sphinx是一个全文检索引擎。&lt;/p&gt;
&lt;p&gt;特性：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;索引和性能优异&lt;/li&gt;
&lt;li&gt;易于集成SQL和XML数据源，并可使用SphinxAPI、SphinxQL或者SphinxSE搜索接口&lt;/li&gt;
&lt;li&gt;易于通过分布式搜索进行扩展&lt;/li&gt;
&lt;li&gt;高速的索引建立(在当代CPU上，峰值性能可达到10 ~ 15MB/秒)&lt;/li&gt;
&lt;li&gt;高性能的搜索 (在1.2G文本，100万条文档上进行搜索，支持高达每秒150~250次查询)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;why%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8sphinx&quot; tabindex=&quot;-1&quot;&gt;Why/为什么使用Sphinx&lt;/h2&gt;
&lt;h3 id=&quot;%E9%81%87%E5%88%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF&quot; tabindex=&quot;-1&quot;&gt;遇到的使用场景&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;遇到一个类似这样的需求：用户可以通过文章标题和文章搜索到一片文章的内容，而文章的标题和文章的内容分别保存在不同的库，而且是跨机房的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;%E5%8F%AF%E9%80%89%E6%96%B9%E6%A1%88&quot; tabindex=&quot;-1&quot;&gt;可选方案&lt;/h3&gt;
&lt;p&gt;A、直接在数据库实现跨库LIKE查询&lt;/p&gt;
&lt;p&gt;优点：简单操作
缺点：效率较低，会造成较大的网络开销&lt;/p&gt;
&lt;p&gt;B、结合Sphinx中文分词搜索引擎&lt;/p&gt;
&lt;p&gt;优点：效率较高，具有较高的扩展性
缺点：不负责数据存储&lt;/p&gt;
&lt;p&gt;使用Sphinx搜索引擎对数据做索引，数据一次性加载进来，然后做了所以之后保存在内存。这样用户进行搜索的时候就只需要在Sphinx服务器上检索数据即可。而且，Sphinx没有MySQL的伴随机磁盘I/O的缺陷，性能更佳。&lt;/p&gt;
&lt;h3 id=&quot;%E5%85%B6%E4%BB%96%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF&quot; tabindex=&quot;-1&quot;&gt;其他典型使用场景&lt;/h3&gt;
&lt;p&gt;1、快速、高效、可扩展和核心的全文检索&lt;/p&gt;
&lt;p&gt;数据量大的时候，比MyISAM和InnoDB都要快。
能对多个源表的混合数据创建索引，不限于单个表上的字段。
能将来自多个索引的搜索结果进行整合。
能根据属性上的附加条件对全文搜索进行优化。&lt;/p&gt;
&lt;p&gt;2、高效地使用WHERE子句和LIMIT字句&lt;/p&gt;
&lt;p&gt;当在多个WHERE条件做SELECT查询时，索引选择性较差或者根本没有索引支持的字段，性能较差。sphinx可以对关键字做索引。区别是，MySQL中，是内部引擎决定使用索引还是全扫描，而sphinx是让你自己选择使用哪一种访问方法。因为sphinx是把数据保存到RAM中，所以sphinx不会做太多的I/O操作。而mysql有一种叫半随机I/O磁盘读，把记录一行一行地读到排序缓冲区里，然后再进行排序，最后丢弃其中的绝大多数行。所以sphinx使用了更少的内存和磁盘I/O。&lt;/p&gt;
&lt;p&gt;3、优化GROUP BY查询&lt;/p&gt;
&lt;p&gt;在sphinx中的排序和分组都是用固定的内存，它的效率比类似数据集全部可以放在RAM的MySQL查询要稍微高些。&lt;/p&gt;
&lt;p&gt;4、并行地产生结果集&lt;/p&gt;
&lt;p&gt;sphinx可以让你从相同数据中同时产生几份结果，同样是使用固定量的内存。作为对比，传统SQL方法要么运行两个查询，要么对每个搜索结果集创建一个临时表。而sphinx用一个multi-query机制来完成这项任务。不是一个接一个地发起查询，而是把几个查询做成一个批处理，然后在一个请求里提交。&lt;/p&gt;
&lt;p&gt;5、向上扩展和向外扩展&lt;/p&gt;
&lt;p&gt;向上扩展：增加CPU/内核、扩展磁盘I/O
向外扩展：多个机器，即分布式sphinx&lt;/p&gt;
&lt;p&gt;6、聚合分片数据&lt;/p&gt;
&lt;p&gt;适合用在将数据分布在不同物理MySQL服务器间的情况。
例子：有一个1TB大小的表，其中有10亿篇文章，通过用户ID分片到10个MySQL服务器上，在单个用户的查询下当然很快，如果需要实现一个归档分页功能，展示某个用户的所有朋友发表的文章。那么就要同事访问多台MySQL服务器了。这样会很慢。而sphinx只需要创建几个实例，在每个表里映射出经常访问的文章属性，然后就可以进行分页查询了，总共就三行代码的配置。&lt;/p&gt;
&lt;h2 id=&quot;how%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8sphinx&quot; tabindex=&quot;-1&quot;&gt;How/如何使用Sphinx&lt;/h2&gt;
&lt;p&gt;Sphinx工作流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/sphinx%E6%B5%81%E7%A8%8B%E5%9B%BE.png&quot; alt=&quot;Sphinx工作流程图&quot; /&gt;&lt;/p&gt;
&lt;p&gt;流程图解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Database：数据源，是Sphinx做索引的数据来源。因为Sphinx是无关存储引擎、数据库的，所以数据源可以是MySQL、PostgreSQL、XML等数据。&lt;/li&gt;
&lt;li&gt;Indexer：索引程序，从数据源中获取数据，并将数据生成全文索引。可以根据需求，定期运行Indexer达到定时更新索引的需求。&lt;/li&gt;
&lt;li&gt;Searchd：Searchd直接与客户端程序进行对话，并使用Indexer程序构建好的索引来快速地处理搜索查询。&lt;/li&gt;
&lt;li&gt;APP：客户端程序。接收来自用户输入的搜索字符串，发送查询给Searchd程序并显示返回结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;sphinx%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86&quot; tabindex=&quot;-1&quot;&gt;Sphinx的工作原理&lt;/h2&gt;
&lt;p&gt;Sphinx的整个工作流程就是Indexer程序到数据库里面提取数据，对数据进行分词，然后根据生成的分词生成单个或多个索引，并将它们传递给searchd程序。然后客户端可以通过API调用进行搜索。&lt;/p&gt;
&lt;p&gt;介绍了Sphinx的工作原理后，那么接下来就要让Sphinx工作起来，先来看看Sphinx的配置。&lt;/p&gt;
&lt;h2 id=&quot;sphinx%E7%9A%84%E9%85%8D%E7%BD%AE&quot; tabindex=&quot;-1&quot;&gt;Sphinx的配置&lt;/h2&gt;
&lt;h3 id=&quot;%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE&quot; tabindex=&quot;-1&quot;&gt;数据源配置&lt;/h3&gt;
&lt;p&gt;先来看一份数据源的配置文件示例：&lt;/p&gt;
&lt;p&gt;source test
{
type                    = mysql&lt;/p&gt;
&lt;p&gt;sql_host                = 127.0.0.1
sql_user                = root
sql_pass                = root
sql_db                  = test
sql_port                = 3306    # optional, default is 3306&lt;/p&gt;
&lt;p&gt;sql_query_pre           = SET NAMES utf8
sql_query       　　　　 = SELECT id, name, add_time FROM tbl_test&lt;/p&gt;
&lt;p&gt;sql_attr_timestamp      = add_time&lt;/p&gt;
&lt;p&gt;sql_query_info_pre      = SET NAMES utf8
sql_query_info          = SELECT * FROM tbl_test WHERE id=$id
}&lt;/p&gt;
&lt;p&gt;其中&lt;/p&gt;
&lt;p&gt;source后面跟着的是数据源的名字，后面做索引的时候会用到；&lt;/p&gt;
&lt;p&gt;type：数据源类型，可以为MySQL，PostreSQL，Oracle等等；&lt;/p&gt;
&lt;p&gt;sql_host、sql_user、sql_pass、sql_db、sql_port是连接数据库的认证信息；&lt;/p&gt;
&lt;p&gt;sql_query_pre：定义查询时的编码&lt;/p&gt;
&lt;p&gt;sql_query：数据源配置核心语句，sphinx使用此语句从数据库中拉取数据；&lt;/p&gt;
&lt;p&gt;sql_attr_*：索引属性，附加在每个文档上的额外的信息（值），可以在搜索的时候用于过滤和排序。设置了属性之后，在调用Sphinx搜索API时，Sphinx会返回已设置了的属性；&lt;/p&gt;
&lt;p&gt;sql_query_info_pre：设置查询编码，如果在命令行下调试出现问号乱码时，可以设置此项；&lt;/p&gt;
&lt;p&gt;sql_query_info：设置命令行下返回的信息。&lt;/p&gt;
&lt;h3 id=&quot;%E7%B4%A2%E5%BC%95%E9%85%8D%E7%BD%AE&quot; tabindex=&quot;-1&quot;&gt;索引配置&lt;/h3&gt;
&lt;p&gt;index test_index
{
source                    = test
path                      = /usr/local/coreseek/var/data/test
docinfo                   = extern
charset_dictpath          = /usr/local/mmseg3/etc/
charset_type              = zh_cn.utf-8
ngram_len                 = 1
ngram_chars               = U+3000..U+2FA1F
}&lt;/p&gt;
&lt;p&gt;其中&lt;/p&gt;
&lt;p&gt;index后面跟的test_index是索引名称&lt;/p&gt;
&lt;p&gt;source：数据源名称；&lt;/p&gt;
&lt;p&gt;path：索引文件基本名，indexer程序会将这个路径作为前缀生成出索引文件名。例如，属性集会存在/usr/local/sphinx/data/test1.spa中，等等。&lt;/p&gt;
&lt;p&gt;docinfo：索引文档属性值存储模式；&lt;/p&gt;
&lt;p&gt;charset_dictpath：中文分词时启用词典文件的目录，该目录下必须要有uni.lib词典文件存在；&lt;/p&gt;
&lt;p&gt;charset_type：数据编码类型；&lt;/p&gt;
&lt;p&gt;ngram_len：分词长度；&lt;/p&gt;
&lt;p&gt;ngram_chars：要进行一元字符切分模式认可的有效字符集。&lt;/p&gt;
&lt;h3 id=&quot;%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE&quot; tabindex=&quot;-1&quot;&gt;中文分词核心配置&lt;/h3&gt;
&lt;h4 id=&quot;%E4%B8%80%E5%85%83%E5%88%86%E8%AF%8D&quot; tabindex=&quot;-1&quot;&gt;一元分词&lt;/h4&gt;
&lt;p&gt;charset_type = utf8
ngram_len = 1
ngram_chars = U+3000..U+2FA1F&lt;/p&gt;
&lt;h4 id=&quot;mmseg%E5%88%86%E8%AF%8D&quot; tabindex=&quot;-1&quot;&gt;mmseg分词&lt;/h4&gt;
&lt;p&gt;charset_type = utf8
charset_dictpath = /usr/local/mmseg3/etc/
ngram_len = 0&lt;/p&gt;
&lt;h3 id=&quot;%E8%BF%90%E8%A1%8C%E7%A4%BA%E4%BE%8B&quot; tabindex=&quot;-1&quot;&gt;运行示例&lt;/h3&gt;
&lt;h4 id=&quot;%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE&quot; tabindex=&quot;-1&quot;&gt;数据库数据&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/sphinx%E6%95%B0%E6%8D%AE%E7%A4%BA%E4%BE%8B&quot; alt=&quot;数据&quot; /&gt;&lt;/p&gt;
&lt;h4 id=&quot;%E4%BD%BF%E7%94%A8indexer%E7%A8%8B%E5%BA%8F%E5%81%9A%E7%B4%A2%E5%BC%95&quot; tabindex=&quot;-1&quot;&gt;使用indexer程序做索引&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/sphinx%20indexer&quot; alt=&quot;sphinx indexer&quot; /&gt;&lt;/p&gt;
&lt;h4 id=&quot;%E6%9F%A5%E8%AF%A2&quot; tabindex=&quot;-1&quot;&gt;查询&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/sphinx%20%E6%90%9C%E7%B4%A2%E7%A4%BA%E4%BE%8B&quot; alt=&quot;sphinx 搜索示例&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到，配置文件中的add_time被返回了，如上图的1所示。而sql_query_info返回的信息如上图的2所示。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Sphinx的配置不是很灵活，此处根据工作流程给出各部分的配置，更多的高级配置可以在使用时查阅文档。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;介绍了Sphinx的配置之后，继续介绍在Sphinx中，负责做索引的程序Indexer是如何做索引的。&lt;/p&gt;
&lt;p&gt;sphinx使用配置文件从数据库读出数据之后，就将数据传递给Indexer程序，然后Indexer就会逐条读取记录，根据分词算法对每条记录建立索引，分词算法可以是一元分词/mmseg分词。下面先介绍Indexer做索引时使用的数据结构和算法。&lt;/p&gt;
&lt;h2 id=&quot;%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95&quot; tabindex=&quot;-1&quot;&gt;倒排索引&lt;/h2&gt;
&lt;p&gt;倒排索引是一种数据结构，用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。它是文档检索系统中最常用的数据结构。&lt;/p&gt;
&lt;p&gt;倒排索引(Inverted Index)：倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。&lt;/p&gt;
&lt;p&gt;传统的索引是：索引ID-&amp;gt;文档内容，而倒排索引是：文档内容（分词）-&amp;gt;索引ID。可以类比正向代理和反向代理的区别来理解。正向代理把内部请求代理到外部，反向代理把外部请求代理到内部。所以应该理解为转置索引比较合适。&lt;/p&gt;
&lt;p&gt;倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。&lt;/p&gt;
&lt;p&gt;单词词典是倒排索引中非常重要的组成部分，它用来维护文档集合中出现过的所有单词的相关信息，同时用来记载某个单词对应的倒排列表在倒排文件中的位置信息。在支持搜索时，根据用户的查询词，去单词词典里查询，就能够获得相应的倒排列表，并以此作为后续排序的基础。&lt;/p&gt;
&lt;p&gt;对于一个规模很大的文档集合来说，可能包含几十万甚至上百万的不同单词，能否快速定位某个单词直接影响搜索时的响应速度，所以需要高效的数据结构来对单词词典进行构建和查找，常用的数据结构包括哈希加链表结构和树形词典结构。&lt;/p&gt;
&lt;h3 id=&quot;%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&quot; tabindex=&quot;-1&quot;&gt;倒排索引基础知识&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;文档(Document)：一般搜索引擎的处理对象是互联网网页，而文档这个概念要更宽泛些，代表以文本形式存在的存储对象，相比网页来说，涵盖更多种形式，比如Word，PDF，html，XML等不同格式的文件都可以称之为文档。再比如一封邮件，一条短信，一条微博也可以称之为文档。在本书后续内容，很多情况下会使用文档来表征文本信息。&lt;/li&gt;
&lt;li&gt;文档集合(Document Collection)：由若干文档构成的集合称之为文档集合。比如海量的互联网网页或者说大量的电子邮件都是文档集合的具体例子。&lt;/li&gt;
&lt;li&gt;文档编号(Document ID)：在搜索引擎内部，会将文档集合内每个文档赋予一个唯一的内部编号，以此编号来作为这个文档的唯一标识，这样方便内部处理，每个文档的内部编号即称之为“文档编号”，后文有时会用DocID来便捷地代表文档编号。&lt;/li&gt;
&lt;li&gt;单词编号(Word ID)：与文档编号类似，搜索引擎内部以唯一的编号来表征某个单词，单词编号可以作为某个单词的唯一表征。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Indexer程序就是根据配置好地分词算法，将获取到的记录进行分词，然后用倒排索引做数据结构保存起来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E5%88%86%E8%AF%8D%E7%AE%97%E6%B3%95&quot; tabindex=&quot;-1&quot;&gt;分词算法&lt;/h2&gt;
&lt;h3 id=&quot;%E4%B8%80%E5%85%83%E5%88%86%E8%AF%8D-1&quot; tabindex=&quot;-1&quot;&gt;一元分词&lt;/h3&gt;
&lt;p&gt;一元分词的核心配置&lt;/p&gt;
&lt;p&gt;charsey_type = zh_cn.utf8
ngram_len = 1
ugram_chars = U+4E00..U+9FBF
ngram_len是分词的长度。&lt;/p&gt;
&lt;p&gt;ngram_chars标识要进行一元分词切分模式的字符集。&lt;/p&gt;
&lt;p&gt;原生的Sphinx支持的分词算法是一元分词，这种分词算法是对记录的每个词切割后做索引，这种索引的优点就是覆盖率高，保证每个记录都能被搜索到。缺点就是会生成很大的索引文件，更新索引时会消耗很多的资源。所以，如果不是特殊需求，而且数据不是特别少的时候，都不建议使用一元分词。&lt;/p&gt;
&lt;p&gt;国人在sphinx的基础上开发了支持中文分词的Coreseek。Coreseek与Sphinx唯一的不同就是Coreseek还支持mmseg分词算法做中文分词。&lt;/p&gt;
&lt;h3 id=&quot;mmseg%E5%88%86%E8%AF%8D-1&quot; tabindex=&quot;-1&quot;&gt;mmseg分词&lt;/h3&gt;
&lt;p&gt;mmseg分词算法是基于统计模型的，所以算法的规则也是来自对语料库的分析和数学归纳，因为中文字符没有明确的分界，会导致大量的字符分界歧义，而且，中文里面，词和短语也很难界定，因此，算法除了要做统计和数学归纳之外，还要做歧义的解决。&lt;/p&gt;
&lt;p&gt;在mmseg分词中，有一个叫chunk的概念。&lt;/p&gt;
&lt;p&gt;chunk，是一句话的分词方式。包括一个词条数组和四个规则。&lt;/p&gt;
&lt;p&gt;如：研究生命，有“研究/生命”和“研究生/命”两种分词方式，这就是两个chunk。&lt;/p&gt;
&lt;p&gt;一个chunk有四个属性：长度、平均长度（长度/分词数）、方差、单字自由度（各单词条词频的对数之和）。&lt;/p&gt;
&lt;p&gt;做好分词之后，会得到多种分词方式，这时候就要使用一些过滤规则来完成歧义的解决，以得到最终的分词方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;歧义解决规则:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、最大匹配
匹配最大长度的词。如“国际化”，有“国际/化”、“国际化”两种分词方式，选择后者。&lt;/p&gt;
&lt;p&gt;2、最大平均词长度
匹配平均词最大的chunk。如“南京市长江大桥”，有“南京市/长江大桥”、“南京/市长/江大桥”三种分词方式，前者平均词长度是7/2=3.5，后者是7/3=2.3，故选择前者的分词方式。&lt;/p&gt;
&lt;p&gt;3、最大方差
去方差最大的chunk。如“研究生命科学”，有“研究生/命/科学”、“研究/生命/科学“两种分词方式，而它们的词长都一样是2。所以需要继续过滤，前者方差是0.82，后者方差是0。所以选择第一种分词方式。&lt;/p&gt;
&lt;p&gt;4、最大单字自由度
选择单个字出现最高频率的chunk。比如”主要是因为“，有”主要/是/因为“，”主/要是/因为“两种分词方式，它们的词长、方差都一样，而”是“的词频较高，所以选择第一种分词方式。&lt;/p&gt;
&lt;p&gt;如果经过上述四个规则的过滤，剩下的chunk仍然大于一，那这个算法也无能为力了，只能自己写扩展完成。&lt;/p&gt;
&lt;h2 id=&quot;%E6%9C%80%E5%90%8E%E7%9A%84%E6%9C%80%E5%90%8E&quot; tabindex=&quot;-1&quot;&gt;最后的最后&lt;/h2&gt;
&lt;p&gt;当然，有人会说数据库的索引也可以做到sphinx索引，只是数据结构不一样而已，但是，最大的不同是sphinx就像一张没有任何关系查询支持的单表数据库。而且，索引主要用在搜索功能的实现而不是主要的数据来源。因此，你的数据库也许是符合第三范式的，但索引会完全被非规范化而且主要包含需要被搜索的数据。
另外一点，大部分数据库都会遭遇一个内部碎片的问题，它们需要在一个大请求里遭遇太多的半随机I/O任务。那就是说，考虑一个在数据库的索引中，查询指向索引，索引指向数据，如果数据因为碎片问题被分开在不同的磁盘中，那么此次查询将占用很长的时间。&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过一个项目的实践，发现sphinx的使用要点主要在配置文件上，如果懂得配置了，那么基本用法很容易掌握。如果要深入研究，比如研究其工作原理，那就得查阅更多的资料。高级特性还没有用到，日后用到再做分享。最后，如果还想扩展sphinx，定制更强大的功能，可以直接阅读源代码，然后编写扩展。使用sphinx也有弊端，如果需要保证高质量的搜索，那么就要经常手动维护词库。如果不能保持经常更新词库，那么可以考虑百度搜索之类的插件。如果可以加入机器学习的话，那么会更好。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，请点下推荐，写文章不容易。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>FreeCodeCamp学习知识点汇总</title>
    <link href="https://hoohack.me/blog/2016/2016-04-05-learning-on-freecodecamp-konwledge-points/"/>
    <updated>2016-04-05T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-04-05-learning-on-freecodecamp-konwledge-points/</id>
    <content type="html">&lt;p&gt;这段时间在FreeCodeCamp这个平台上学习前端知识，上面的练习题都很不错，推荐大家去学习。学习了一段时间，记录下了一些知识点，在这里总结分享。&lt;/p&gt;
&lt;h2 id=&quot;arguments%E6%95%B0%E7%BB%84&quot; tabindex=&quot;-1&quot;&gt;arguments数组&lt;/h2&gt;
&lt;p&gt;当需要使用arguments数组时，最好的方法就是转换成一个新数组。&lt;/p&gt;
&lt;p&gt;var args = Array.prototype.slice.call(arguments);&lt;/p&gt;
&lt;h2 id=&quot;%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6&quot; tabindex=&quot;-1&quot;&gt;修改字符串中的字符&lt;/h2&gt;
&lt;p&gt;_&lt;/p&gt;
&lt;p&gt;可以新生成字符串变量；或者也可以使用如下方法：&lt;/p&gt;
&lt;p&gt;String.prototype.replaceAt = function(index, character) {
return this.substr(0, index) + character + this.substr(index + characyer.length);
}&lt;/p&gt;
&lt;h2 id=&quot;javascript%E5%8A%A0%E6%B3%95&quot; tabindex=&quot;-1&quot;&gt;javascript加法&lt;/h2&gt;
&lt;p&gt;遇到数字相加，应该用Number强制转换类型，不然会出现字符串连接的情况。&lt;/p&gt;
&lt;h2 id=&quot;no-&#39;access-control-allow-origin&#39;-header-is-present-on-the-requested-resource&quot; tabindex=&quot;-1&quot;&gt;No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource&lt;/h2&gt;
&lt;p&gt;把ajax请求的dataType改为JSONP&lt;/p&gt;
&lt;h2 id=&quot;css%E7%94%BB%E5%9C%88&quot; tabindex=&quot;-1&quot;&gt;CSS画圈&lt;/h2&gt;
&lt;p&gt;使用一个长宽相同的div，然后border-radius画圆，设置background颜色可以画空心圆，然后绝对定位。&lt;/p&gt;
&lt;h2 id=&quot;css%E7%94%BB%E6%90%9C%E7%B4%A2%E5%9B%BE%E6%A0%87&quot; tabindex=&quot;-1&quot;&gt;CSS画搜索图标&lt;/h2&gt;
&lt;p&gt;一个圈加一条旋转的线。&lt;/p&gt;
&lt;h2 id=&quot;input%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E&quot; tabindex=&quot;-1&quot;&gt;input背景透明&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;background-color:transparent;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E5%88%A0%E9%99%A4%E7%A9%BA%E7%99%BD%E5%AD%97%E7%AC%A6&quot; tabindex=&quot;-1&quot;&gt;删除空白字符&lt;/h2&gt;
&lt;p&gt;可以用空字符replace。&lt;/p&gt;
&lt;h2 id=&quot;%E6%9B%BF%E6%8D%A2%E6%89%80%E6%9C%89%E5%87%BA%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%EF%BC%8C&quot; tabindex=&quot;-1&quot;&gt;替换所有出现字符串的单个字符，&lt;/h2&gt;
&lt;p&gt;使用该字符new一个正则：new RegExp(char, &#39;g&#39;);&lt;/p&gt;
&lt;h2 id=&quot;%E5%8E%BB%E9%99%A4%E6%95%B0%E7%BB%84%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%8C&quot; tabindex=&quot;-1&quot;&gt;去除数组的重复元素，&lt;/h2&gt;
&lt;p&gt;调用filter函数，然后过滤条件是return arr.indexOf(item) === iex;
说明，如果元素第一次出现的位置跟当前位置不一样，说明有重复的元素，那么将其删除掉。&lt;/p&gt;
&lt;h2 id=&quot;objects.keys&quot; tabindex=&quot;-1&quot;&gt;Objects.keys&lt;/h2&gt;
&lt;p&gt;Objects.keys只收集自身属性名，不收集继承自原继承链上的。在对象中使用this创建keys。&lt;/p&gt;
&lt;h2 id=&quot;%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD&quot; tabindex=&quot;-1&quot;&gt;垂直居中&lt;/h2&gt;
&lt;p&gt;line-height设置为该对象的值&lt;/p&gt;
&lt;h2 id=&quot;jquery-ready-%E6%96%B9%E6%B3%95&quot; tabindex=&quot;-1&quot;&gt;jQuery ready 方法&lt;/h2&gt;
&lt;p&gt;语法1：&lt;/p&gt;
&lt;p&gt;$(document).ready(&lt;em&gt;function&lt;/em&gt;)&lt;/p&gt;
&lt;p&gt;语法2：&lt;/p&gt;
&lt;p&gt;$().ready(&lt;em&gt;function&lt;/em&gt;)&lt;/p&gt;
&lt;p&gt;语法3：&lt;/p&gt;
&lt;p&gt;$(&lt;em&gt;function&lt;/em&gt;)&lt;/p&gt;
&lt;h2 id=&quot;%E9%98%BB%E6%AD%A2%E5%85%83%E7%B4%A0%E8%A2%AB%E9%80%89%E4%B8%AD&quot; tabindex=&quot;-1&quot;&gt;阻止元素被选中&lt;/h2&gt;
&lt;p&gt;-webkit-user-select: none;/-moz-user-select: none;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>【读书笔记】代码整洁之道</title>
    <link href="https://hoohack.me/blog/2016/2016-03-23-code-clean-read-note/"/>
    <updated>2016-03-23T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-03-23-code-clean-read-note/</id>
    <content type="html">&lt;h2 id=&quot;%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B4%E6%B4%81%E4%BB%A3%E7%A0%81&quot; tabindex=&quot;-1&quot;&gt;第一章 整洁代码&lt;/h2&gt;
&lt;p&gt;赶上期限的唯一方法：始终尽可能保持代码整洁。&lt;/p&gt;
&lt;p&gt;整洁的代码只做好一件事。&lt;/p&gt;
&lt;p&gt;整本书的主旨，不要重复代码，只做一件事，表达力，小规模抽象。&lt;/p&gt;
&lt;p&gt;要想干得快，要想快点做完，要想轻松写代码，先让代码易读吧。&lt;/p&gt;
&lt;p&gt;让每次签入时，代码都比签出时干净。&lt;/p&gt;
&lt;h2 id=&quot;%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%8C%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84%E5%91%BD%E5%90%8D&quot; tabindex=&quot;-1&quot;&gt;第二章，有意义的命名&lt;/h2&gt;
&lt;p&gt;1、名副其实&lt;/p&gt;
&lt;p&gt;如果名称需要注释来补充，那就不算是名副其实。&lt;/p&gt;
&lt;p&gt;2、避免误导&lt;/p&gt;
&lt;p&gt;别用xxxList来指称一组账号，除非它真的是List类型。（用xxxGroup/bunchOfxxx/xxxs代替更好）&lt;/p&gt;
&lt;p&gt;3、做有意义的区分&lt;/p&gt;
&lt;p&gt;不要使用数字区分变量/函数命名。如a1,a2,...&lt;/p&gt;
&lt;p&gt;不要添加废话区分命名。如：ProductInfo和ProductData&lt;/p&gt;
&lt;p&gt;4、使用读得出来的名称&lt;/p&gt;
&lt;p&gt;比如日期：用generationTimestamp，而不要使用genymdhms。&lt;/p&gt;
&lt;p&gt;5、使用可搜索的名称&lt;/p&gt;
&lt;p&gt;单字母和数字常量很难搜出。使用宏或者变量命名这类数据。&lt;/p&gt;
&lt;p&gt;6、避免使用编码&lt;/p&gt;
&lt;p&gt;不必用前缀表示成员变量。&lt;/p&gt;
&lt;p&gt;7、避免思维映射&lt;/p&gt;
&lt;p&gt;8、类名&lt;/p&gt;
&lt;p&gt;类名和对象应该是名词或名词短语。&lt;/p&gt;
&lt;p&gt;9、方法名&lt;/p&gt;
&lt;p&gt;方法名应该是动词或动词短语。&lt;/p&gt;
&lt;p&gt;10、别扮可爱&lt;/p&gt;
&lt;p&gt;11、每个概念对应一个词&lt;/p&gt;
&lt;p&gt;12、别用双关语&lt;/p&gt;
&lt;p&gt;避免将同一个单词用于不同目的。&lt;/p&gt;
&lt;p&gt;13、使用解决方案领域名称&lt;/p&gt;
&lt;p&gt;尽可能使用IT类术语&lt;/p&gt;
&lt;p&gt;14、使用源自所涉问题领域的名称&lt;/p&gt;
&lt;p&gt;15、使用有意义的语境&lt;/p&gt;
&lt;p&gt;如：使用addrState代替state&lt;/p&gt;
&lt;p&gt;16、不要添加没用的语境&lt;/p&gt;
&lt;p&gt;如：不要用GSD代替GasStationDeluxe这样类似的短语。&lt;/p&gt;
&lt;h2 id=&quot;%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%87%BD%E6%95%B0&quot; tabindex=&quot;-1&quot;&gt;第三章 函数&lt;/h2&gt;
&lt;p&gt;函数的第一规则是要短小，第二规则是还要更短小。&lt;/p&gt;
&lt;p&gt;函数的缩进层数不该多于一层或两层。&lt;/p&gt;
&lt;p&gt;函数应该做一件事，做好这件事，只做这一件事。&lt;/p&gt;
&lt;p&gt;要判断函数是否不止做了一件事，看是否能再拆出一个函数，该函数不仅是单纯地重新诠释其实现。&lt;/p&gt;
&lt;p&gt;函数参数，最理想的参数是0,其次是1,再次是2.尽量避免3个。有足够特殊的理由才能用3个以上函数。&lt;/p&gt;
&lt;p&gt;如果函数看起来需要两个，三个或三个以上参数，就说明其中一些参数应该封装成类了。&lt;/p&gt;
&lt;p&gt;函数不应有副作用，如，检查密码的函数不应该有初始化Session的步骤。&lt;/p&gt;
&lt;p&gt;把指令和询问分隔开来。&lt;/p&gt;
&lt;p&gt;别重复自己。&lt;/p&gt;
&lt;p&gt;如何做到：先想些什么就写什么，然后再打磨它。&lt;/p&gt;
&lt;h2 id=&quot;%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%B3%A8%E9%87%8A&quot; tabindex=&quot;-1&quot;&gt;第四章 注释&lt;/h2&gt;
&lt;p&gt;注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。&lt;/p&gt;
&lt;p&gt;注释会撒谎，因为修改代码后并不会让注释随之变动。&lt;/p&gt;
&lt;p&gt;注释不会美化糟糕的代码。&lt;/p&gt;
&lt;p&gt;与其花时间美化代码，不如花时间清洁代码。&lt;/p&gt;
&lt;p&gt;好注释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、法律信息&lt;/p&gt;
&lt;p&gt;2、提供信息的注释&lt;/p&gt;
&lt;p&gt;3、对意图的注释&lt;/p&gt;
&lt;p&gt;4、阐释&lt;/p&gt;
&lt;p&gt;5、警示&lt;/p&gt;
&lt;p&gt;6、TODO&lt;/p&gt;
&lt;p&gt;7、放大：放大某种看起来不合理之物的重要性&lt;/p&gt;
&lt;p&gt;8、公共API中的javadoc&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;坏注释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、喃喃自语&lt;/p&gt;
&lt;p&gt;2、多余的注释&lt;/p&gt;
&lt;p&gt;3、误导性注释&lt;/p&gt;
&lt;p&gt;4、循规式注释&lt;/p&gt;
&lt;p&gt;5、日志式注释&lt;/p&gt;
&lt;p&gt;6、废话注释&lt;/p&gt;
&lt;p&gt;7、可怕的废话&lt;/p&gt;
&lt;p&gt;8、能用函数或变量时就别用注释&lt;/p&gt;
&lt;p&gt;9、位置标记&lt;/p&gt;
&lt;p&gt;10、括号后面的注释&lt;/p&gt;
&lt;p&gt;11、归属和署名&lt;/p&gt;
&lt;p&gt;12、注释掉的代码（别这么干）&lt;/p&gt;
&lt;p&gt;13、html注释&lt;/p&gt;
&lt;p&gt;14、非本地信息&lt;/p&gt;
&lt;p&gt;15、信息过多&lt;/p&gt;
&lt;p&gt;16、不明显的联系&lt;/p&gt;
&lt;p&gt;17、函数头&lt;/p&gt;
&lt;p&gt;18、非公共代码中的javadoc&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%BC%E5%BC%8F&quot; tabindex=&quot;-1&quot;&gt;第五章 格式&lt;/h2&gt;
&lt;p&gt;代码格式很重要，关乎沟通。&lt;/p&gt;
&lt;p&gt;实体变量应该在类的顶部声明。&lt;/p&gt;
&lt;p&gt;相关函数。若某个函数调用了另一个，就应该把它们放到一起。而且调用着应该尽可能放在被调用着上面。&lt;/p&gt;
&lt;p&gt;四则运算时，运算级较高的符号可以不用空格隔开。&lt;/p&gt;
&lt;p&gt;每个程序员都有自己喜欢的格式规则，但如果在一个团队中工作，就是团队说了算。&lt;/p&gt;
&lt;h2 id=&quot;%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&quot; tabindex=&quot;-1&quot;&gt;第六章 对象和数据结构&lt;/h2&gt;
&lt;p&gt;隐藏实现并非只是变量之间放上一个函数层那么简单。隐藏实现关乎抽象。类并不简单地用取值器和赋值器将变量推向外间，而是暴露抽象接口，以便用户无需了解数据的实现便能操作数据本体。&lt;/p&gt;
&lt;p&gt;要以最好的方式呈现某个对象包含的数据，需要做严肃的思考。&lt;/p&gt;
&lt;p&gt;过程式代码便于在不改动既有函数的前提下添加新类。&lt;/p&gt;
&lt;p&gt;得墨耳律：模块不应了解它所操作对象的内部情形。&lt;/p&gt;
&lt;p&gt;例如：类C的f方法只应调用以下对象的方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;C
由f创建的对象&lt;/p&gt;
&lt;p&gt;由C的实体变量持有的对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;即：方法不应调用由任何函数返回的对象的方法。&lt;/p&gt;
&lt;h2 id=&quot;%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86&quot; tabindex=&quot;-1&quot;&gt;第七章 错误处理&lt;/h2&gt;
&lt;p&gt;使用异常而非返回码。
先写try、catch、finally语句&lt;/p&gt;
&lt;p&gt;使用不可控异常&lt;/p&gt;
&lt;p&gt;给出异常发生的环境说明。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;应创建信息充分的错误信息，并和异常一起传递出去。在消息中，包括失败的操作和失败的类型。如果你的应用程序由日志系统，传递足够的信息给catch块，并记录下来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;依调用者需要定义异常类。&lt;/p&gt;
&lt;p&gt;定义常规流程。&lt;/p&gt;
&lt;p&gt;别返回null值。&lt;/p&gt;
&lt;p&gt;别传递null值。&lt;/p&gt;
&lt;h2 id=&quot;%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95&quot; tabindex=&quot;-1&quot;&gt;第九章 单元测试&lt;/h2&gt;
&lt;h3 id=&quot;tdd%E4%B8%89%E5%AE%9A%E5%BE%8B&quot; tabindex=&quot;-1&quot;&gt;TDD三定律&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;1、在编写不能通过的单元测试前，不可编写生产代码。&lt;/p&gt;
&lt;p&gt;2、只可编写刚好无法通过的单元测试，不能编译也不算通过。&lt;/p&gt;
&lt;p&gt;3、只可编写刚好足以通过当前失败测试的生产代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;保持测试整洁。&lt;/p&gt;
&lt;p&gt;脏测试等同于没测试。&lt;/p&gt;
&lt;p&gt;测试代码和生产代码一样重要。&lt;/p&gt;
&lt;p&gt;整洁的测试三要素：可读性，可读性和可读性。&lt;/p&gt;
&lt;p&gt;每个测试一个断言。&lt;/p&gt;
&lt;p&gt;每个测试只测试一个概念。&lt;/p&gt;
&lt;h3 id=&quot;f.i.r.s.t.&quot; tabindex=&quot;-1&quot;&gt;F.I.R.S.T.&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Fast(快速)、Independent(独立)、Repeatable(可重复)、Self-Validating(自足验证)、Timely(及时)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B1%BB&quot; tabindex=&quot;-1&quot;&gt;第十章 类&lt;/h2&gt;
&lt;p&gt;类应该短小。&lt;/p&gt;
&lt;p&gt;用权责衡量类的大小。&lt;/p&gt;
&lt;p&gt;如果无法为某个类命以精确的名称，这个类大概太长了。&lt;/p&gt;
&lt;p&gt;SRP，单一权责原则，类或模块应有且只有一条加以修改的理由。&lt;/p&gt;
&lt;p&gt;系统应该有许多短小的类而不是少量巨大的类组成。每个小雷封装一个权责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为。&lt;/p&gt;
&lt;p&gt;内聚：如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。&lt;/p&gt;
&lt;h2 id=&quot;%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%B3%BB%E7%BB%9F&quot; tabindex=&quot;-1&quot;&gt;第十一章 系统&lt;/h2&gt;
&lt;p&gt;将构造与使用分开的方法之一是将全部构造过程搬迁到main或被称之为main的模块中，设计系统的其他部分时，假设所有对象都已正确构造和设置。&lt;/p&gt;
&lt;p&gt;使用工厂方法，让程序负责确定何时创建对象。&lt;/p&gt;
&lt;p&gt;AOP 切面编程&lt;/p&gt;
&lt;h2 id=&quot;%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E8%BF%AD%E8%BF%9B&quot; tabindex=&quot;-1&quot;&gt;第十二章 迭进&lt;/h2&gt;
&lt;p&gt;简单设计四条规则：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;运行所有测试；&lt;/p&gt;
&lt;p&gt;不可重复；&lt;/p&gt;
&lt;p&gt;表达了程序员的意图；&lt;/p&gt;
&lt;p&gt;尽可能减少类和方法的数量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;极其雷同的代码就是重复。&lt;/p&gt;
&lt;p&gt;要想实现大规模复用，必须理解如何实现小规模复用。&lt;/p&gt;
&lt;p&gt;模板方法模式是一种移除高层级重复的通用技巧&lt;/p&gt;
&lt;h2 id=&quot;%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B&quot; tabindex=&quot;-1&quot;&gt;第十三章 并发编程&lt;/h2&gt;
&lt;p&gt;对象是过程的抽象，线程是调度的抽象。&lt;/p&gt;
&lt;p&gt;并发是一种解耦策略，帮助我们把做什么（目的）和何时（时间）做分解开。&lt;/p&gt;
&lt;p&gt;并发会在性能和编写额外代码上增加一些开销。&lt;/p&gt;
&lt;p&gt;正确的并发是复杂的，即便对于简单的问题也是如此。&lt;/p&gt;
&lt;p&gt;并发缺陷并非总能重现，所以常被看做偶发事件而忽略，未被当作真的缺陷对待。&lt;/p&gt;
&lt;p&gt;并发常常需要对设计策略的根本性修改。&lt;/p&gt;
&lt;h3 id=&quot;%E5%B9%B6%E5%8F%91%E9%98%B2%E5%BE%A1%E5%8E%9F%E5%88%99%EF%BC%9A&quot; tabindex=&quot;-1&quot;&gt;并发防御原则：&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;1、SRP，分离并发相关代码和其他代码。&lt;/p&gt;
&lt;p&gt;2、推论：限制数据作用域。&lt;/p&gt;
&lt;p&gt;3、推论：使用数据复本，避免共享数据的好方法之一就是一开始就避免共享数据。&lt;/p&gt;
&lt;p&gt;4、推论：线程应尽可能独立。尝试将数据分解到可独立线程（可能在不同处理器上）操作的独立子集。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B&quot; tabindex=&quot;-1&quot;&gt;并发执行模型&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;生产者－消费者&lt;/p&gt;
&lt;p&gt;读者－作者&lt;/p&gt;
&lt;p&gt;宴席哲学家&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;学习这些基础算法，理解其解决方案。&lt;/p&gt;
&lt;p&gt;在你认为自己完成某个函数之前，确认自己理解了它是怎么工作的。通过全部测试还不够好。你必须知道解决方案是正确的。获得这种知识和理解的最好途径，往往是重构函数，得到某种整洁而足具表达力、清楚呈示如何工作的东西。&lt;/p&gt;
&lt;p&gt;用多态替代If/Else或Switch/Case&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;看了这本书，得到了很多新的指导，建议。这确实是一本好书，作者表达很清晰，说明白了该怎么做。虽然知道了，但是还是得要根据当中的理论多去实践才能体会当中的精髓。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>在OpenSUSE上编译安装sphinx扩展</title>
    <link href="https://hoohack.me/blog/2016/2016-03-18-compile-install-sphinx-extend-on-opensuse/"/>
    <updated>2016-03-18T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-03-18-compile-install-sphinx-extend-on-opensuse/</id>
    <content type="html">&lt;h2 id=&quot;%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C&quot; tabindex=&quot;-1&quot;&gt;准备工作&lt;/h2&gt;
&lt;p&gt;要在PHP中安装sphinx扩展，你必须先安装好sphinx，笔者使用的是中文分词，因此我安装的是coreseek。&lt;/p&gt;
&lt;p&gt;如何安装coreseek请看：&lt;a href=&quot;http://www.coreseek.cn/products-install/install_on_bsd_linux/&quot;&gt;http://www.coreseek.cn/products-install/install_on_bsd_linux/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B&quot; tabindex=&quot;-1&quot;&gt;安装过程&lt;/h2&gt;
&lt;p&gt;安装过程：&lt;/p&gt;
&lt;p&gt;1、安装libsphinclient&lt;/p&gt;
&lt;p&gt;2、安装PHP sphinx扩展模块&lt;/p&gt;
&lt;p&gt;3、PHP配置&lt;/p&gt;
&lt;p&gt;4、测试&lt;/p&gt;
&lt;h3 id=&quot;%E5%AE%89%E8%A3%85libsphinxclient&quot; tabindex=&quot;-1&quot;&gt;安装libsphinxclient&lt;/h3&gt;
&lt;p&gt;进入coreseek的代码目录&lt;/p&gt;
&lt;p&gt;cd /usr/local/src/coreseek-4.1-beta/csft-4.1/api/libsphinxclient
./configure  --prefix=/usr/local/sphinx
make &amp;amp;&amp;amp; make install&lt;/p&gt;
&lt;h3 id=&quot;%E5%AE%89%E8%A3%85php-sphinx%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97&quot; tabindex=&quot;-1&quot;&gt;安装PHP sphinx扩展模块&lt;/h3&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://pecl.php.net/package/sphinx&quot;&gt;https://pecl.php.net/package/sphinx&lt;/a&gt;。下载你想要的版本。&lt;/p&gt;
&lt;p&gt;tar -zxvf sphinx-1.3.3.tgz
cd sphinx-1.3.3
/usr/local/php/bin/phpize
./configure --with-php-config=/usr/local/php/bin/php-config --with-sphinx=/usr/local/sphinx/
make &amp;amp;&amp;amp; make install&lt;/p&gt;
&lt;h3 id=&quot;php%E9%85%8D%E7%BD%AE&quot; tabindex=&quot;-1&quot;&gt;PHP配置&lt;/h3&gt;
&lt;p&gt;修改php.ini文件，将&lt;code&gt;extension=sphinx.so&lt;/code&gt;添加到扩展选项部分。&lt;/p&gt;
&lt;h3 id=&quot;%E6%B5%8B%E8%AF%95%E5%AE%89%E8%A3%85%E7%BB%93%E6%9E%9C&quot; tabindex=&quot;-1&quot;&gt;测试安装结果&lt;/h3&gt;
&lt;p&gt;重启php，输入&lt;code&gt;php -m | grep &#39;sphinx&#39;&lt;/code&gt;查看是否安装成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/sphinx-result.png&quot; alt=&quot;sphinx-result&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3&quot; tabindex=&quot;-1&quot;&gt;错误解决&lt;/h2&gt;
&lt;p&gt;在安装的过程中，遇到一个比较二的错误。加了&lt;code&gt;extension=sphinx.so&lt;/code&gt;，运行&lt;code&gt;php -m&lt;/code&gt;的时候一直报错。错误信息如下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PHP Warning:  PHP Startup: Unable to load dynamic library &#39;/usr/local/php/lib/php/extensions/no-debug-non-zts-20100525/sphinx.so&#39; - &lt;a href=&quot;http://libsphinxclient-0.0.1.so/&quot;&gt;libsphinxclient-0.0.1.so&lt;/a&gt;: cannot open shared object file: No such file or directory in Unknown on line 0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的错误是软件无法加载依赖库，但是之前安装的&lt;code&gt;libsphinxclient&lt;/code&gt;依赖库是存在的。于是我就找了旁边的同事帮我看，然后其实同事也不懂，但是呢，他跟我一起思考，他叫我一起看看日志文件，一起想出哪一步出错了。我们发现，安装前几步没有问题，一直到要安装的软件找不到某个依赖库才出错，那需要的库安装在哪呢，在那个地方吗？因此找一下，发现，在呀，然后我看到错误显示的路径时，突然恍然大悟，这个软件从哪里搜索这个库呢？会不会是另一个目录呢？然后看一下配置文件，发现真的是搜索的地方错误了啊，因为电脑是64位的，因此之前安装依赖的时候安装到了64位的库了，而安装的扩展是从32的库目录寻找依赖库的。问题终于解决。&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;在opensuse下，很多时候安装和搜索依赖库的目录是不一致的，应当仔细检查。在解决问题的时候，如果花了很多时间都解决不了，这个时候，找一个人，把你遇到的问题清楚地描述一遍，然后一起解决，也许他不懂，但是他思考的方向也许是你忽略掉的，然而他会引导你往一个新的方向思考，然后你就会发现你忽略了一些东西，这个时候，问题就解决了，别人可能没有做任何事情，只是跟你聊聊天，问题就解决了。所以往往会遇到谢谢别人别人都不知道你感谢他什么。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你觉得本文对你有帮助或者觉得不错，望点下推荐，写文章不容易。&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>【性能为王】从PHP源码剖析array_keys和array_unique</title>
    <link href="https://hoohack.me/blog/2016/2016-02-25-analyze-array-unique-array-keys-source-code/"/>
    <updated>2016-02-25T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-02-25-analyze-array-unique-array-keys-source-code/</id>
    <content type="html">&lt;p&gt;之前在&lt;a href=&quot;https://www.hoohack.me/2016/01/11/faster-way-to-phps-array-unique-function/&quot;&gt;[译]更快的方式实现PHP数组去重&lt;/a&gt;这篇文章里讨论了使用array_flip后再调用array_keys函数替换直接调用array_unique函数实现数组去重性能较好。由于原文没有给出源码分析和测试的结果，导致给读者造成迷惑，在此说声抱歉。为了解开读者的疑惑，笔者承诺了会补上源码的分析，于是花了一些时间去研究PHP的源码，现在此补上详细的说明。&lt;/p&gt;
&lt;p&gt;我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/read-php-src/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/read-php-src/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90&quot; tabindex=&quot;-1&quot;&gt;性能分析&lt;/h2&gt;
&lt;p&gt;从运行性能上分析，看看下面的测试代码：&lt;/p&gt;
&lt;p&gt;$test=array();
for($run=0; $run&amp;lt;10000; $run++)
$test[]=rand(0,100);&lt;/p&gt;
&lt;p&gt;$time=microtime(true);&lt;/p&gt;
&lt;p&gt;$out = array_unique($test);&lt;/p&gt;
&lt;p&gt;$time=microtime(true)-$time;
echo &#39;Array Unique: &#39;.$time.&amp;quot;&#92;n&amp;quot;;&lt;/p&gt;
&lt;p&gt;$time=microtime(true);&lt;/p&gt;
&lt;p&gt;$out=array_keys(array_flip($test));&lt;/p&gt;
&lt;p&gt;$time=microtime(true)-$time;
echo &#39;Keys Flip: &#39;.$time.&amp;quot;&#92;n&amp;quot;;&lt;/p&gt;
&lt;p&gt;$time=microtime(true);&lt;/p&gt;
&lt;p&gt;$out=array_flip(array_flip($test));&lt;/p&gt;
&lt;p&gt;$time=microtime(true)-$time;
echo &#39;Flip Flip: &#39;.$time.&amp;quot;&#92;n&amp;quot;;&lt;/p&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/php_array_unique_vs_keys.png&quot; alt=&quot;php array_unique vs array_keys&quot; /&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看到，使用array_unique函数需要0.069s;使用array_flip后再使用array_keys函数需要0.00152s;使用两次array_flip函数需要0.00146s。&lt;/p&gt;
&lt;p&gt;测试结果表明，使用array_flip后再调用array_keys函数比array_unique函数快。那么，具体原因是什么呢？让我们看看在PHP底层，这两个函数是怎么实现的。&lt;/p&gt;
&lt;h2 id=&quot;%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90&quot; tabindex=&quot;-1&quot;&gt;源码分析&lt;/h2&gt;
&lt;p&gt;/* {{{ proto array array_keys(array input [, mixed search_value[, bool strict]]) Return just the keys from the input array, optionally only for the specified search_value */
PHP_FUNCTION(array_keys)
{
//变量定义
zval &lt;em&gt;input,                /&lt;/em&gt; Input array */
&lt;em&gt;search_value = NULL,    /&lt;/em&gt; Value to search for */
*&lt;em&gt;entry,                /&lt;/em&gt; An entry in the input array &lt;em&gt;/
res,                    /&lt;/em&gt; Result of comparison */
&lt;em&gt;new_val;                /&lt;/em&gt; New value &lt;em&gt;/
int    add_key;                /&lt;/em&gt; Flag to indicate whether a key should be added */
char  &lt;em&gt;string_key;            /&lt;/em&gt; String key &lt;em&gt;/
uint   string_key_len;
ulong  num_key;                /&lt;/em&gt; Numeric key &lt;em&gt;/
zend_bool strict = 0;        /&lt;/em&gt; do strict comparison */
HashPosition pos;
int (*is_equal_func)(zval *, zval *, zval * TSRMLS_DC) = is_equal_function;&lt;/p&gt;
&lt;p&gt;//程序解析参数
if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &amp;quot;a|zb&amp;quot;, &amp;amp;input, &amp;amp;search_value, &amp;amp;strict) == FAILURE) {
return;
}&lt;/p&gt;
&lt;p&gt;// 如果strict是true，则设置is_equal_func为is_identical_function，即全等比较
if (strict) {
is_equal_func = is_identical_function;
}&lt;/p&gt;
&lt;p&gt;/* 根据search_vale初始化返回的数组大小 */
if (search_value != NULL) {
array_init(return_value);
} else {
array_init_size(return_value, zend_hash_num_elements(Z_ARRVAL_P(input)));
}
add_key = 1;&lt;/p&gt;
&lt;p&gt;/* 遍历输入的数组参数，然后添加键值到返回的数组 */
zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(input), &amp;amp;pos);//重置指针
//循环遍历数组
while (zend_hash_get_current_data_ex(Z_ARRVAL_P(input), (void **)&amp;amp;entry, &amp;amp;pos) == SUCCESS) {
// 如果search_value不为空
if (search_value != NULL) {
// 判断search_value与当前的值是否相同，并将比较结果保存到add_key变量
is_equal_func(&amp;amp;res, search_value, *entry TSRMLS_CC);
add_key = zval_is_true(&amp;amp;res);
}&lt;/p&gt;
&lt;p&gt;if (add_key) {
// 创建一个zval结构体
MAKE_STD_ZVAL(new_val);&lt;/p&gt;
&lt;p&gt;// 根据键值是字符串还是整型数字将值插入到return_value中
switch (zend_hash_get_current_key_ex(Z_ARRVAL_P(input), &amp;amp;string_key, &amp;amp;string_key_len, &amp;amp;num_key, 1, &amp;amp;pos)) {
case HASH_KEY_IS_STRING:
ZVAL_STRINGL(new_val, string_key, string_key_len - 1, 0);
// 此函数负责将值插入到return_value中，如果键值已存在，则使用新值更新对应的值，否则直接插入
zend_hash_next_index_insert(Z_ARRVAL_P(return_value), &amp;amp;new_val, sizeof(zval *), NULL);
break;&lt;/p&gt;
&lt;p&gt;case HASH_KEY_IS_LONG:
Z_TYPE_P(new_val) = IS_LONG;
Z_LVAL_P(new_val) = num_key;
zend_hash_next_index_insert(Z_ARRVAL_P(return_value), &amp;amp;new_val, sizeof(zval *), NULL);
break;
}
}&lt;/p&gt;
&lt;p&gt;// 移动到下一个
zend_hash_move_forward_ex(Z_ARRVAL_P(input), &amp;amp;pos);
}
}
/* }}} */&lt;/p&gt;
&lt;p&gt;以上是array_keys函数底层的源码。为方便理解，笔者添加了一些中文注释。如果需要查看原始代码，可以点击查看。这个函数的功能就是新建一个临时数组，然后将键值对重新复制到新的数组，如果复制过程中有重复的键值出现，那么就用新的值替换。这个函数的主要步骤是地57和63行调用的zend_hash_next_index_insert函数。该函数将元素插入到数组中，如果出现重复的值，则使用新的值更新原键值指向的值，否则直接插入，时间复杂度是O(n)。&lt;/p&gt;
&lt;p&gt;/* {{{ proto array array_flip(array input)
Return array with key &amp;lt;-&amp;gt; value flipped */
PHP_FUNCTION(array_flip)
{
// 定义变量
zval *array, **entry, *data;
char *string_key;
uint str_key_len;
ulong num_key;
HashPosition pos;&lt;/p&gt;
&lt;p&gt;// 解析数组参数
if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &amp;quot;a&amp;quot;, &amp;amp;array) == FAILURE) {
return;
}&lt;/p&gt;
&lt;p&gt;// 初始化返回数组
array_init_size(return_value, zend_hash_num_elements(Z_ARRVAL_P(array)));&lt;/p&gt;
&lt;p&gt;// 重置指针
zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(array), &amp;amp;pos);
// 遍历每个元素，并执行键&amp;lt;-&amp;gt;值交换操作
while (zend_hash_get_current_data_ex(Z_ARRVAL_P(array), (void **)&amp;amp;entry, &amp;amp;pos) == SUCCESS) {
// 初始化一个结构体
MAKE_STD_ZVAL(data);
// 将原数组的值赋值为新数组的键
switch (zend_hash_get_current_key_ex(Z_ARRVAL_P(array), &amp;amp;string_key, &amp;amp;str_key_len, &amp;amp;num_key, 1, &amp;amp;pos)) {
case HASH_KEY_IS_STRING:
ZVAL_STRINGL(data, string_key, str_key_len - 1, 0);
break;
case HASH_KEY_IS_LONG:
Z_TYPE_P(data) = IS_LONG;
Z_LVAL_P(data) = num_key;
break;
}&lt;/p&gt;
&lt;p&gt;// 将原数组的键赋值为新数组的值，如果有重复的，则使用新值覆盖旧值
if (Z_TYPE_PP(entry) == IS_LONG) {
zend_hash_index_update(Z_ARRVAL_P(return_value), Z_LVAL_PP(entry), &amp;amp;data, sizeof(data), NULL);
} else if (Z_TYPE_PP(entry) == IS_STRING) {
zend_symtable_update(Z_ARRVAL_P(return_value), Z_STRVAL_PP(entry), Z_STRLEN_PP(entry) + 1, &amp;amp;data, sizeof(data), NULL);
} else {
zval_ptr_dtor(&amp;amp;data); /* will free also zval structure */
php_error_docref(NULL TSRMLS_CC, E_WARNING, &amp;quot;Can only flip STRING and INTEGER values!&amp;quot;);
}&lt;/p&gt;
&lt;p&gt;// 下一个
zend_hash_move_forward_ex(Z_ARRVAL_P(array), &amp;amp;pos);
}
}
/* }}} */&lt;/p&gt;
&lt;p&gt;上面就是是array_flip函数的源码。&lt;a href=&quot;http://lxr.php.net/xref/PHP_5_4/ext/standard/array.c#2691&quot;&gt;点击链接&lt;/a&gt;查看原始代码。这个函数主要的做的事情就是创建一个新的数组，遍历原数组。在26行开始将原数组的值赋值为新数组的键，然后在37行开始将原数组的键赋值为新数组的值，如果有重复的，则使用新值覆盖旧值。整个函数的时间复杂度也是O(n)。因此，使用了array_flip之后再使用array_keys的时间复杂度是O(n)。&lt;/p&gt;
&lt;p&gt;接下来，我们看看array_unique函数的源码。&lt;a href=&quot;http://lxr.php.net/xref/PHP_5_4/ext/standard/array.c#2777&quot;&gt;点击链接&lt;/a&gt;查看原始代码。&lt;/p&gt;
&lt;p&gt;/* {{{ proto array array_unique(array input [, int sort_flags])
Removes duplicate values from array */
PHP_FUNCTION(array_unique)
{
// 定义变量
zval *array, *tmp;
Bucket *p;
struct bucketindex {
Bucket *b;
unsigned int i;
};
struct bucketindex *arTmp, *cmpdata, *lastkept;
unsigned int i;
long sort_type = PHP_SORT_STRING;&lt;/p&gt;
&lt;p&gt;// 解析参数
if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &amp;quot;a|l&amp;quot;, &amp;amp;array, &amp;amp;sort_type) == FAILURE) {
return;
}&lt;/p&gt;
&lt;p&gt;// 设置比较函数
php_set_compare_func(sort_type TSRMLS_CC);&lt;/p&gt;
&lt;p&gt;// 初始化返回数组
array_init_size(return_value, zend_hash_num_elements(Z_ARRVAL_P(array)));
// 将值拷贝到新数组
zend_hash_copy(Z_ARRVAL_P(return_value), Z_ARRVAL_P(array), (copy_ctor_func_t) zval_add_ref, (void &lt;em&gt;)&amp;amp;tmp, sizeof(zval&lt;/em&gt;));&lt;/p&gt;
&lt;p&gt;if (Z_ARRVAL_P(array)-&amp;gt;nNumOfElements &amp;lt;= 1) {    /* 什么都不做 */
return;
}&lt;/p&gt;
&lt;p&gt;/* 根据target_hash buckets的指针创建数组并排序 */
arTmp = (struct bucketindex *) pemalloc((Z_ARRVAL_P(array)-&amp;gt;nNumOfElements + 1) * sizeof(struct bucketindex), Z_ARRVAL_P(array)-&amp;gt;persistent);
if (!arTmp) {
zval_dtor(return_value);
RETURN_FALSE;
}
for (i = 0, p = Z_ARRVAL_P(array)-&amp;gt;pListHead; p; i++, p = p-&amp;gt;pListNext) {
arTmp[i].b = p;
arTmp[i].i = i;
}
arTmp[i].b = NULL;
// 排序
zend_qsort((void *) arTmp, i, sizeof(struct bucketindex), php_array_data_compare TSRMLS_CC);&lt;/p&gt;
&lt;p&gt;/* 遍历排序好的数组，然后删除重复的元素 &lt;em&gt;/
lastkept = arTmp;
for (cmpdata = arTmp + 1; cmpdata-&amp;gt;b; cmpdata++) {
if (php_array_data_compare(lastkept, cmpdata TSRMLS_CC)) {
lastkept = cmpdata;
} else {
if (lastkept-&amp;gt;i &amp;gt; cmpdata-&amp;gt;i) {
p = lastkept-&amp;gt;b;
lastkept = cmpdata;
} else {
p = cmpdata-&amp;gt;b;
}
if (p-&amp;gt;nKeyLength == 0) {
zend_hash_index_del(Z_ARRVAL_P(return_value), p-&amp;gt;h);
} else {
if (Z_ARRVAL_P(return_value) == &amp;amp;EG(symbol_table)) {
zend_delete_global_variable(p-&amp;gt;arKey, p-&amp;gt;nKeyLength - 1 TSRMLS_CC);
} else {
zend_hash_quick_del(Z_ARRVAL_P(return_value), p-&amp;gt;arKey, p-&amp;gt;nKeyLength, p-&amp;gt;h);
}
}
}
}
pefree(arTmp, Z_ARRVAL_P(array)-&amp;gt;persistent);
}
/&lt;/em&gt; }}} */&lt;/p&gt;
&lt;p&gt;可以看到，这个函数初始化一个新的数组，然后将值拷贝到新数组，然后在45行调用排序函数对数组进行排序，排序的算法是zend引擎的块树排序算法。接着遍历排序好的数组，删除重复的元素。整个函数开销最大的地方就在调用排序函数上，而快排的时间复杂度是O(n&lt;em&gt;logn)，因此，该函数的时间复杂度是O(n&lt;/em&gt;logn)。&lt;/p&gt;
&lt;h2 id=&quot;%E7%BB%93%E8%AE%BA&quot; tabindex=&quot;-1&quot;&gt;结论&lt;/h2&gt;
&lt;p&gt;因为array_unique底层调用了快排算法，加大了函数运行的时间开销，导致整个函数的运行较慢。这就是为什么array_keys比array_unique函数更快的原因。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;如果本文对你有帮助，望点下推荐，写文章不容易。&lt;/p&gt;
&lt;p&gt;最后再安利一下，我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/read-php-src/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/read-php-src/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>[PHP源码阅读笔记]strlen函数</title>
    <link href="https://hoohack.me/blog/2016/2016-02-22-phps-source-analytics-strlen/"/>
    <updated>2016-02-22T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-02-22-phps-source-analytics-strlen/</id>
    <content type="html">&lt;p&gt;我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/read-php-src/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/read-php-src/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
&lt;p&gt;strlen函数说明。&lt;/p&gt;
&lt;p&gt;int strlen ( string $string )&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.hoohack.me/2016/02/10/understanding-phps-internal-function-definitions-ch&quot;&gt;这篇文章&lt;/a&gt;，我们可以知道&lt;code&gt;strlen&lt;/code&gt;函数是通过Zend Engine定义的。函数的定义可以在&lt;a href=&quot;http://lxr.php.net/xref/PHP_5_4/Zend/zend_builtin_functions.c#478&quot;&gt;这里&lt;/a&gt;查看。&lt;/p&gt;
&lt;p&gt;在这里也给出函数的源码：&lt;/p&gt;
&lt;p&gt;ZEND_FUNCTION(strlen)
{
char *s1;
int s1_len;&lt;/p&gt;
&lt;p&gt;if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &amp;quot;s&amp;quot;, &amp;amp;s1, &amp;amp;s1_len) == FAILURE) {
return;
}&lt;/p&gt;
&lt;p&gt;RETVAL_LONG(s1_len);
}&lt;/p&gt;
&lt;p&gt;该文章讲到，该函数很简单，并不需要进一步的解释。而&lt;a href=&quot;https://www.hoohack.me/2016/02/12/phps-source-code-for-php-developers-part3-variables-ch&quot;&gt;这篇文章&lt;/a&gt;也有对&lt;code&gt;zend_parse_parameters&lt;/code&gt;函数做介绍。笔者较笨，于是便想理解&lt;code&gt;zend_parse_parameters&lt;/code&gt;函数是怎么返回变量长度的。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;zend_parse_arg_impl&lt;/code&gt;函数，就是解析参数的地方，我们继续看&lt;code&gt;case &#39;s&#39;&lt;/code&gt;的分支。这个分支是对字符串变量的解析。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int *pl = va_arg(*va, int *);&lt;/code&gt;是字符串长度变量的定义。&lt;/p&gt;
&lt;p&gt;继续往下看，可以看到对&lt;code&gt;pl&lt;/code&gt;变量的赋值语句：&lt;code&gt;*pl = Z_STRLEN_PP(arg);&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;Z_STRLEN_PP&lt;/code&gt;宏的定义在&lt;code&gt;zend_operators.h&lt;/code&gt;文件中：&lt;/p&gt;
&lt;p&gt;#define Z_STRLEN_PP(zval_pp)    Z_STRLEN(**zval_pp)&lt;/p&gt;
&lt;p&gt;再继续看&lt;code&gt;Z_STRLEN&lt;/code&gt;宏的定义，&lt;code&gt;#define Z_STRLEN(zval)          (zval).value.str.len&lt;/code&gt;。由此我们可以知道，&lt;code&gt;strlen&lt;/code&gt;函数是通过直接返回zval结构体中的str的len属性来实现的。&lt;/p&gt;
&lt;p&gt;最后再安利一下，我在github有对PHP源码更详细的注解。感兴趣的可以围观一下，给个star。&lt;a href=&quot;https://github.com/read-php-src/read-php-src&quot;&gt;PHP5.4源码注解&lt;/a&gt;。可以通过&lt;a href=&quot;https://github.com/read-php-src/read-php-src/commits/master&quot;&gt;commit记录&lt;/a&gt;查看已添加的注解。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>【译】理解数组在PHP内部的实现（给PHP开发者的PHP源码-第四部分）</title>
    <link href="https://hoohack.me/blog/2016/2016-02-15-understanding-phps-internal-array-implementation-ch/"/>
    <updated>2016-02-15T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-02-15-understanding-phps-internal-array-implementation-ch/</id>
    <content type="html">&lt;p&gt;原文：&lt;a href=&quot;https://nikic.github.io/2012/03/28/Understanding-PHPs-internal-array-implementation.html&quot;&gt;https://nikic.github.io/2012/03/28/Understanding-PHPs-internal-array-implementation.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎来到&amp;quot;给PHP开发者的PHP源码&amp;quot;系列的第四部分，这一部分我们会谈论PHP数组在内部是如何表示和在代码库里使用的。&lt;/p&gt;
&lt;p&gt;为了防止你错过了之前的文章，以下是链接：&lt;/p&gt;
&lt;p&gt;第一部分：&lt;a href=&quot;https://www.hoohack.me/2016/02/04/phps-source-code-for-php-developers-ch&quot;&gt;给PHP开发者的PHP源码-源码结构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第二部分：&lt;a href=&quot;https://www.hoohack.me/2016/02/10/understanding-phps-internal-function-definitions-ch&quot;&gt;理解PHP内部函数的定义&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第三部分：&lt;a href=&quot;https://www.hoohack.me/2016/02/12/phps-source-code-for-php-developers-part3-variables-ch&quot;&gt;PHP的变量实现&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E6%89%80%E6%9C%89%E7%9A%84%E4%B8%9C%E8%A5%BF%E9%83%BD%E6%98%AF%E5%93%88%E5%B8%8C%E8%A1%A8&quot; tabindex=&quot;-1&quot;&gt;所有的东西都是哈希表&lt;/h2&gt;
&lt;p&gt;基本上，PHP里面的所有东西都是哈希表。不仅仅是在下面的PHP数组实现中，它们还用来存储对象属性，方法，函数，变量还有几乎所有东西。&lt;/p&gt;
&lt;p&gt;因为哈希表对PHP来说太基础了，因此非常值得深入研究它是如何工作的。&lt;/p&gt;
&lt;h2 id=&quot;%E9%82%A3%E4%B9%88%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%9F&quot; tabindex=&quot;-1&quot;&gt;那么，什么是哈希表？&lt;/h2&gt;
&lt;p&gt;记住，在C里面，数组是内存块，你可以通过下标访问这些内存块。因此，在C里面的数组只能使用整数且有序的键值（那就是说，你不能在键值0之后使用1332423442的键值）。C里面没有关联数组这种东西。&lt;/p&gt;
&lt;p&gt;哈希表是这样的东西：它们使用哈希函数转换字符串键值为正常的整型键值。哈希后的结果可以被作为正常的C数组的键值（又名为内存块）。现在的问题是，哈希函数会有冲突，那就是说，多个字符串键值可能会生成一样的哈希值。例如，在PHP，超过64个元素的数组里，字符串&amp;quot;foo&amp;quot;和&amp;quot;oof&amp;quot;拥有一样的哈希值。&lt;/p&gt;
&lt;p&gt;这个问题可以通过存储可能冲突的值到链表中，而不是直接将值存储到生成的下标里。&lt;/p&gt;
&lt;h2 id=&quot;hashtable%E5%92%8Cbucket&quot; tabindex=&quot;-1&quot;&gt;HashTable和Bucket&lt;/h2&gt;
&lt;p&gt;那么，现在哈希表的基本概念已经清晰了，让我们看看在PHP内部中实现的哈希表结构：&lt;/p&gt;
&lt;p&gt;typedef struct _hashtable {
uint nTableSize;
uint nTableMask;
uint nNumOfElements;
ulong nNextFreeElement;
Bucket *pInternalPointer;
Bucket *pListHead;
Bucket *pListTail;
Bucket **arBuckets;
dtor_func_t pDestructor;
zend_bool persistent;
unsigned char nApplyCount;
zend_bool bApplyProtection;
#if ZEND_DEBUG
int inconsistent;
#endif
} HashTable;&lt;/p&gt;
&lt;h2 id=&quot;%E5%BF%AB%E9%80%9F%E8%BF%87%E4%B8%80%E4%B8%8B%EF%BC%9A&quot; tabindex=&quot;-1&quot;&gt;快速过一下：&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;nNumOfElements&lt;/code&gt;标识现在存储在数组里面的值的数量。这也是函数&lt;code&gt;count($array)&lt;/code&gt;返回的值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nTableSize&lt;/code&gt;表示哈希表的容量。它通常是下一个大于等于&lt;code&gt;nNumOfElements&lt;/code&gt;的2的幂值。比如，如果数组存储了32元素，那么哈希表也是32大小的容量。但如果再多一个元素添加进来，也就是说，数组现在有33个元素，那么哈希表的容量就被调整为64。
这是为了保持哈希表在空间和时间上始终有效。很明显，如果哈希表太小，那么将会有很多的冲突，而且性能也会降低。另一方面，如果哈希表太大，那么浪费内存。2的幂值是一个很好的折中方案。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nTableMask&lt;/code&gt;是哈希表的容量减一。这个mask用来根据当前的表大小调整生成的哈希值。例如，&amp;quot;foo&amp;quot;真正的哈希值（使用DJBX33A哈希函数）是193491849。如果我们现在有64容量的哈希表，我们明显不能使用它作为数组的下标。取而代之的是通过应用哈希表的mask，然后只取哈希表的低位。&lt;/p&gt;
&lt;p&gt;hash           |        193491849 |     0b1011100010000111001110001001
&amp;amp; mask         | &amp;amp;             63 | &amp;amp;   0b0000000000000000000000111111
---------------------------------------------------------
= index        | = 9              | =   0b0000000000000000000000001001&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nNextFreeElement&lt;/code&gt;是下一个可以使用的数字键值，当你使用$array[] = xyz是被使用到。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pInternalPointer&lt;/code&gt; 存储数组当前的位置。这个值在foreach遍历时可使用reset()，current()，key()，next()，prev()和end()函数访问。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pListHead&lt;/code&gt;和&lt;code&gt;pListTail&lt;/code&gt;标识了数组的第一个和最后一个元素的位置。记住：PHP的数组是有序集合。比如，[&#39;foo&#39; =&amp;gt; &#39;bar&#39;, &#39;bar&#39; =&amp;gt; &#39;foo&#39;]和[&#39;bar&#39; =&amp;gt; &#39;foo&#39;, &#39;foo&#39; =&amp;gt; &#39;bar&#39;]这两个数组包含了相同的元素，但却有不同的顺序。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;arBuckets&lt;/code&gt;是我们经常谈论的“哈希表（internal C array）”。它用Bucket **来定义，因此它可以被看作数组的bucket指针（我们会马上谈论Bucket是什么）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pDestructor&lt;/code&gt;是值的析构器。如果一个值从HT中移除，那么这个函数会被调用。常见的析构函数是zval_ptr_dtor。zval_ptr_dtor会减少zval的引用数量，而且，如果它遇到o，它会销毁和释放它。&lt;/p&gt;
&lt;p&gt;最后的四个变量对我们来说不是那么重要。所以简单地说persistent标识哈希表可以在多个请求里存活，nApplyCount和bApplyProtection防止多次递归，inconsistent用来捕获在调试模式里哈希表的非法使用。&lt;/p&gt;
&lt;p&gt;让我们继续第二个重要的结构：Bucket：&lt;/p&gt;
&lt;p&gt;typedef struct bucket {
ulong h;
uint nKeyLength;
void *pData;
void *pDataPtr;
struct bucket *pListNext;
struct bucket *pListLast;
struct bucket *pNext;
struct bucket *pLast;
const char *arKey;
} Bucket;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;h&lt;/code&gt;是一个哈希值（没有应用mask值映射之前的值）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;arKey&lt;/code&gt;用来保存字符串键值。&lt;code&gt;nKeyLength&lt;/code&gt;是对应的长度。如果是数字键值，那么这两个变量都不会被使用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pData&lt;/code&gt;及&lt;code&gt;pDataPtr&lt;/code&gt;被用来存储真正的值。对PHP数组来说，它的值是一个zval结构体（但它也在其他地方使用到）。不要纠结为什么有两个属性。它们两者的区别是谁负责释放值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pListNext&lt;/code&gt;和&lt;code&gt;pListLast&lt;/code&gt;标识数组元素的下一个元素和上一个元素。如果PHP想顺序遍历数组它会从pListHead这个bucket开始（在HashTable结构里面），然后使用pListNext bucket作为遍历指针。在逆序也是一样，从pListTail指针开始，然后使用pListLast指针作为变量指针。（你可以在用户代码里调用end()然后调用prev()函数达到这个效果。）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pNext&lt;/code&gt;和&lt;code&gt;pLast&lt;/code&gt;生成我上面提到的“可能冲突的值链表”。arBucket数组存储第一个可能值的bucket。如果该bucket没有正确的键值，PHP会查找pNext指向的bucket。它会一直指向后面的bucket直到找到正确的bucket。pLast在逆序中也是一样的原理。&lt;/p&gt;
&lt;p&gt;你可以看到，PHP的哈希表实现相当复杂。这是它使用超灵活的数组类型要付出的代价。&lt;/p&gt;
&lt;h2 id=&quot;%E5%93%88%E5%B8%8C%E8%A1%A8%E6%98%AF%E6%80%8E%E4%B9%88%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84%EF%BC%9F&quot; tabindex=&quot;-1&quot;&gt;哈希表是怎么被使用的？&lt;/h2&gt;
&lt;p&gt;Zend Engine定义了大量的API函数供哈希表使用。低级的哈希表函数预览可以在&lt;code&gt;zend_hash.h&lt;/code&gt;文件里面找到。另外Zend Engine在&lt;code&gt;zend_API.h&lt;/code&gt;文件定义了稍微高级一些的API。&lt;/p&gt;
&lt;p&gt;我们没有足够的时间去讲所有的函数，但是我们至少可以查看一些实例函数，看看它是如何工作的。我们将使用&lt;code&gt;array_fill_keys&lt;/code&gt;作为实例函数。&lt;/p&gt;
&lt;p&gt;使用第二部分提到的技巧你可以很容易地找到函数在&lt;code&gt;ext/standard/array.c&lt;/code&gt;文件里面定义了。现在，让我们来快速查看这个函数。&lt;/p&gt;
&lt;p&gt;跟大部分函数一样，函数的顶部有一堆变量的定义，然后调用&lt;code&gt;zend_parse_parameters&lt;/code&gt;函数：&lt;/p&gt;
&lt;p&gt;zval *keys, *val, **entry;
HashPosition pos;&lt;/p&gt;
&lt;p&gt;if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &amp;quot;az&amp;quot;, &amp;amp;keys, &amp;amp;val) == FAILURE) {
return;
}&lt;/p&gt;
&lt;p&gt;很明显，&lt;code&gt;az&lt;/code&gt;参数说明第一个参数类型是数组（即变量&lt;code&gt;keys&lt;/code&gt;），第二个参数是任意的zval（即变量&lt;code&gt;val&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;解析完参数后，返回数组就被初始化了：&lt;/p&gt;
&lt;p&gt;/* Initialize return array */
array_init_size(return_value, zend_hash_num_elements(Z_ARRVAL_P(keys)));&lt;/p&gt;
&lt;p&gt;这一行包含了array API里面存在的三步重要的部分：&lt;/p&gt;
&lt;p&gt;1、Z_ARRVAL_P宏从zval里面提取值到哈希表。&lt;/p&gt;
&lt;p&gt;2、zend_hash_num_elements提取哈希表元素的个数（nNumOfElements属性）。&lt;/p&gt;
&lt;p&gt;3、array_init_size使用size变量初始化数组。&lt;/p&gt;
&lt;p&gt;因此，这一行使用与键值数组一样大小来初始化数组到&lt;code&gt;return_value&lt;/code&gt;变量里。&lt;/p&gt;
&lt;p&gt;这里的size只是一种优化方案。函数也可以只调用&lt;code&gt;array_init(return_value)&lt;/code&gt;，这样随着越来越多的元素添加到数组里，PHP就会多次重置数组的大小。通过指定特定的大小，PHP会在一开始就分配正确的内存空间。&lt;/p&gt;
&lt;p&gt;数组被初始化并返回后，函数用跟下面大致相同的代码结构，使用while循环变量keys数组：&lt;/p&gt;
&lt;p&gt;zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(keys), &amp;amp;pos);
while (zend_hash_get_current_data_ex(Z_ARRVAL_P(keys), (void **)&amp;amp;entry, &amp;amp;pos) == SUCCESS) {
// some code&lt;/p&gt;
&lt;p&gt;zend_hash_move_forward_ex(Z_ARRVAL_P(keys), &amp;amp;pos);
}&lt;/p&gt;
&lt;p&gt;这可以很容易地翻译成PHP代码：&lt;/p&gt;
&lt;p&gt;reset($keys);
while (null !== $entry = current($keys)) {
// some code&lt;/p&gt;
&lt;p&gt;next($keys);
}&lt;/p&gt;
&lt;p&gt;跟下面的一样：&lt;/p&gt;
&lt;p&gt;foreach ($keys as $entry) {
// some code
}&lt;/p&gt;
&lt;p&gt;唯一不同的是，C的遍历并没有使用内部的数组指针，而使用它自己的pos变量来存储当前的位置。&lt;/p&gt;
&lt;p&gt;在循环里面的代码分为两个分支：一个是给数字键值，另一个是其他键值。数字键值的分支只有下面的两行代码：&lt;/p&gt;
&lt;p&gt;zval_add_ref(&amp;amp;val);
zend_hash_index_update(Z_ARRVAL_P(return_value), Z_LVAL_PP(entry), &amp;amp;val, sizeof(zval *), NULL);&lt;/p&gt;
&lt;p&gt;这看起来太直接了：首先值的引用增加了（添加值到哈希表意味着增加另一个指向它的引用），然后值被插入到哈希表中。&lt;code&gt;zend_hash_index_update&lt;/code&gt;宏的参数分别是，需要更新的哈希表&lt;code&gt;Z_ARRVAL_P(return_value)&lt;/code&gt;，整型下标&lt;code&gt;Z_LVAL_PP(entry)&lt;/code&gt;，值&lt;code&gt;&amp;amp;val&lt;/code&gt;，值的大小&lt;code&gt;sizeof(zval *)&lt;/code&gt;以及目标指针(这个我们不关注，因此是&lt;code&gt;NULL&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;非数字下标的分支就稍微复杂一点：&lt;/p&gt;
&lt;p&gt;zval key, *key_ptr = *entry;&lt;/p&gt;
&lt;p&gt;if (Z_TYPE_PP(entry) != IS_STRING) {
key = **entry;
zval_copy_ctor(&amp;amp;key);
convert_to_string(&amp;amp;key);
key_ptr = &amp;amp;key;
}&lt;/p&gt;
&lt;p&gt;zval_add_ref(&amp;amp;val);
zend_symtable_update(Z_ARRVAL_P(return_value), Z_STRVAL_P(key_ptr), Z_STRLEN_P(key_ptr) + 1, &amp;amp;val, sizeof(zval *),             NULL);&lt;/p&gt;
&lt;p&gt;if (key_ptr != *entry) {
zval_dtor(&amp;amp;key);
}&lt;/p&gt;
&lt;p&gt;首先，使用&lt;code&gt;convert_to_string&lt;/code&gt;将键值转换为字符串（除非它已经是字符串了）。在这之前，&lt;code&gt;entry&lt;/code&gt;被复制到新的&lt;code&gt;key&lt;/code&gt;变量。&lt;code&gt;key = **entry&lt;/code&gt;这一行实现。另外，&lt;code&gt;zval_copy_ctor&lt;/code&gt;函数会被调用，不然复杂的结构（比如字符串或数组）不会被正确地复制。&lt;/p&gt;
&lt;p&gt;上面的复制操作非常有必要，因为要保证类型转换不会改变原来的数组。如果没有copy操作，强制转换不仅仅修改局部的变量，而且也修改了在键值数组中的值（显然，这对用户来说非常意外）。&lt;/p&gt;
&lt;p&gt;显然，循环结束之后，复制操作需要再次被移除，&lt;code&gt;zval_dtor(&amp;amp;key)&lt;/code&gt;做的就是这个工作。&lt;code&gt;zval_ptr_dtor&lt;/code&gt;和&lt;code&gt;zval_dtor&lt;/code&gt;的不同是&lt;code&gt;zval_ptr_dtor&lt;/code&gt;只会在&lt;code&gt;refcount&lt;/code&gt;变量为0时销毁zval变量，而&lt;code&gt;zval_dtor&lt;/code&gt;会马上销毁它，而不是依赖&lt;code&gt;refcount&lt;/code&gt;的值。这就为什么你看到&lt;code&gt;zval_pte_dtor&lt;/code&gt;使用&amp;quot;normal&amp;quot;变量而&lt;code&gt;zval_dtor&lt;/code&gt;使用临时变量，这些临时变量不会在其他地方使用。而且，&lt;code&gt;zval_ptr_dtor&lt;/code&gt;会在销毁之后释放zval的内容而&lt;code&gt;zval_dtor&lt;/code&gt;不会。因为我们没有&lt;code&gt;malloc()&lt;/code&gt;任何东西，因此我们也不需要&lt;code&gt;free()&lt;/code&gt;，因此在这方面，&lt;code&gt;zval_dtor&lt;/code&gt;做了正确的选择。&lt;/p&gt;
&lt;p&gt;现在来看看剩下的两行（重要的两行^^）：&lt;/p&gt;
&lt;p&gt;zval_add_ref(&amp;amp;val);
zend_symtable_update(Z_ARRVAL_P(return_value), Z_STRVAL_P(key_ptr), Z_STRLEN_P(key_ptr) + 1, &amp;amp;val, sizeof(zval *), NULL);&lt;/p&gt;
&lt;p&gt;这跟数字键值分支完成后的操作非常相似。不同的是，现在调用的是&lt;code&gt;zend_symtable_update&lt;/code&gt;而不是&lt;code&gt;zend_hash_index_update&lt;/code&gt;，而传递的是键值字符串和它的长度。&lt;/p&gt;
&lt;h2 id=&quot;%E7%AC%A6%E5%8F%B7%E8%A1%A8&quot; tabindex=&quot;-1&quot;&gt;符号表&lt;/h2&gt;
&lt;p&gt;&amp;quot;正常的&amp;quot;插入字符串键值到哈希表的函数是&lt;code&gt;zend_hash_update&lt;/code&gt;，但这里却使用了&lt;code&gt;zend_symtable_update&lt;/code&gt;。它们有什么不同呢？&lt;/p&gt;
&lt;p&gt;符号表简单地说就是哈希表的特殊的类型，这种类型使用在数组里。它跟原始的哈希表不同的是他如何处理数字型的键值：在符号表里，&amp;quot;123&amp;quot;和123被看作是相同的。因此，如果你在$array[&amp;quot;123&amp;quot;]存储一个值，你可以在后面使用$array[123]获取它。&lt;/p&gt;
&lt;p&gt;底层可以使用两种方式实现：要么使用&amp;quot;123&amp;quot;来保存123和&amp;quot;123&amp;quot;，要么使用123来保存这两种键值。显然PHP选择了后者（因为整型比字符串类型更快和占用更少的空间）。&lt;/p&gt;
&lt;p&gt;如果你不小心使用&amp;quot;123&amp;quot;而不是强制转换为123后插入数据，你会发现符号表一些有趣的事情。一个利用数组到对象的强制转换如下：&lt;/p&gt;
&lt;p&gt;$obj = new stdClass;
$obj-&amp;gt;{123} = &amp;quot;foo&amp;quot;;
$arr = (array) $obj;
var_dump($arr[123]); // Undefined offset: 123
var_dump($arr[&amp;quot;123&amp;quot;]); // Undefined offset: 123&lt;/p&gt;
&lt;p&gt;对象属性总是使用字符串键值来保存，尽管它们是数字。因此&lt;code&gt;$obj-&amp;gt;{123} = &#39;foo&#39;&lt;/code&gt;这行代码实际上保存&#39;foo&#39;变量到&amp;quot;123&amp;quot;下标里。当使用数组强制转换的时候，这个值不会给改变。但当&lt;code&gt;$arr[123]&lt;/code&gt;和&lt;code&gt;$arr[&amp;quot;123&amp;quot;]&lt;/code&gt;都想访问123下标的值（不是已有的&amp;quot;123&amp;quot;下标）时，都抛出了错误。因此，恭喜，你创建了一个隐藏的数组元素。&lt;/p&gt;
&lt;p&gt;下一部分
下一部分会再次在ircmaxell的博客发表。下一篇会介绍对象和类在内部是如何工作的。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>【译】PHP的变量实现（给PHP开发者的PHP源码-第三部分）</title>
    <link href="https://hoohack.me/blog/2016/2016-02-12-phps-source-code-for-php-developers-part3-variables-ch/"/>
    <updated>2016-02-12T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-02-12-phps-source-code-for-php-developers-part3-variables-ch/</id>
    <content type="html">&lt;p&gt;原文：&lt;a href=&quot;http://blog.ircmaxell.com/2012/03/phps-source-code-for-php-developers_21.html&quot;&gt;http://blog.ircmaxell.com/2012/03/phps-source-code-for-php-developers_21.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在&amp;quot;给PHP开发者的PHP源码&amp;quot;系列的第三篇文章，我们打算扩展上一篇文章来帮助理解PHP内部是怎么工作的。在第一篇文章，我们介绍了如何查看PHP的源码，它的代码结构是怎样的以及一些介绍给PHP开发者的C指针基础。第二篇文章介绍了函数。这一次，我们打算深入PHP最有用的结构之一：变量。&lt;/p&gt;
&lt;h2 id=&quot;%E8%BF%9B%E5%85%A5zval&quot; tabindex=&quot;-1&quot;&gt;进入ZVAL&lt;/h2&gt;
&lt;p&gt;在PHP的核心代码中，变量被称为&lt;code&gt;ZVAL&lt;/code&gt;。这个结构之所以那么重要是有原因的，不仅仅是因为PHP使用弱类型而C使用强类型。那么ZVAL是怎么解决这个问题的呢？要回答这个问题，我们需要认真的查看ZVAL类型的定义。要查看这个定义，让我们尝试在lxr页面的定义搜索框里搜索zval。乍一眼看去，我们似乎找不到任何有用的东西。但是有一行&lt;code&gt;typedef&lt;/code&gt;在zend.h文件（typedef在C里面是一种定义新的数据类型的方式）。这个也许就是我们要找的东西，再继续查看。原来，这看起来是不相干的。这里并没有任何有用的东西。但为了确认一些，我们来点击&lt;code&gt;_zval_struct&lt;/code&gt;这一行。&lt;/p&gt;
&lt;p&gt;struct _zval_struct {
/* Variable information &lt;em&gt;/
zvalue_value value; /&lt;/em&gt; value &lt;em&gt;/
zend_uint refcount__gc;
zend_uchar type; /&lt;/em&gt; active type */
zend_uchar is_ref__gc;
};&lt;/p&gt;
&lt;p&gt;然后我们就得到PHP的基础，zval。看起来很简单，对吗？是的，没错，但这里还有一些很有意义的神奇的东西。注意，这是一个结构或结构体。基本上，这可以看作PHP里面的类，这些类只有公共的属性。这里，我们有四个属性：&lt;code&gt;value&lt;/code&gt;,&lt;code&gt;refcount__gc&lt;/code&gt;,&lt;code&gt;type&lt;/code&gt;以及&lt;code&gt;is_ref__gc&lt;/code&gt;。让我们来一一查看这些属性（省略它们的顺序）。&lt;/p&gt;
&lt;h3 id=&quot;value&quot; tabindex=&quot;-1&quot;&gt;Value&lt;/h3&gt;
&lt;p&gt;我们第一个谈论的元素是value变量，它的类型是&lt;code&gt;zvalue_value&lt;/code&gt;。我不认识你，但我也从来没有听说过&lt;code&gt;zvalue_value&lt;/code&gt;。那么让我们尝试弄懂它是什么。跟网站的其他部分一样，你可以点击某个类型查看它的定义。一旦你点击了，你会看到它的定义跟下面的是一样的：&lt;/p&gt;
&lt;p&gt;typedef union _zvalue_value {
long lval; /* long value &lt;em&gt;/
double dval; /&lt;/em&gt; double value */
struct {
char *val;
int len;
} str;
HashTable &lt;em&gt;ht; /&lt;/em&gt; hash table value */
zend_object_value obj;
} zvalue_value;&lt;/p&gt;
&lt;p&gt;现在，这里有一些黑科技。看到那个union的定义吗？那意味着这不是真正的结构体，而是一个单独的类型。但是有多个类型的变量在里面。如果这里面有多种类型的话，那它怎么能作为单一的类型呢？我很高兴你问了这个问题。要理解这个问题，我们需要先回想我们在第一篇文章谈论的C语言中的类型。&lt;/p&gt;
&lt;p&gt;在C里面，变量只是一行内存地址的标签。也可以说类型只是标识哪一块内存将被使用的方式。在C里面没有使用任何东西将4个字节的字符串和整型值分隔开。它们都只是一整块的内存。编译器会尝试通过&amp;quot;标识&amp;quot;内存段作为变量来解析它，然后将这些变量转换为特定的类型，但这并不是总是成功（顺便说一句，当一个变量“重写”它得到的内存段，那将会产生段错误）。&lt;/p&gt;
&lt;p&gt;那么，据我们所知，union是单独的类型，它根据怎么被访问而使用不同的方式解释。这可以让我们定义一个值来支持多种类型。有一点要注意的是，所有类型的数据都必须使用同一块内存来存储。这个例子，在64位的编译器，long和double都会占用64个位来保存。字符串结构体会占用96位（64位存储字符指针，32位保存整型长度）。&lt;code&gt;hash_table&lt;/code&gt;会占用64位，还有&lt;code&gt;zend_object_value&lt;/code&gt;会占用96位（32位用来存储元素，剩下的64位来存储指针）。而整一个union会占用最大元素的内存大小，因此在这里就是96位。&lt;/p&gt;
&lt;p&gt;现在，如果再看清楚这个联合体（union），我们可以看到只有5种PHP数据类型在这里（long == int，double == float，str == string，hashtable == array，zend_object_value == object）。那么剩下的数据类型去了哪里呢？原来，这个结构体已经足够来存储剩余的数据类型。BOOL使用long(int)来存储，&lt;code&gt;NULL&lt;/code&gt;不占用数据段，&lt;code&gt;RESOURCE&lt;/code&gt;也使用long来存储。&lt;/p&gt;
&lt;h3 id=&quot;type&quot; tabindex=&quot;-1&quot;&gt;TYPE&lt;/h3&gt;
&lt;p&gt;因为这个value联合体并没有控制它是怎么被访问的，我们需要其他方式来记录变量的类型。这里，我们可以通过数据类型来得出如何访问value的信息。它使用type这个字节来处理这个问题（&lt;code&gt;zend_uchar&lt;/code&gt;是一个无符号的字符，或者内存中的一个字节）。它从zend类型常量保留这些信息。这真的是一种魔法，是需要使用&lt;code&gt;zval.type = IS_LONG&lt;/code&gt;来定义整型数据。因此这个字段和value字段就足够让我们知道PHP变量的类型和值。&lt;/p&gt;
&lt;h3 id=&quot;is_ref&quot; tabindex=&quot;-1&quot;&gt;IS_REF&lt;/h3&gt;
&lt;p&gt;这个字段标识变量是否为引用。那就是说，如果你执行了在变量里执行了&lt;code&gt;$foo = &amp;amp;$bar&lt;/code&gt;。如果它是0，那么变量就不是一个引用，如果它是1，那么变量就是一个引用。它并没有做太多的事情。那么，在我们结束&lt;code&gt;_zval_struct&lt;/code&gt;之前，再看一看它的第四个成员。&lt;/p&gt;
&lt;h3 id=&quot;refcount&quot; tabindex=&quot;-1&quot;&gt;REFCOUNT&lt;/h3&gt;
&lt;p&gt;这个变量是指向PHP变量容器的指针的计数器。也就是说，如果refcount是1，那就表示有一个PHP变量使用这个容器。如果refcount是2，那就表示有两个PHP变量指向同一个变量容器。单独的refcount变量并没有太多有用的信息，但如果它与&lt;code&gt;is_ref&lt;/code&gt;一起使用，就构成了垃圾回收器和写时复制的基础。它允许我们使用同一个zval容器来保存一个或多个PHP变量。refcount的语义解释超出这篇文章的范围，如果你想继续深入，我推荐你查看这篇文档。&lt;/p&gt;
&lt;p&gt;这就是ZVAL的所有内容。&lt;/p&gt;
&lt;h2 id=&quot;%E5%AE%83%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F&quot; tabindex=&quot;-1&quot;&gt;它是怎么工作的？&lt;/h2&gt;
&lt;p&gt;在PHP内部，zval使用跟其他C变量一样，作为内存段或者一个指向内存段的指针（或者指向指针的指针，等等），传递到函数。一旦我们有了变量，我们就想访问它里面的数据。那我们要怎么做到呢？我们使用定义在&lt;code&gt;zend_operators.h&lt;/code&gt;文件里面的宏来跟zval一起使用，使得访问数据更简单。有一点很重要的是，每一个宏都有多个拷贝。不同的是它们的前缀。例如，要得出zval的类型，有&lt;code&gt;Z_TYPE(zval)&lt;/code&gt;宏，这个宏返回一个整型数据来表示zval参数。但这里还有一个&lt;code&gt;Z_TYPE(zval_p)&lt;/code&gt;宏，它跟&lt;code&gt;Z_TYPE(zval)&lt;/code&gt;做的事情是一样的，但它返回的是指向zval的指针。事实上，除了参数的属性不一样之外，这两个函数是一样的，实际上，我们可以使用&lt;code&gt;Z_TYPE(*zval_p)&lt;/code&gt;，但_P和_PP让事情更简单。&lt;/p&gt;
&lt;p&gt;我们可以使用VAL这一类宏来获取zval的值。可以调用&lt;code&gt;Z_LVAL(zval)&lt;/code&gt;来得到整型值（比如整型数据和资源数据）。调用&lt;code&gt;Z_DVAL(zval)&lt;/code&gt;来得到浮点值。还有很多其他的，到这里到此为止。要注意的关键是，为了在C里面获取zval的值，你需要使用宏（或应该）。因此，当我们看见有函数使用它们时，我们就知道它是从zval里面提取它的值。&lt;/p&gt;
&lt;h2 id=&quot;%E9%82%A3%E4%B9%88%EF%BC%8C%E7%B1%BB%E5%9E%8B%E5%91%A2%EF%BC%9F&quot; tabindex=&quot;-1&quot;&gt;那么，类型呢？&lt;/h2&gt;
&lt;p&gt;到现在为止，我们知识谈论了类型和zval的值。我们都知道，PHP帮我们做了类型判断。因此，如果我们喜欢，我们可以将一个字符串当作一个整型值。我们把这一步叫做&lt;code&gt;convert_to_type&lt;/code&gt;。要转换一个zval为string值，就调用&lt;code&gt;convert_to_string&lt;/code&gt;函数。它会改变我们传递给函数的ZVAL的类型。因此，如果你看到有函数在调用这些函数，你就知道它是在转换参数的数据类型。&lt;/p&gt;
&lt;h2 id=&quot;zend_parse_paramenters&quot; tabindex=&quot;-1&quot;&gt;Zend_Parse_Paramenters&lt;/h2&gt;
&lt;p&gt;上一篇文章中，介绍了&lt;code&gt;zend_parse_paramenters&lt;/code&gt;这个函数。既然我们知道PHP变量在C里面是怎么表示的，那我们就来深入看看。&lt;/p&gt;
&lt;p&gt;ZEND_API int zend_parse_parameters(int num_args TSRMLS_DC, const char *type_spec, ...)
{
va_list va;
int retval;&lt;/p&gt;
&lt;p&gt;RETURN_IF_ZERO_ARGS(num_args, type_spec, 0);&lt;/p&gt;
&lt;p&gt;va_start(va, type_spec);
retval = zend_parse_va_args(num_args, type_spec, &amp;amp;va, 0 TSRMLS_CC);
va_end(va);&lt;/p&gt;
&lt;p&gt;return retval;
}&lt;/p&gt;
&lt;p&gt;现在，从表面上看，这看起来很迷惑。重点要理解的是，va_list类型只是一个使用&#39;...&#39;的可变参数列表。因此，它跟PHP中的&lt;code&gt;func_get_args()&lt;/code&gt;函数的构造差不多。有了这个东西，我们可以看到&lt;code&gt;zend_parse_parameters&lt;/code&gt;函数马上调用&lt;code&gt;zend_parse_va_args&lt;/code&gt;函数。我们继续往下看看这个函数...&lt;/p&gt;
&lt;p&gt;这个函数看起来很有趣。第一眼看去，它好像做了很多事情。但仔细看看。首先，我们可以看到一个for循环。这个for循环主要遍历从&lt;code&gt;zend_parse_parameters&lt;/code&gt;传递过来的&lt;code&gt;type_spec&lt;/code&gt;字符串。在循环里面我们可以看到它只是计算期望接收到的参数数量。它是如何做到这些的研究就留给读者。&lt;/p&gt;
&lt;p&gt;继续往下看，我么可以看到有一些合理的检查（检查参数是否都正确地传递），还有错误检查，检查是否传递了足够数量的参数。接下来进入一个我们感兴趣的循环。这个循环真正解析那些参数。在循环里面，我们可以看到有三个if语句。第一个处理可选参数的标识符。第二个处理&lt;code&gt;var-args&lt;/code&gt;(参数的数量)。第三个if语句正是我们感兴趣的。可以看到，这里调用了&lt;code&gt;zend_parse_arg()&lt;/code&gt;函数。让我们再深入看看这个函数...&lt;/p&gt;
&lt;p&gt;继续往下看，我们可以看到这里有一些非常有趣的事情。这个函数再调用另一个函数（zend_parse_arg_impl），然后得到一些错误信息。这在PHP里面是一种很常见的模式，将函数的错误处理工作提取到父函数。这样代码实现和错误处理就分开了，而且可以最大化地重用。你可以继续深入研究那个函数，非常容易理解。但我们现在仔细看看&lt;code&gt;zend_parse_arg_impl()&lt;/code&gt;...&lt;/p&gt;
&lt;p&gt;现在，我们真正到了PHP内部函数解析参数的步骤。让我们看看第一个switch语句的分支，这个分支用来解析整型参数。接下来的应该很容易理解。那么，我们从分支的第一行开始吧：&lt;/p&gt;
&lt;p&gt;long *p = va_arg(*va, long *);&lt;/p&gt;
&lt;p&gt;如果你记得我们之前说的，va_args是C语言处理变量参数的方式。所以这里是定义一个整型指针（long在C里面是整型）。总之，它从va_arg函数里面得到指针。这说明，它得到传递给zend_parse_parameters函数的参数的指针。所以这就是我们会用分支结束后的值赋值的指针结果。接下来，我们可以看到进入一个根据传递进来的变量（zval）类型的分支。我们先看看&lt;code&gt;IS_STRING&lt;/code&gt;分支（这一步会在传递整型值到字符串变量时执行）。&lt;/p&gt;
&lt;p&gt;case IS_STRING:
{
double d;
int type;&lt;/p&gt;
&lt;p&gt;if ((type = is_numeric_string(Z_STRVAL_PP(arg), Z_STRLEN_PP(arg), p, &amp;amp;d, -1)) == 0) {
return &amp;quot;long&amp;quot;;
} else if (type == IS_DOUBLE) {
if (c == &#39;L&#39;) {
if (d &amp;gt; LONG_MAX) {
*p = LONG_MAX;
break;
} else if (d &amp;lt; LONG_MIN) {
*p = LONG_MIN;
break;
}
}&lt;/p&gt;
&lt;p&gt;*p = zend_dval_to_lval(d);
}
}
break;&lt;/p&gt;
&lt;p&gt;现在，这个做的事情并没有看起来的那么多。所有的事情都归结与&lt;code&gt;is_numeric_string&lt;/code&gt;函数。总的来说，该函数检查字符串是否只包含整数字符，如果不是的话就返回0。如果是的话，它将该字符串解析到变量里（整型或浮点型，p或d），然后返回数据类型。所以我们可以看到，如果字符串不是纯数字，他返回“long”字符串。这个字符串用来包装错误处理函数。否则，如果字符串表示double（浮点型），它先检查这个浮点数作为整型数来存储的话是否太大，然后它使用&lt;code&gt;zend_dval_to_lval&lt;/code&gt;函数来帮助解析浮点数到整型数。这就是我们所知道的。我们已经解析了我们的字符串参数。现在继续看看其他分支：&lt;/p&gt;
&lt;p&gt;case IS_DOUBLE:
if (c == &#39;L&#39;) {
if (Z_DVAL_PP(arg) &amp;gt; LONG_MAX) {
*p = LONG_MAX;
break;
} else if (Z_DVAL_PP(arg) &amp;lt; LONG_MIN) {
*p = LONG_MIN;
break;
}
}
case IS_NULL:
case IS_LONG:
case IS_BOOL:
convert_to_long_ex(arg);
*p = Z_LVAL_PP(arg);
break;&lt;/p&gt;
&lt;p&gt;这里，我们可以看到解析浮点数的操作，这一步跟解析字符串里的浮点数相似（巧合？）。有一个很重要的事情要注意的是，如果参数的标识不是大写&#39;L&#39;，它会跟其他类型变量一样的处理方式（这个case语句没有break）。现在，我们还有一个有趣的函数，convert_to_long_ex()。这跟我们之前说到的convert_to_type()函数集合是一类的，该函数转换参数为特定的类型。唯一的不同是，如果参数不是引用的话（因为这个函数在改变数据类型），这个函数就将变量的值及其引用分离（拷贝）了。( The only difference is that it separates (copies) the passed in variable if it&#39;s not a reference (since it&#39;s changing the type). )这就是写时复制的作用。因此，当我们传递一个浮点数到到一个非引用的整型变量，该函数会把它当作整型来处理，但我们仍然可以得到浮点型数据。&lt;/p&gt;
&lt;p&gt;case IS_ARRAY:
case IS_OBJECT:
case IS_RESOURCE:
default:
return &amp;quot;long&amp;quot;;&lt;/p&gt;
&lt;p&gt;最后，我们还有另外三个case分支。我们可以看到，如果你传递一个数组、对象、资源或者其他不知道的类型到整型变量中，你会得到错误。&lt;/p&gt;
&lt;p&gt;剩下的部分我们留给读者。阅读&lt;code&gt;zend_parse_arg_impl&lt;/code&gt;函数对更好地理解额PHP类型判断系统真的很有用。一部分一部分地读，然后尽量追踪在C里面的各种参数的状态和类型。&lt;/p&gt;
&lt;p&gt;下一部分
下一部分会在Nikic的博客（我们会在这个系列的文章来回跳转）。在下一篇，他会谈到数组的所有内容。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>【译】理解PHP内部函数的定义（给PHP开发者的PHP源码-第二部分）</title>
    <link href="https://hoohack.me/blog/2016/2016-02-10-understanding-phps-internal-function-definitions-ch/"/>
    <updated>2016-02-10T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-02-10-understanding-phps-internal-function-definitions-ch/</id>
    <content type="html">&lt;p&gt;原文：&lt;a href=&quot;https://nikic.github.io/2012/03/16/Understanding-PHPs-internal-function-definitions.html&quot;&gt;https://nikic.github.io/2012/03/16/Understanding-PHPs-internal-function-definitions.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎来到&amp;quot;给PHP开发者的PHP源码&amp;quot;系列的第二部分。&lt;/p&gt;
&lt;p&gt;在上一篇中，ircmaxell说明了你可以在哪里找到PHP的源码，它的基本目录结构以及简单地介绍了一些C语言（因为PHP是用C语言来写的）。如果你错过了那篇文章，在你开始读这篇文章之前也许你应该读一下它。&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们谈论的是定位PHP内部函数的定义，以及理解它们的原理。&lt;/p&gt;
&lt;h2 id=&quot;%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89&quot; tabindex=&quot;-1&quot;&gt;如何找到函数的定义&lt;/h2&gt;
&lt;p&gt;作为开始，让我们尝试找出strpos函数的定义。&lt;/p&gt;
&lt;p&gt;尝试的第一步，就是去PHP 5.4根目录然后在页面顶部的搜索框输入strpos。搜索的结果是一个很大的列表，展示了&lt;code&gt;strpos&lt;/code&gt;在PHP源码中出现的位置。&lt;/p&gt;
&lt;p&gt;因为这个结果对我们并没有太大的帮助，我们使用一个小技巧：我们搜索&amp;quot;PHP_FUNCTION strpos&amp;quot;（不要漏了双引号，它们很重要），而不是&lt;code&gt;strpos&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;现在我们得到两个入口链接：&lt;/p&gt;
&lt;p&gt;/PHP_5_4/ext/standard/
php_string.h 48   PHP_FUNCTION(strpos);
string.c     1789 PHP_FUNCTION(strpos)&lt;/p&gt;
&lt;p&gt;第一个要注意的事情是，两个位置都是在&lt;code&gt;ext/standard&lt;/code&gt;文件夹。这就是我们希望找到的，因为strpos函数（跟大部分string，array和文件函数一样）是standard扩展的一部分。&lt;/p&gt;
&lt;p&gt;现在，在新标签页打开两个链接，然后看看它们背后藏了什么代码。&lt;/p&gt;
&lt;p&gt;你会看到第一个链接带你到了php_string.h文件，它包含了下面的代码：&lt;/p&gt;
&lt;p&gt;// ...
PHP_FUNCTION(strpos);
PHP_FUNCTION(stripos);
PHP_FUNCTION(strrpos);
PHP_FUNCTION(strripos);
PHP_FUNCTION(strrchr);
PHP_FUNCTION(substr);
// ...&lt;/p&gt;
&lt;p&gt;这就是一个典型的头文件（以.h后缀结尾的文件）的样子：单纯的函数列表，函数在其他地方定义。事实上，我们对这些并不感兴趣，因为我们已经知道我们要找的是什么。&lt;/p&gt;
&lt;p&gt;第二个链接更有趣：它带我们到&lt;code&gt;string.c&lt;/code&gt;文件，这个文件包含了函数真正的源代码。&lt;/p&gt;
&lt;p&gt;在我带你一步一步地查阅这个函数之前，我推荐你自己尝试理解这个函数。这是一个很简单的函数，尽管你不知道真正的细节，但大多数代码看起来都很清晰。&lt;/p&gt;
&lt;h2 id=&quot;php%E5%87%BD%E6%95%B0%E7%9A%84%E9%AA%A8%E6%9E%B6&quot; tabindex=&quot;-1&quot;&gt;PHP函数的骨架&lt;/h2&gt;
&lt;p&gt;所有的PHP函数都使用同一个基本结构。在函数顶部定义了各个变量，然后调用&lt;code&gt;zend_parse_parameters&lt;/code&gt;函数，然后到了主要的逻辑，当中有&lt;code&gt;RETURN_***&lt;/code&gt;和&lt;code&gt;php_error_docref&lt;/code&gt;的调用。&lt;/p&gt;
&lt;p&gt;那么，让我们以函数的定义来开始：&lt;/p&gt;
&lt;p&gt;zval *needle;
char *haystack;
char *found = NULL;
char  needle_char[2];
long  offset = 0;
int   haystack_len;&lt;/p&gt;
&lt;p&gt;第一行定义了一个指向&lt;code&gt;zval&lt;/code&gt;的指针&lt;code&gt;needle&lt;/code&gt;。zval是在PHP内部代表任意一个PHP变量的定义。它真正是怎么样的会在下一篇文章重点谈论。&lt;/p&gt;
&lt;p&gt;第二行定义了指向单个字符的指针&lt;code&gt;haystack&lt;/code&gt;。这时候，你需要记住，在C语言里面，数组代表指向它们第一个元素的指针。比如说，&lt;code&gt;haystack&lt;/code&gt;变量会指向你所传递的&lt;code&gt;$haystack&lt;/code&gt;字符串变量的第一个字符。&lt;code&gt;haystack + 1&lt;/code&gt;会指向第二个字符，&lt;code&gt;haystack + 2&lt;/code&gt;指向第三个，以此类推。因此，通过逐个递增指针，可以读取整个字符串。&lt;/p&gt;
&lt;p&gt;那么问题来了，PHP需要知道字符串在哪里结束。不然的话，它会一直递增指针而不会停止。为了解决这个问题，PHP也保存了明确的长度，这就是&lt;code&gt;haystack_len&lt;/code&gt;变量。&lt;/p&gt;
&lt;p&gt;现在，在上面的定义中，我们感兴趣的是offset变量，这个变量用来保存函数的第三个参数：开始搜索的偏移量。它使用long来定义，跟int一样，也是整型数据类型。现在这两者的差异并不重要，但你需要知道的是在PHP中，整型值使用long来存储，字符串的长度使用int来存储。&lt;/p&gt;
&lt;p&gt;现在来看看下面的三行：&lt;/p&gt;
&lt;p&gt;if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &amp;quot;sz|l&amp;quot;, &amp;amp;haystack, &amp;amp;haystack_len, &amp;amp;needle, &amp;amp;offset) == FAILURE) {
return;
}&lt;/p&gt;
&lt;p&gt;这三行代码做的事情就是，获取传递到函数的参数，然后把它们存储到上面声明的变量中。&lt;/p&gt;
&lt;p&gt;传递给函数的第一个参数是传递参数的数量。这个数字通过&lt;code&gt;ZEND_NUM_ARGS()&lt;/code&gt;宏提供。&lt;/p&gt;
&lt;p&gt;下一个函数是&lt;code&gt;TSRMLS_CC&lt;/code&gt;宏，这是PHP的一种特性。你会发现这个奇怪的宏分散在PHP代码库的很多地方。是线程安全资源管理器（TSRM）的一部分，它保证PHP不会在多线程之间混乱变量。这对我们来说不是很重要，当你在代码中看到&lt;code&gt;TSRMLS_CC&lt;/code&gt;（或者&lt;code&gt;TSRMLS_DC&lt;/code&gt;）的时候，忽略它就行。（有一个奇怪的地方你需要注意的是，在&amp;quot;argument&amp;quot;之前没有逗号。这是因为不管你是否使用线程安全创建函数，该宏会被解释为空或者, trsm_ls。因此，逗号是宏的一部分。）&lt;/p&gt;
&lt;p&gt;现在，我们来到重要的东西：&amp;quot;sz|l&amp;quot;字符串标记了函数接收的参数。：&lt;/p&gt;
&lt;p&gt;s  // 第一个参数是字符串
z  // 第二个参数是一个zval结构体，任意的变量
|  // 标识接下来的参数是可选的
l  // 第三个参数是long类型（整型）&lt;/p&gt;
&lt;p&gt;除了s，z，l之外，还有更多的标识类型，但是大部分都能从字符中清楚其意思。例如b是boolean，d是double（浮点型数字），a是array，f是回调（function），o是object。&lt;/p&gt;
&lt;p&gt;接下来的参数&lt;code&gt;&amp;amp;haystack&lt;/code&gt;，&lt;code&gt;&amp;amp;haystack_len&lt;/code&gt;，&lt;code&gt;&amp;amp;needle&lt;/code&gt;，&lt;code&gt;&amp;amp;offset&lt;/code&gt;指定了需要赋值的参数的变量。你可以看到，它们都是使用引用（&amp;amp;）传递的，意味着它们传递的不是变量本身，而是指向它们的指针。&lt;/p&gt;
&lt;p&gt;这个函数调用之后，&lt;code&gt;haystack&lt;/code&gt;会包含haystack字符串，&lt;code&gt;haystack_len&lt;/code&gt;是字符串的长度，needle是needle的值，offset是开始的偏移量。&lt;/p&gt;
&lt;p&gt;而且，这个函数使用FAILURE（当你尝试传递无效参数到函数时会发生，比如传递一个数组赋值到字符串）来检查。这种情况下&lt;code&gt;zend_parse_parameters&lt;/code&gt;函数会抛出警告，而此函数马上返回（会返回null给PHP的用户层代码）。&lt;/p&gt;
&lt;p&gt;在参数解析完毕以后，主函数体开始：&lt;/p&gt;
&lt;p&gt;if (offset &amp;lt; 0 || offset &amp;gt; haystack_len) {
php_error_docref(NULL TSRMLS_CC, E_WARNING, &amp;quot;Offset not contained in string&amp;quot;);
RETURN_FALSE;
}&lt;/p&gt;
&lt;p&gt;这段代码做的事情很明显，如果offset超出了边界，一个E_WARNING级别的错误会通过php_error_docref函数抛出，然后函数使用RETURN_FALSE宏返回false。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;php_error_docref&lt;/code&gt;是一个错误函数，你可以在扩展目录找到它（比如，ext文件夹）。它的名字根据它在错误页面中返回文档参考（就是那些不会正常工作的函数）定义。还有一个&lt;code&gt;zend_error&lt;/code&gt;函数，它主要被Zend Engine使用，但也经常出现在扩展代码中。&lt;/p&gt;
&lt;p&gt;两个函数都使用sprintf函数，比如格式化信息，因此错误信息可以包含占位符，那些占位符会被后面的参数填充。下面有一个例子：&lt;/p&gt;
&lt;p&gt;php_error_docref(NULL TSRMLS_CC, E_WARNING, &amp;quot;Failed to write %d bytes to %s&amp;quot;, Z_STRLEN_PP(tmp), filename);
// %d is filled with Z_STRLEN_PP(tmp)
// %s is filled with filename&lt;/p&gt;
&lt;p&gt;让我们继续解析代码：&lt;/p&gt;
&lt;p&gt;if (Z_TYPE_P(needle) == IS_STRING) {
if (!Z_STRLEN_P(needle)) {
php_error_docref(NULL TSRMLS_CC, E_WARNING, &amp;quot;Empty delimiter&amp;quot;);
RETURN_FALSE;
}&lt;/p&gt;
&lt;p&gt;found = php_memnstr(haystack + offset,
Z_STRVAL_P(needle),
Z_STRLEN_P(needle),
haystack + haystack_len);
}&lt;/p&gt;
&lt;p&gt;前面的5行非常清晰：这个分支只会在needle为字符串的情况下执行，而且如果它是空的话会抛出错误。然后到了比较有趣的一部分：&lt;code&gt;php_memnstr&lt;/code&gt;被调用了，这个函数做了主要的工作。跟往常一样，你可以点击该函数名然后查看它的源码。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;php_memnstr&lt;/code&gt;返回指向needle在haystack第一次出现的位置的指针（这就是为什么found变量要定义为char *，例如，指向字符的指针）。从这里可以知道，偏移量（offset）可以通过减法被简单地计算，可以在函数的最后看到：&lt;/p&gt;
&lt;p&gt;RETURN_LONG(found - haystack);&lt;/p&gt;
&lt;p&gt;最后，让我们来看看当needle作为非字符串的时候的分支：&lt;/p&gt;
&lt;p&gt;else {
if (php_needle_char(needle, needle_char TSRMLS_CC) != SUCCESS) {
RETURN_FALSE;
}
needle_char[1] = 0;&lt;/p&gt;
&lt;p&gt;found = php_memnstr(haystack + offset,
needle_char,
1,
haystack + haystack_len);
}&lt;/p&gt;
&lt;p&gt;我只引用在手册上写的&amp;quot;如果 needle 不是一个字符串，那么它将被转换为整型并被视为字符顺序值。&amp;quot;这基本上说明，除了写&lt;code&gt;strpos($str, &#39;A&#39;)&lt;/code&gt;，你还可以写&lt;code&gt;strpos($str, 65)&lt;/code&gt;，因为A字符的编码是65。&lt;/p&gt;
&lt;p&gt;如果你再查看变量定义，你可以看到&lt;code&gt;needle_char&lt;/code&gt;被定义为&lt;code&gt;char needle_char[2]&lt;/code&gt;，即有两个字符的字符串，&lt;code&gt;php_needle_char&lt;/code&gt;会将真正的字符（在这里是&#39;A&#39;）到needle_char[0]。然后strpos函数会设置needle_char[1]为0。这背后的原因是因为，在C里面，字符串是使用&#39;&#92;0&#39;结尾，就是说，最后一个字符被设置为NUL（编码为0的字符）。在PHP的语法环境里，这样的情况不存在，因为PHP存储了所有字符串的长度（因此它不需要0来帮助找到字符串的结尾），但是为了保证与C函数的兼容性，还是在PHP的内部实现了。&lt;/p&gt;
&lt;h2 id=&quot;zend-functions&quot; tabindex=&quot;-1&quot;&gt;Zend functions&lt;/h2&gt;
&lt;p&gt;我对strpos这个函数感觉好累，让我们找另一个函数吧：strlen。我们使用之前的方法：&lt;/p&gt;
&lt;p&gt;从PHP5.4源码根目录开始搜索strlen。&lt;/p&gt;
&lt;p&gt;你会看到一堆无关的函数的使用，因此，搜索“PHP_FUNCTION strlen”。当你这么搜索的时候，你会发现一些奇怪的事情发生了：没有任何的结果。&lt;/p&gt;
&lt;p&gt;原因是，strlen是少数通过Zend Engine而不是PHP扩展定义的函数。这种情况下，函数不是使用&lt;code&gt;PHP_FUNCTION(strlen)&lt;/code&gt;定义，而是&lt;code&gt;ZEND_FUNCTION(strlen)&lt;/code&gt;。因此，我们也要搜索“ZEND_FUNCTION strlen”。&lt;/p&gt;
&lt;p&gt;我们都知道，我们需要点击没有分号结尾的链接跳到源码的定义。这个链接带我们到下面的函数定义：&lt;/p&gt;
&lt;p&gt;ZEND_FUNCTION(strlen)
{
char *s1;
int s1_len;&lt;/p&gt;
&lt;p&gt;if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &amp;quot;s&amp;quot;, &amp;amp;s1, &amp;amp;s1_len) == FAILURE) {
return;
}&lt;/p&gt;
&lt;p&gt;RETVAL_LONG(s1_len);
}&lt;/p&gt;
&lt;p&gt;这个函数实现太简单了，我不觉得我还需要进一步的解释。&lt;/p&gt;
&lt;h2 id=&quot;%E6%96%B9%E6%B3%95&quot; tabindex=&quot;-1&quot;&gt;方法&lt;/h2&gt;
&lt;p&gt;我们会谈论类和对象如何工作的更多细节在其他文章里，但作为一个小小的剧透：你可以通过在搜索框搜索&lt;code&gt;ClassName::methodName&lt;/code&gt;来搜索对象方法。例如，尝试搜索&lt;code&gt;SplFixedArray::getSize&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%8B%E4%B8%80%E9%83%A8%E5%88%86&quot; tabindex=&quot;-1&quot;&gt;下一部分&lt;/h2&gt;
&lt;p&gt;下一部分会再次发表在。会谈论到zval是什么，它们是怎么工作的，以及它们是怎么在源码中被使用的（所有的Z_***宏）。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>【译】给PHP开发者的PHP源码-第一部分-源码结构</title>
    <link href="https://hoohack.me/blog/2016/2016-02-04-phps-source-code-for-php-developers-ch/"/>
    <updated>2016-02-04T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-02-04-phps-source-code-for-php-developers-ch/</id>
    <content type="html">&lt;p&gt;原文：&lt;a href=&quot;http://blog.ircmaxell.com/2012/03/phps-source-code-for-php-developers.html&quot;&gt;http://blog.ircmaxell.com/2012/03/phps-source-code-for-php-developers.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作为一个开发者，我发现在我的日常工作中越来越多地查看PHP的源码。在为了弄清楚奇怪的边界问题和为什么某些问题应该发生的却没有发生而去理解背后究竟发生了什么事情的时候非常有用。在文档缺失、不完整或者错误的情况下也很有用。因此，我已经决定通过一系列的文章来分享我学到的知识，给予PHP开发者们足够的知识去真正阅读PHP的C语言源码。你并不需要有C语言的基础（我们会总结一些基础），但如果有的话会更有帮助。&lt;/p&gt;
&lt;p&gt;这是这个系列的第一篇文章。在这篇文章，我们会谈论PHP程序的基础：在哪里找到它，基本的代码结构和一些最基础的C语言概念。需要说明的是，这一系列文章的目标是获得源码的阅读理解能力。这意味着为了过一下某些点，某些概念会被简化而不是太复杂的描述。这不会给阅读造成明显的差异，但如果你想为源码做贡献，则还有更多的知识需要补充。在我做简化的时候，我会尽量指出这些简化。&lt;/p&gt;
&lt;p&gt;另外，这系列文章是基于5.4版本的源码，在不同版本中，大部分概念都是一样的，但这里，我们需要针对这次的文章有一个版本的定义（为了让新的版本出来后接下来的文章更容易地遵循）。&lt;/p&gt;
&lt;p&gt;那么，我们可以开始了吧？&lt;/p&gt;
&lt;h2 id=&quot;%E5%9C%A8%E5%93%AA%E9%87%8C%E6%89%BE%E5%88%B0php%E7%9A%84%E6%BA%90%E7%A0%81&quot; tabindex=&quot;-1&quot;&gt;在哪里找到PHP的源码&lt;/h2&gt;
&lt;p&gt;下载PHP源码最简单的方式是通过&lt;a href=&quot;http://www.php.net/svn.php&quot;&gt;PHP的SVN仓库&lt;/a&gt;。对于这此文章，我们检出(check out)了5.4的分支。这对于成为PHP的前沿或者真正的开发PHP（解决bugs，实现特性等等）来说是非常棒的。值得注意的是，PHP社区正在（这篇文章正在写的时候）将源码迁移到GIT仓库中。一旦迁移完成，我会更新这篇文章以达到标准。（译者注：译者翻译的时候PHP已经迁移到GIT仓库了）。&lt;/p&gt;
&lt;p&gt;事实上，下载源码对我们的目的来说并不是真正的有用。我们不想编辑它，我们只是想使用它和跟踪它是如何运行的。我们可以下载它，然后导入到一个好的IDE中，在这些IDE中我们可以点击跳到函数的定义和声明，当我发现这比想象中略困难。我有一个更好的解决方案。&lt;/p&gt;
&lt;p&gt;事实证明，PHP社区在维护一个对于我们来说一个&lt;strong&gt;非常好&lt;/strong&gt;的工具。那就是&lt;a href=&quot;http://lxr.php.net/&quot;&gt;lxr.php.net&lt;/a&gt;。这主要是一个自动生成可搜索的源码列表，而且有语法高亮和函数全部有链接的。这个是我几乎只用来浏览C源码的工具，实在太棒（即使在我写补丁的时候，我依然到lxr而不是我正在开发的代码库）。我们还不会讲到如何做更有效的搜索，但我们会在谈论PHP核心函数的时候讲到。&lt;/p&gt;
&lt;p&gt;从这里开始，我们将开始谈论PHP5.4。为了达到这目的，我们会使用&lt;a href=&quot;http://lxr.php.net/xref/PHP_5_4/&quot;&gt;这个lxr链接&lt;/a&gt;作为其他文章的基础。当我提到“5.4的根目录”的时候，我就是说这个页面。&lt;/p&gt;
&lt;p&gt;那么，既然我们可以查看源码目录了，那么我们来谈谈这里面都有什么吧。&lt;/p&gt;
&lt;h2 id=&quot;php%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84&quot; tabindex=&quot;-1&quot;&gt;PHP源码结构&lt;/h2&gt;
&lt;p&gt;那么，当你查看列在5.4的根目录的文件和目录时，还有很多可以研究。我希望你只关注两个目录：&lt;strong&gt;ext&lt;/strong&gt;和&lt;strong&gt;Zend&lt;/strong&gt;。其他的文件和目录对于PHP扩展和开发来说很重要，但对于我们的目的来说，我们完全可以忽略它们。那么，为什么这两个目录那么重要呢？&lt;/p&gt;
&lt;p&gt;PHP程序被分为，你猜对了，两个主要的部分。第一部分是Zend引擎，控制PHP代码运行时候的运行环境。它处理PHP提供的所有“语言层”的特性，包括：变量，表达式，语法解析，代码执行和错误处理。没有这个引擎，就没有PHP。引擎的源码放在了&lt;strong&gt;Zend&lt;/strong&gt;目录。&lt;/p&gt;
&lt;p&gt;PHP第二个核心的部分，是包含在PHP里面的扩展。这些扩展包括我们可以在PHP调用的每一个核心函数（例如&lt;em&gt;strpos&lt;/em&gt;,&lt;em&gt;substr&lt;/em&gt;,&lt;em&gt;array_diff&lt;/em&gt;,&lt;em&gt;mysql_connect&lt;/em&gt;等等）。也包括核心的类（&lt;em&gt;MySQLi&lt;/em&gt;,&lt;em&gt;SplFixedArray&lt;/em&gt;,&lt;em&gt;PDO&lt;/em&gt;等等）。&lt;/p&gt;
&lt;p&gt;在核心代码中，决定在哪里找到你想查看的功能最简单的方法是，查看PHP的&lt;a href=&quot;https://secure.php.net/manual/zh/index.php&quot;&gt;文档首页&lt;/a&gt;。PHP的文档也被分为两个主要的部分（为了达到我们的目的），&lt;a href=&quot;https://secure.php.net/manual/zh/langref.php&quot;&gt;语言参考&lt;/a&gt;和&lt;a href=&quot;https://secure.php.net/manual/zh/funcref.php&quot;&gt;函数参考&lt;/a&gt;。作为一个庞大的概括，如果你想查看的是在语言参考中的定义，很有可能可以在&lt;strong&gt;Zend&lt;/strong&gt;文件夹找到。如果是在函数参考中，可以在&lt;strong&gt;ext&lt;/strong&gt;文件夹中找到。&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%9A%84c%E8%AF%AD%E8%A8%80%E6%A6%82%E5%BF%B5&quot; tabindex=&quot;-1&quot;&gt;一些基本的C语言概念&lt;/h2&gt;
&lt;p&gt;这部分不是为了成为C的入门，而是一个“读者的配套指南”。有如下概念：&lt;/p&gt;
&lt;h3 id=&quot;%E5%8F%98%E9%87%8F&quot; tabindex=&quot;-1&quot;&gt;变量&lt;/h3&gt;
&lt;p&gt;在C里面，变量是静态和强类型的。这意味着变量必须要使用一个类型定义之后才能使用。一旦定义之后，你不能改变它的类型（你可以在之后转换成其他类型，但你需要使用不同的变量来实现）。因为，在C语言里面，变量并不真实地存在。它们只是为了我们使用的方便的内存地址的标签。正因为如此，C语言没有PHP中的引用。取而代之，它有指针。为了我们的目的，把指针想象成指向其他变量的变量。把它当作PHP中变量的变量。&lt;/p&gt;
&lt;p&gt;那么，通过上面的描述，我们来谈论一下变量的语法。C语言没有使用任何的前缀来标识变量。因此，要说出它们的不同的唯一方式（为了达到我们的目的）是查看它们的定义。如果你在函数的顶部（或者函数的声明）看到在类型和空格之后的字符，那就是变量。一个要说明的关键点是变量名前面可以有一个或这多个符号。星号(*)表明变量是指向某个类型的指针（一个引用）。两个星号表明变量是指向指针的指针。三个星号表明变量是指向一个指向其他指针的指针。&lt;/p&gt;
&lt;p&gt;这个间接寻址非常重要，因为PHP内部使用很多的双层指针。这是因为引擎需要能够传递块数据（PHP变量），和所有有趣的类型如PHP引用，写时复制以及对象引用等等。因此，只要意识到**ptr意味着我们正使用两层的引用（不是变量的引用，而是一个数据引用的引用）。这又一点迷惑，但如果引用对你来说是完全新的知识，我建议你阅读一下这方面的知识（尽管我们的目的是不用必需阅读C）。会有帮助的。&lt;/p&gt;
&lt;p&gt;现在，另一个理解指针的事情是它们是如何在C的数组里应用的（不是PHP的数组，而是C语言中的数组）。因为指针是内存地址，我们可以通过分配一块的内存来定义一个数组，然后通过递增指针来遍历它。正常情况下，我们可以使用代表一个字符（8位）的C的数据类型char来存储字符串中的一个字符。但我们也可以像使用数组那样使用它来访问字符串后面的字节。因此，我们可以只在第一个字节里存储一个指针而不是存储正一个字符串在变量中。然后，我们可以递增指针（增加它的内存地址）来遍历整个字符串。&lt;/p&gt;
&lt;p&gt;char *foo = &amp;quot;test&amp;quot;;
// foo 是指向&amp;quot;t&amp;quot;在内存的片段保存&amp;quot;test&amp;quot;的指针
// 要访问&amp;quot;e&amp;quot;，我们可以通过下面的方式：
char e = foo[1];
char e = *(foo + 1);
char e = *(++foo);&lt;/p&gt;
&lt;p&gt;要另外阅读C语言重点的变量和指针，查看这本&lt;a href=&quot;http://home.netcom.com/~tjensen/ptr/pointers.htm&quot;&gt;很好的免费书籍&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;%E9%A2%84%E5%A4%84%E7%90%86%E8%AF%B4%E6%98%8E&quot; tabindex=&quot;-1&quot;&gt;预处理说明&lt;/h3&gt;
&lt;p&gt;C在编译之前使用一步叫做“预处理”的步骤。这一步包含优化和根据你传递给编译器的选项动态使用部分代码。我们将谈论两个主要的预处理器说明：条件语句和宏。&lt;/p&gt;
&lt;p&gt;条件语句允许代码在编译输出或者不是基于定义时被引入。这看起来很像下面的例子。这允许不同的代码根据不同的操作系统被使用（因此尽管它们使用不同的API，也可以在Windows和Linux中很好的使用）。另外，它允许一部分代码被引入或者不是基于定义的指示。事实上，这是配置步骤中如何编译PHP的执行过程。&lt;/p&gt;
&lt;p&gt;#define FOO 1
#if FOO
Foo is defined and not 0
#else
Foo is not defined or is 0
#endif
#ifdef FOO
Foo is defined
#else
Foo is not defined
#endif&lt;/p&gt;
&lt;p&gt;另一个说明我叫它做宏。这是最简单简化代码的迷你函数。它们不是真正的函数，但是在编译预处理是会执行简单的文本替换。因此，宏不会真正地调用函数。你可以为函数定义写一个宏（事实上，PHP就是这么做的，但我们会在后面的文章中深入了解这个）。我想说的是，宏允许在预处理编译时使用更简单的代码。&lt;/p&gt;
&lt;p&gt;#define FOO(a) ((a) + 1)
int b = FOO(1); // Converted to int b = 1 + 1&lt;/p&gt;
&lt;h2 id=&quot;%E6%BA%90%E6%96%87%E4%BB%B6&quot; tabindex=&quot;-1&quot;&gt;源文件&lt;/h2&gt;
&lt;p&gt;最后这一部分，我们需要了解的是两种在C源码使用的类型的文件。主要有两种文件：&lt;strong&gt;.c&lt;/strong&gt;和**.h**。&lt;strong&gt;.c&lt;/strong&gt;文件是包含了源码准备编译的文件。通常来说，&lt;strong&gt;.c&lt;/strong&gt;文件包含了不能分享到其他文件的私有函数的实现。&lt;strong&gt;.h&lt;/strong&gt;（或者说头文件）定义了在**.c**文件中可以被其他文件看到的函数，包括预处理宏。头文件定义公共API的方式，是通过不使用函数体重新声明函数的签名（跟PHP中的接口和抽象方法相似）。这样，源码就可以通过头文件&lt;em&gt;链接&lt;/em&gt;在一起了。&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%8B%E4%B8%80%E9%83%A8%E5%88%86&quot; tabindex=&quot;-1&quot;&gt;下一部分&lt;/h2&gt;
&lt;p&gt;这个系列的下一部分文章，我们即将讨论内部函数在C里面是怎么定义的。因此你可以跳到任意的内部函数（比如&lt;em&gt;strlen&lt;/em&gt;）查看它的定义和它是如何工作的。保持这个节奏。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>在OpenSUSE下编译安装Nginx</title>
    <link href="https://hoohack.me/blog/2016/2016-01-27-compile-install-nginx-in-opensuse/"/>
    <updated>2016-01-27T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-01-27-compile-install-nginx-in-opensuse/</id>
    <content type="html">&lt;h2 id=&quot;%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81&quot; tabindex=&quot;-1&quot;&gt;下载源码&lt;/h2&gt;
&lt;p&gt;在nginx官网上选择稳定的版本&lt;a href=&quot;http://nginx.org/en/download.html&quot;&gt;Nginx&lt;/a&gt;。解压到&lt;code&gt;/usr/local/src/&lt;/code&gt;目录。&lt;/p&gt;
&lt;p&gt;笔者使用的是nginx-1.9.9。&lt;/p&gt;
&lt;h2 id=&quot;%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C&quot; tabindex=&quot;-1&quot;&gt;准备工作&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;进入/usr/local/src继续操作)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85pcre%E5%BA%93&quot; tabindex=&quot;-1&quot;&gt;编译安装pcre库&lt;/h3&gt;
&lt;p&gt;下载:&lt;a href=&quot;ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/&quot;&gt;ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;p&gt;.configure
make &amp;amp;&amp;amp; make install&lt;/p&gt;
&lt;p&gt;高版本会出现&lt;code&gt;No rule to make target &#39;libpcre.la&lt;/code&gt;错误，建议选择版本低一些，因为nginx暂不支持，可以使用8.37版本。&lt;/p&gt;
&lt;p&gt;编译错误：&lt;code&gt;&#39;aclocal-1.14&#39; is missing on your system.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解决：输入命令&lt;code&gt;touch configure.ac aclocal.m4 configure Makefile.am Makefile.in&lt;/code&gt;，然后重新编译。&lt;/p&gt;
&lt;h3 id=&quot;%E5%AE%89%E8%A3%85zlib%E5%BA%93&quot; tabindex=&quot;-1&quot;&gt;安装zlib库&lt;/h3&gt;
&lt;p&gt;下载:&lt;a href=&quot;http://zlib.net/&quot;&gt;http://zlib.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装:&lt;/p&gt;
&lt;p&gt;.configure
make &amp;amp;&amp;amp; make install&lt;/p&gt;
&lt;h3 id=&quot;%E5%AE%89%E8%A3%85ssl&quot; tabindex=&quot;-1&quot;&gt;安装ssl&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.openssl.org/source/&quot;&gt;http://www.openssl.org/source/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解压即可&lt;/p&gt;
&lt;h2 id=&quot;%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85&quot; tabindex=&quot;-1&quot;&gt;编译安装&lt;/h2&gt;
&lt;h3 id=&quot;%E5%B8%B8%E7%94%A8%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%E8%AF%B4%E6%98%8E&quot; tabindex=&quot;-1&quot;&gt;常用编译选项说明&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;--prefix=PATH&lt;/code&gt;： 指定nginx的安装目录。默认&lt;code&gt;/usr/local/nginx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--conf-path=PATH&lt;/code&gt; ： 设置nginx.conf配置文件的路径。nginx允许通过命令行中的&lt;code&gt;-c&lt;/code&gt;选项使用不同的配置文件启动。默认为&lt;code&gt;prefix/conf/nginx.conf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--with-pcre&lt;/code&gt; ： 设置PCRE库的源码路径&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--with-zlib=PATH&lt;/code&gt; ： 指定 zlib的安装目录。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--with-http_ssl_module&lt;/code&gt; ： 使用https协议模块。默认情况下，该模块没有被构建。前提是openssl与openssl-devel已安装&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--with-openssl&lt;/code&gt; ：openssl解压目录&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--pid-path&lt;/code&gt;：nginx运行时的进程ID保存目录&lt;/p&gt;
&lt;h3 id=&quot;%E7%BC%96%E8%AF%91%E6%96%B9%E6%A1%88&quot; tabindex=&quot;-1&quot;&gt;编译方案&lt;/h3&gt;
&lt;p&gt;./configure&lt;br /&gt;
--sbin-path=/usr/local/nginx/nginx&lt;br /&gt;
--conf-path=/usr/local/nginx/nginx.conf&lt;br /&gt;
--pid-path=/usr/local/nginx/nginx.pid&lt;br /&gt;
--with-http_ssl_module&lt;br /&gt;
--with-pcre=/usr/local/src/pcre-8.37&lt;br /&gt;
--with-zlib=/usr/local/src/zlib-1.2.8&lt;br /&gt;
--with-openssl=/usr/local/src/openssl-1.0.1c&lt;/p&gt;
&lt;h3 id=&quot;%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85-1&quot; tabindex=&quot;-1&quot;&gt;编译安装&lt;/h3&gt;
&lt;p&gt;make &amp;amp;&amp;amp; make install&lt;/p&gt;
&lt;h3 id=&quot;%E6%B5%8B%E8%AF%95%E5%AE%89%E8%A3%85%E7%BB%93%E6%9E%9C&quot; tabindex=&quot;-1&quot;&gt;测试安装结果&lt;/h3&gt;
&lt;p&gt;通过命令&lt;code&gt;/usr/local/nginx/nginx&lt;/code&gt;运行nginx&lt;/p&gt;
&lt;p&gt;在命令行下输入 &lt;code&gt;netstat -ptnl | grep &#39;nginx&#39;&lt;/code&gt; 查看nginx是否启动成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/nginx-start-result.png&quot; alt=&quot;nginx启动结果&quot; /&gt;&lt;/p&gt;
&lt;p&gt;打开浏览器，输入localhost，如果看到下面的Welcome nginx页面说明安装成功了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/Nginx-welcome-page.png&quot; alt=&quot;Welcome nginx页面&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;%E6%B7%BB%E5%8A%A0%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC&quot; tabindex=&quot;-1&quot;&gt;添加启动脚本&lt;/h3&gt;
&lt;p&gt;安装完成后，如果需要在命令行下启动和停止nginx，或者添加开机启动任务，需要添加脚本到&lt;code&gt;/etc/init.d/&lt;/code&gt;目录。&lt;/p&gt;
&lt;p&gt;脚本文件：&lt;/p&gt;
&lt;p&gt;#! /bin/sh&lt;/p&gt;
&lt;p&gt;# Description: Startup script for nginx on CentOS、SuSE、redhat. cp it in /etc/init.d and
# chkconfig --add nginx &amp;amp;amp;&amp;amp;amp; chkconfig nginx on
# then you can use server command control nginx
#
# chkconfig: 2345 08 99
# description: Starts, stops nginx&lt;/p&gt;
&lt;p&gt;set -e&lt;/p&gt;
&lt;p&gt;PATH=$PATH:/usr/local/nginx/sbin/
DESC=&amp;quot;nginx daemon&amp;quot;
NAME=nginx
DAEMON=/usr/local/nginx/sbin/$NAME
CONFIGFILE=/usr/local/nginx/conf/nginx.conf
PIDFILE=/usr/local/nginx/logs/$NAME.pid
SCRIPTNAME=/etc/init.d/$NAME&lt;/p&gt;
&lt;p&gt;# Gracefully exit if the package has been removed.
test -x $DAEMON || exit 0&lt;/p&gt;
&lt;p&gt;d_start() {
$DAEMON -c $CONFIGFILE || echo -n &amp;quot; already running&amp;quot;
}&lt;/p&gt;
&lt;p&gt;d_stop() {
kill -QUIT &lt;code&gt;cat $PIDFILE&lt;/code&gt; || echo -n &amp;quot; not running&amp;quot;
}&lt;/p&gt;
&lt;p&gt;d_reload() {
kill -HUP &lt;code&gt;cat $PIDFILE&lt;/code&gt; || echo -n &amp;quot; can&#39;t reload&amp;quot;
}&lt;/p&gt;
&lt;p&gt;case &amp;quot;$1&amp;quot; in
start)
echo -n &amp;quot;Starting $DESC: $NAME&amp;quot;
d_start
echo &amp;quot;.&amp;quot;
;;
stop)
echo -n &amp;quot;Stopping $DESC: $NAME&amp;quot;
d_stop
echo &amp;quot;.&amp;quot;
;;
reload)
echo -n &amp;quot;Reloading $DESC configuration...&amp;quot;
d_reload
echo &amp;quot;reloaded.&amp;quot;
;;
restart)
echo -n &amp;quot;Restarting $DESC: $NAME&amp;quot;
d_stop
sleep 1
d_start
echo &amp;quot;.&amp;quot;
;;
*)
echo &amp;quot;Usage: $SCRIPTNAME {start|stop|restart|force-reload}&amp;quot; &amp;gt;&amp;amp;2
exit 3
;;
esac&lt;/p&gt;
&lt;p&gt;exit 0&lt;/p&gt;
&lt;p&gt;使用方法：&lt;/p&gt;
&lt;p&gt;vim /etc/init.d/nginx
chmod +x /etc/init.d/nginx
chkconfig nginx on
chkconfig --level 2345 nginx on&lt;/p&gt;
&lt;p&gt;启动方法：&lt;/p&gt;
&lt;p&gt;service nginx xxx
/etc/init.d/nginx xxx&lt;/p&gt;
&lt;p&gt;参考文章:&lt;a href=&quot;http://www.coffin5257.com/opensuse-nginx-startup-script/&quot;&gt;openSUSE Nginx 启动脚本&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>【PDO扩展】lastInsertId函数返回0的原因</title>
    <link href="https://hoohack.me/blog/2016/2016-01-19-the-reason-why-lastInsertId-return-0/"/>
    <updated>2016-01-19T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-01-19-the-reason-why-lastInsertId-return-0/</id>
    <content type="html">&lt;h2 id=&quot;%E9%97%AE%E9%A2%98&quot; tabindex=&quot;-1&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;在使用PHP的PDO扩展插入数据的时候，有时候需要获取到最后插入记录的ID作为返回信息。要怎么才能实现这个需求呢？&lt;/p&gt;
&lt;h2 id=&quot;lastinsertid%E5%87%BD%E6%95%B0&quot; tabindex=&quot;-1&quot;&gt;lastInsertId函数&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;使用PDO的lastInsertId函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是，最近在使用的过程中发现有时候lastInsertId函数返回的是0。为什么会这样呢？&lt;/p&gt;
&lt;p&gt;先来看看lastInsertId函数在&lt;a href=&quot;http://php.net/manual/zh/pdo.lastinsertid.php&quot;&gt;PHP手册&lt;/a&gt;上的说明。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;返回最后插入行的ID或序列值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再来看看下面的几个例子。&lt;/p&gt;
&lt;h2 id=&quot;%E6%B5%8B%E8%AF%95%E4%BE%8B%E5%AD%90&quot; tabindex=&quot;-1&quot;&gt;测试例子&lt;/h2&gt;
&lt;h3 id=&quot;%E4%B8%BB%E9%94%AE%E6%98%AFid%E5%AD%97%E6%AE%B5%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9E%E7%BA%A6%E6%9D%9F%E3%80%82&quot; tabindex=&quot;-1&quot;&gt;主键是ID字段，使用自增约束。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%BB%BA%E8%A1%A8%E8%AF%AD%E5%8F%A51.png&quot; alt=&quot;测试数据库表建表语句1&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$dsn = &#39;mysql:dbname=test;host=127.0.0.1&#39;;
$user = &#39;root&#39;;
$password = &#39;root&#39;;&lt;/p&gt;
&lt;p&gt;try{
$dbh = new PDO($dsn, $user, $password);
}catch(PDOException $e){
echo &amp;quot;Connection failed: &amp;quot; . $e-&amp;gt;getMessage();
}&lt;/p&gt;
&lt;p&gt;for( $i = 0; $i &amp;lt; 10; $i++){
$sql = &#39;INSERT INTO &lt;code&gt;tbl_test&lt;/code&gt; (id, name) VALUE (:id, :name)&#39;;
$data = array(
&#39;:id&#39; =&amp;gt; &#39;&#39;,
&#39;:name&#39; =&amp;gt; &amp;quot;user_$i&amp;quot;
);
$sth = $dbh-&amp;gt;prepare($sql);
$sth-&amp;gt;execute($data);
}&lt;/p&gt;
&lt;p&gt;$sql = &#39;INSERT INTO &lt;code&gt;tbl_test&lt;/code&gt; (id, name) VALUE (:id, :name)&#39;;
$new_data = array(
&#39;:id&#39; =&amp;gt; &#39;&#39;,
&#39;:name&#39; =&amp;gt; &#39;user_new&#39;
);
$sth = $dbh-&amp;gt;prepare($sql);
$sth-&amp;gt;execute($new_data);
$last_id = $dbh-&amp;gt;lastInsertId();
echo &#39;last id: &#39; . $last_id;&lt;/p&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;last id: 11&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;%E4%B8%BB%E9%94%AE%E6%98%AFid%E5%AD%97%E6%AE%B5%EF%BC%8C%E4%B8%8D%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9E%E7%BA%A6%E6%9D%9F%E3%80%82&quot; tabindex=&quot;-1&quot;&gt;主键是ID字段，不使用自增约束。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%BB%BA%E8%A1%A8%E8%AF%AD%E5%8F%A52.png&quot; alt=&quot;测试数据库表建表语句2&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$dsn = &#39;mysql:dbname=test;host=127.0.0.1&#39;;
$user = &#39;root&#39;;
$password = &#39;root&#39;;&lt;/p&gt;
&lt;p&gt;try{
$dbh = new PDO($dsn, $user, $password);
}catch(PDOException $e){
echo &amp;quot;Connection failed: &amp;quot; . $e-&amp;gt;getMessage();
}&lt;/p&gt;
&lt;p&gt;for( $i = 0; $i &amp;lt; 10; $i++){
$sql = &#39;INSERT INTO &lt;code&gt;tbl_test&lt;/code&gt; (id, name) VALUE (:id, :name)&#39;;
$data = array(
&#39;:id&#39; =&amp;gt; $i,
&#39;:name&#39; =&amp;gt; &amp;quot;user_$i&amp;quot;
);
$sth = $dbh-&amp;gt;prepare($sql);
$sth-&amp;gt;execute($data);
}&lt;/p&gt;
&lt;p&gt;$sql = &#39;INSERT INTO &lt;code&gt;tbl_test&lt;/code&gt; (id, name) VALUE (:id, :name)&#39;;
$new_data = array(
&#39;:id&#39; =&amp;gt; &#39;&#39;,
&#39;:name&#39; =&amp;gt; &#39;user_new&#39;
);
$sth = $dbh-&amp;gt;prepare($sql);
$sth-&amp;gt;execute($new_data);
$last_id = $dbh-&amp;gt;lastInsertId();
echo &#39;last id: &#39; . $last_id;&lt;/p&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;last id: 0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;%E4%B8%BB%E9%94%AE%E4%B8%8D%E6%98%AFid%E5%AD%97%E6%AE%B5%EF%BC%8C%E4%B8%BB%E9%94%AE%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9E%E7%BA%A6%E6%9D%9F%E3%80%82&quot; tabindex=&quot;-1&quot;&gt;主键不是ID字段，主键使用自增约束。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%BB%BA%E8%A1%A8%E8%AF%AD%E5%8F%A53.png&quot; alt=&quot;测试数据库表建表语句3&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$dsn = &#39;mysql:dbname=test;host=127.0.0.1&#39;;
$user = &#39;root&#39;;
$password = &#39;root&#39;;&lt;/p&gt;
&lt;p&gt;try{
$dbh = new PDO($dsn, $user, $password);
}catch(PDOException $e){
echo &amp;quot;Connection failed: &amp;quot; . $e-&amp;gt;getMessage();
}&lt;/p&gt;
&lt;p&gt;for( $i = 0; $i &amp;lt; 10; $i++){
$sql = &#39;INSERT INTO &lt;code&gt;tbl_test&lt;/code&gt; (tbl_id, name) VALUE (:tbl_id, :name)&#39;;
$data = array(
&#39;:tbl_id&#39; =&amp;gt; $i,
&#39;:name&#39; =&amp;gt; &amp;quot;user_$i&amp;quot;
);
$sth = $dbh-&amp;gt;prepare($sql);
$sth-&amp;gt;execute($data);
}&lt;/p&gt;
&lt;p&gt;$sql = &#39;INSERT INTO &lt;code&gt;tbl_test&lt;/code&gt; (tbl_id, name) VALUE (:tbl_id, :name)&#39;;
$new_data = array(
&#39;:tbl_id&#39; =&amp;gt; &#39;&#39;,
&#39;:name&#39; =&amp;gt; &#39;user_new&#39;
);
$sth = $dbh-&amp;gt;prepare($sql);
$sth-&amp;gt;execute($new_data);
$last_id = $dbh-&amp;gt;lastInsertId();
echo &#39;last id: &#39; . $last_id;&lt;/p&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;last id: 11&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;%E4%B8%BB%E9%94%AE%E4%B8%8D%E6%98%AFid%E5%AD%97%E6%AE%B5%EF%BC%8C%E4%B8%8D%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9E%E7%BA%A6%E6%9D%9F%E3%80%82&quot; tabindex=&quot;-1&quot;&gt;主键不是ID字段，不使用自增约束。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%BB%BA%E8%A1%A8%E8%AF%AD%E5%8F%A54.png&quot; alt=&quot;测试数据库表建表语句4&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$dsn = &#39;mysql:dbname=test;host=127.0.0.1&#39;;
$user = &#39;root&#39;;
$password = &#39;root&#39;;&lt;/p&gt;
&lt;p&gt;try{
$dbh = new PDO($dsn, $user, $password);
}catch(PDOException $e){
echo &amp;quot;Connection failed: &amp;quot; . $e-&amp;gt;getMessage();
}&lt;/p&gt;
&lt;p&gt;for( $i = 0; $i &amp;lt; 10; $i++){
$sql = &#39;INSERT INTO &lt;code&gt;tbl_test&lt;/code&gt; (tbl_id, name) VALUE (:tbl_id, :name)&#39;;
$data = array(
&#39;:tbl_id&#39; =&amp;gt; uniqid(),
&#39;:name&#39; =&amp;gt; &amp;quot;user_$i&amp;quot;
);
$sth = $dbh-&amp;gt;prepare($sql);
$sth-&amp;gt;execute($data);
}&lt;/p&gt;
&lt;p&gt;$sql = &#39;INSERT INTO &lt;code&gt;tbl_test&lt;/code&gt; (tbl_id, name) VALUE (:tbl_id, :name)&#39;;
$new_data = array(
&#39;:tbl_id&#39; =&amp;gt; uniqid(),
&#39;:name&#39; =&amp;gt; &#39;user_new&#39;
);
$sth = $dbh-&amp;gt;prepare($sql);
$sth-&amp;gt;execute($new_data);
$last_id = $dbh-&amp;gt;lastInsertId();
echo &#39;last id: &#39; . $last_id;&lt;/p&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;last id: 0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E6%9F%A5%E7%9C%8Bphp%E6%BA%90%E7%A0%81&quot; tabindex=&quot;-1&quot;&gt;查看PHP源码&lt;/h2&gt;
&lt;p&gt;可以看到，有些例子返回0，有些例子返回最新的ID。那么lastInsertId什么情况下会返回0呢？在网上搜了很多资料，并没有发现想要的答案，翻开PHP源码，发现函数&lt;code&gt;last_insert_id&lt;/code&gt;的实现源码是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E5%87%BD%E6%95%B0last_insert_id%E6%BA%90%E7%A0%81.jpg&quot; alt=&quot;函数last_insert_id源码&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到，函数返回的id的值是调用mysql api中的&lt;code&gt;mysql_insert_id&lt;/code&gt;函数返回的值。&lt;/p&gt;
&lt;h2 id=&quot;%E6%9F%A5%E7%9C%8Bmysql%E6%89%8B%E5%86%8C&quot; tabindex=&quot;-1&quot;&gt;查看mysql手册&lt;/h2&gt;
&lt;p&gt;翻开mysql手册，在&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.6/en/getting-unique-id.html&quot;&gt;这里&lt;/a&gt;找到这一段：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mysql_insert_id() returns the value stored into an AUTO_INCREMENT column, whether that value is automatically generated by storing NULL or 0 or was specified as an explicit value. LAST_INSERT_ID() returns only automatically generated AUTO_INCREMENT values. If you store an explicit value other than NULL or 0, it does not affect the value returned by LAST_INSERT_ID().&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E7%BB%93%E8%AE%BA&quot; tabindex=&quot;-1&quot;&gt;结论&lt;/h2&gt;
&lt;p&gt;从手册的描述可以知道，&lt;code&gt;mysql_insert_id&lt;/code&gt;函数返回的是储存在有&lt;code&gt;AUTO_INCREMENT&lt;/code&gt;约束的字段的值，如果表中的字段不使用&lt;code&gt;AUTO_INCREMENT&lt;/code&gt;约束或者使用自己生成的唯一值插入，那么该函数不会返回你所存储的值，而是返回NULL或0。因此，在没有使用AUTO_INCREMENT约束的表中，或者ID是自己生成的唯一ID，lastInsertId函数返回的都是0。&lt;/p&gt;
&lt;h2 id=&quot;%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&quot; tabindex=&quot;-1&quot;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;那么，有没有另一种方法可以帮助我们判断程序执行插入是否成功呢？答案是有的。在PDO执行了excecute之后，调用PDO实例的rowCount函数可以得到执行之后的影响行数，如果结果非0，那么说明数据库插入操作执行成功了。下面这个解决方案的一小段demo：&lt;/p&gt;
&lt;p&gt;$sql = &#39;INSERT INTO &lt;code&gt;tbl_test&lt;/code&gt; (tbl_id, name) VALUE (:tbl_id, :name)&#39;;
$new_data = array(
&#39;:tbl_id&#39; =&amp;gt; uniqid(),
&#39;:name&#39; =&amp;gt; &#39;user_another&#39;
);
$sth = $dbh-&amp;gt;prepare($sql);
$sth-&amp;gt;execute($new_data);
$row_count = $sth-&amp;gt;rowCount();
if( $row_count ){
echo &#39;execute success&#39;;
} else{
echo &#39;execute failed&#39;;
}&lt;/p&gt;
&lt;p&gt;本文探讨一个问题出现的原因和一个解决方案，由于个人水平有限，如有更好的方法或者其他建议和批评，欢迎指出。&lt;/p&gt;
&lt;p&gt;注：本文使用的是PHP5.4.15，MySQL5.5.41。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>【译】更快的方式实现PHP数组去重</title>
    <link href="https://hoohack.me/blog/2016/2016-01-11-faster-way-to-phps-array-unique-function/"/>
    <updated>2016-01-11T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-01-11-faster-way-to-phps-array-unique-function/</id>
    <content type="html">&lt;p&gt;原文:&lt;a href=&quot;http://www.thecave.info/faster-alternative-to-phps-array-unique-function/&quot;&gt;Faster Alternative to PHP’s Array Unique Function&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E6%A6%82%E8%BF%B0&quot; tabindex=&quot;-1&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;使用PHP的&lt;code&gt;array_unique()&lt;/code&gt;函数允许你传递一个数组，然后移除重复的值，返回一个拥有唯一值的数组。这个函数大多数情况下都能工作得很好。但是，如果你尝试在一个大的数组里使用&lt;code&gt;array_unique（）&lt;/code&gt;函数，它会运行地慢一些。&lt;/p&gt;
&lt;p&gt;有一个比较好而且更快的函数&lt;code&gt;array_flip()&lt;/code&gt;来替代使用&lt;code&gt;array_unique()&lt;/code&gt;函数来创建唯一的数组。这个魔法般的函数会交换数组里面每一个元素的键和值，因为键值必须唯一，因此，你会得到跟&lt;code&gt;array_unique()&lt;/code&gt;函数一样的结果。&lt;/p&gt;
&lt;h2 id=&quot;%E6%9B%B4%E5%BF%AB%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0php%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D&quot; tabindex=&quot;-1&quot;&gt;更快的方式实现PHP数组去重&lt;/h2&gt;
&lt;p&gt;/* 创建一个包含重复值的，一共四个元素的数组 */
$array = array(&#39;green&#39;,&#39;blue&#39;,&#39;orange&#39;,&#39;blue&#39;);&lt;/p&gt;
&lt;p&gt;/* 翻转数组，你将会得到唯一键值的数组
array(&#39;green&#39;=&amp;gt;0,&#39;blue&#39;=&amp;gt;1,&#39;orange&#39;=&amp;gt;2); */
$array = array_flip($array);&lt;/p&gt;
&lt;p&gt;/* 然后再翻转一次，将键和值重新放置，然后得到数组：array(0=&amp;gt;&#39;green&#39;,1=&amp;gt;&#39;blue&#39;,2=&amp;gt;&#39;orange&#39;); */
$array = array_flip($array);&lt;/p&gt;
&lt;p&gt;因为我们已经移除了一些元素，因此数组看起来不是正常的序列。比如我们可能会得到：&lt;code&gt;array(0=&amp;gt;’A’,2=&amp;gt;’B’,5=&amp;gt;’C’);&lt;/code&gt;。在某些情况下，这不是一个问题，但是如果你需要数组的键值保持数字的序列，你可以使用一到两种方法解决键值乱序的问题。&lt;/p&gt;
&lt;h2 id=&quot;%E4%BD%BF%E7%94%A8array_merge%E4%BF%AE%E5%A4%8D%E6%95%B0%E7%BB%84%E7%9A%84keys&quot; tabindex=&quot;-1&quot;&gt;使用array_merge修复数组的keys&lt;/h2&gt;
&lt;p&gt;添加array_flip之后的函数，将会对数组的键值排序并且让它们恢复到正常的序列，如：0,1,2,3...&lt;/p&gt;
&lt;p&gt;$array = array(&#39;green&#39;,&#39;blue&#39;,&#39;orange&#39;,&#39;blue&#39;);
$array = array_flip($array);
$array = array_flip($array);&lt;/p&gt;
&lt;p&gt;/* 使用array_merge()函数修复键值*/
$array = array_merge($array);&lt;/p&gt;
&lt;h2 id=&quot;%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BD%BF%E7%94%A8array_keys&quot; tabindex=&quot;-1&quot;&gt;第二种方式，使用array_keys&lt;/h2&gt;
&lt;p&gt;注意，这种修复数组键值的方法比使用&lt;code&gt;array_merge()&lt;/code&gt;函数稍微快了一点。你也可以在最后一步结合使用&lt;code&gt;array_keys()&lt;/code&gt;函数(此函数返回翻转后的值)。然后当你翻转数组的值，键值就会根据顺序创建。&lt;/p&gt;
&lt;p&gt;$array = array(&#39;green&#39;,&#39;blue&#39;,&#39;orange&#39;,&#39;blue&#39;);
$array = array_flip($array);
/* 跟第一个例子一样，但是现在我们先提取数组的键值 */
$array = array_keys($array);&lt;/p&gt;
&lt;h2 id=&quot;%E7%BB%93%E8%AE%BA&quot; tabindex=&quot;-1&quot;&gt;结论&lt;/h2&gt;
&lt;p&gt;非常简单，比起在大数组使用array_unique函数，有了一个有效的性能提升。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>迟到的2015总结</title>
    <link href="https://hoohack.me/blog/2016/2016-01-05-late-summary-about-2015/"/>
    <updated>2016-01-05T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2016/2016-01-05-late-summary-about-2015/</id>
    <content type="html">&lt;p&gt;2015年，是真正出来参与工作的一年，没有激昂的情绪，没有忙成狗的节奏，但有健康的生活，有充实的生活。&lt;/p&gt;
&lt;h2 id=&quot;%E5%B7%A5%E4%BD%9C&quot; tabindex=&quot;-1&quot;&gt;工作&lt;/h2&gt;
&lt;p&gt;这一年，结束了学生生涯。毕业了。开始真正出来工作了，从实习第一天起，导师就跟我说，团队准备做一个从无到有的项目，要做好加班的心里准备，顿时吓得我开始发慌了。刚开始确实疯狂加班加了一个月，一个多月后项目上线了，由于各种原因，项目要交接出去了。原有团队也走了好几个，最后连主管都走了。后来团队就准备交接项目，然后接手其他项目，交接过程中比较漫长，中途找了一些业余时间研究了一些东西，分别有&lt;a href=&quot;https://github.com/hoohack/zhihuSpider&quot;&gt;知乎爬虫&lt;/a&gt;，&lt;a href=&quot;https://github.com/hoohack/SwitchHosts&quot;&gt;切换Hosts项目&lt;/a&gt;，&lt;a href=&quot;https://github.com/hoohack/DesignPattern&quot;&gt;设计模式学习与实现&lt;/a&gt;。总的来说，这一年的进步比起自己在学校的时候要大，但是比起工作任务很多的小伙伴们，还是进步地太慢了。&lt;/p&gt;
&lt;h3 id=&quot;polean&quot; tabindex=&quot;-1&quot;&gt;Polean&lt;/h3&gt;
&lt;p&gt;在这里来一段小插曲，用一段话纪念一下前任主管。前任主管是一个很牛逼的人，从腾讯跳过来的，非计算机专业，自学成才。样子看上去很成熟，然而还不到30岁。最佩服的是他解决问题有自己的方法，他会一步一步去深入思考问题的本质，而不是急于去给某个问题下结论，不会轻易就说为什么会出现这个问题。很可惜没有与他有更多的交流。致Polean。&lt;/p&gt;
&lt;h2 id=&quot;%E5%AD%A6%E4%B9%A0&quot; tabindex=&quot;-1&quot;&gt;学习&lt;/h2&gt;
&lt;p&gt;参加工作后接触到的知识更加多，选择性地去学习，这一年里，学习到的新技术：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;node-webkit&lt;/li&gt;
&lt;li&gt;node-Js基础&lt;/li&gt;
&lt;li&gt;PHP多线程编程&lt;/li&gt;
&lt;li&gt;设计模式&lt;/li&gt;
&lt;li&gt;golang基础&lt;/li&gt;
&lt;li&gt;PHP安全编程&lt;/li&gt;
&lt;li&gt;MySQL索引&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;完成了10本技术书的读书目标，其中最有帮助的是《代码大全》。里面讲得更多的是编程思想、编程风格以及设计模式。&lt;/p&gt;
&lt;p&gt;超额完成了读书计划，一共读了35本书（原计划24本）。最喜欢的一本书是《岛上书店(英文版)》。讲述的是一个关于孤独，以及生命中的艰难时期如何将人生变得更美好辽阔的故事。&lt;/p&gt;
&lt;h2 id=&quot;%E7%94%9F%E6%B4%BB&quot; tabindex=&quot;-1&quot;&gt;生活&lt;/h2&gt;
&lt;p&gt;完成了和女友去旅游的目标。去了一次四川成都，是和公司部门的人一起去的。是一次很惬意和很开心的旅程，和部门的人玩得很开心。&lt;/p&gt;
&lt;p&gt;这一年跑步更多了，跑步是因为想要健康的生活和保持每天的精力，也希望锻炼更坚强的毅力。不断地健身，可以不休息地做完腹肌撕裂者，感觉很好。现在在锻炼平板支撑，最长记录是3:30，当然，下一年要破这个记录。&lt;/p&gt;
&lt;p&gt;感情上也稳定，更多问题达到了共识，不知不觉快六年了，继续走下去。&lt;/p&gt;
&lt;h2 id=&quot;%E5%8D%9A%E5%AE%A2&quot; tabindex=&quot;-1&quot;&gt;博客&lt;/h2&gt;
&lt;p&gt;博客的记录比起2014多了一些，有几个月的时间没有更新，因为那段时间没有技术类的东西可以分享，其实也可以分享一些生活或者对某些问题的见解，或者翻译一下国外文章也可以。还是要坚持写博客，因为写博客可以让自己知道某个知识点是否完全掌握了，大脑里面的知道和写出来是完全不同的。如果不知道某个知识点是否完全掌握，不妨写下来，看别人看懂了多少就可以知道你掌握了多少了。&lt;/p&gt;
&lt;h2 id=&quot;2016&quot; tabindex=&quot;-1&quot;&gt;2016&lt;/h2&gt;
&lt;p&gt;2016年，是未知的一年，前面充满挑战和机会。希望自己踏实前进，该干嘛干嘛，完成该完成的计划，该学习学习，该工作工作，该运动运动，活在当下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/2016.png&quot; alt=&quot;2016&quot; /&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>如何在openSUSE42.1下编译安装PHP7</title>
    <link href="https://hoohack.me/blog/2015/2015-12-24-how-to-compile-php7-on-opensuse-leap-42-1/"/>
    <updated>2015-12-24T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-12-24-how-to-compile-php7-on-opensuse-leap-42-1/</id>
    <content type="html">&lt;p&gt;首先推荐一篇文章&lt;a href=&quot;http://www.phpclasses.org/blog/post/333-PHP-7-Release-Date-Arrived-Will-Developers-Adopt-PHP-7.html&quot;&gt;PHP 7 Release Date Arrived: Will Developers Adopt PHP 7? - PHP Classes blog&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;里面说到是否会去使用PHP7，就个人而言，我是毫不犹豫地使用的，但是生产环境就不是我说了算，所以只能自己在自己的开发环境里更新PHP的版本。那么，你呢？&lt;/p&gt;
&lt;p&gt;笔者使用的是Linux的openSUSE42.1发行版，Yast里面还没有PHP7的安装包，于是乎只能自己手动编译安装了。作为一个PHP开发者，我是非常希望能够学会编译安装PHP7的，之前试过几次，但是每次安装都要上网找各种资料，于是乎，这次安装成功后就想把自己的安装过程以及遇到的问题记录下来，方便以后查阅和分享给需要的人。&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81%E5%B9%B6%E8%A7%A3%E5%8E%8B&quot; tabindex=&quot;-1&quot;&gt;下载源码并解压&lt;/h2&gt;
&lt;p&gt;进入正题，要编译安装PHP7,首先当然要下载PHP7的源码。你可以到&lt;a href=&quot;https://github.com/php/php-src&quot;&gt;github&lt;/a&gt;上clone，也可以到&lt;a href=&quot;http://php.net/downloads.php&quot;&gt;PHP官网&lt;/a&gt;下载。下载后解压到&lt;code&gt;/usr/local/src&lt;/code&gt;目录，并将目录重命名为php7。进入目录。&lt;/p&gt;
&lt;h2 id=&quot;%E9%85%8D%E7%BD%AE%E7%BC%96%E8%AF%91%E5%8F%82%E6%95%B0&quot; tabindex=&quot;-1&quot;&gt;配置编译参数&lt;/h2&gt;
&lt;h3 id=&quot;%E7%94%9F%E6%88%90%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&quot; tabindex=&quot;-1&quot;&gt;生成配置文件&lt;/h3&gt;
&lt;p&gt;./buildconf&lt;/p&gt;
&lt;h3 id=&quot;%E9%85%8D%E7%BD%AE&quot; tabindex=&quot;-1&quot;&gt;配置&lt;/h3&gt;
&lt;p&gt;./configure &lt;br /&gt;
--prefix=/usr/local/php7 &lt;br /&gt;
--exec-prefix=/usr/local/php7 &lt;br /&gt;
--bindir=/usr/local/php7/bin &lt;br /&gt;
--sbindir=/usr/local/php7/sbin &lt;br /&gt;
--includedir=/usr/local/php7/include &lt;br /&gt;
--libdir=/usr/local/php7/lib/php &lt;br /&gt;
--mandir=/usr/local/php7/php/man &lt;br /&gt;
--with-config-file-path=/usr/local/php7/etc &lt;br /&gt;
--with-mysql-sock=/var/run/mysql/mysql.sock &lt;br /&gt;
--with-mcrypt=/usr/include &lt;br /&gt;
--with-mhash &lt;br /&gt;
--with-openssl &lt;br /&gt;
--with-mysqli=shared,mysqlnd &lt;br /&gt;
--with-pdo-mysql=shared,mysqlnd &lt;br /&gt;
--with-gd &lt;br /&gt;
--with-iconv &lt;br /&gt;
--with-zlib &lt;br /&gt;
--enable-zip &lt;br /&gt;
--enable-inline-optimization &lt;br /&gt;
--disable-debug &lt;br /&gt;
--disable-rpath &lt;br /&gt;
--enable-shared &lt;br /&gt;
--enable-xml &lt;br /&gt;
--enable-bcmath &lt;br /&gt;
--enable-shmop &lt;br /&gt;
--enable-sysvsem &lt;br /&gt;
--enable-mbregex &lt;br /&gt;
--enable-mbstring &lt;br /&gt;
--enable-ftp &lt;br /&gt;
--enable-gd-native-ttf &lt;br /&gt;
--enable-pcntl &lt;br /&gt;
--enable-sockets &lt;br /&gt;
--with-xmlrpc &lt;br /&gt;
--enable-soap &lt;br /&gt;
--without-pear &lt;br /&gt;
--with-gettext &lt;br /&gt;
--enable-session &lt;br /&gt;
--with-curl &lt;br /&gt;
--with-jpeg-dir &lt;br /&gt;
--with-freetype-dir &lt;br /&gt;
--enable-opcache &lt;br /&gt;
--enable-fpm &lt;br /&gt;
--disable-cgi &lt;br /&gt;
--with-fpm-user=nginx &lt;br /&gt;
--with-fpm-group=nginx &lt;br /&gt;
--without-gdbm &lt;br /&gt;
--disable-fileinfo&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参数说明
prefix PHP7安装的根目录
with-config-file-path PHP7的配置文件目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;执行完上面的配置命令后的结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/php7-configure-result.png&quot; alt=&quot;安装PHPconfigure结果&quot; /&gt;&lt;/p&gt;
&lt;p&gt;执行上面命令的过程中会遇到一些依赖缺少的提示，下面列出我遇到的依赖问题：&lt;/p&gt;
&lt;p&gt;错误：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;configure: error: xml2-config not found. Please check your libxml2 installation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;zypper install libxml2-devel&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;错误：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;configure: WARNING: unrecognized options: --with-mysql&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;取消这个选项，这个选项是不存在的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;错误：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;configure: error: jpeglib.h not found.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;zypper install libjpeg-devel&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;错误：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;configure: error: mcrypt.h not found. Please reinstall libmcrypt.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;zypper install libmcrypt-devel&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;错误：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;configure: error: Cannot find pspell&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;取消该选项&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;错误：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;checking for recode support... yes
configure: error: Can not find recode.h anywhere under /usr /usr/local /usr /opt.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;zypper install librecode-devel&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总的来说，在配置的时候遇到没有的就打开Yast搜一下，如果有的话就安装，然后重新编译看还需要那些，如果在Yast找不到，那就上网找一下Google。&lt;/p&gt;
&lt;h2 id=&quot;%E7%BC%96%E8%AF%91%E5%92%8C%E5%AE%89%E8%A3%85php7&quot; tabindex=&quot;-1&quot;&gt;编译和安装PHP7&lt;/h2&gt;
&lt;p&gt;make &amp;amp;&amp;amp; make install&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其中，make之后可以选择make test。只是一个可选步骤，不执行不知道有什么问题，不过笔者暂时还没遇到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E6%9F%A5%E7%9C%8B%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F%E5%90%8E%E7%9A%84php7%E7%9B%AE%E5%BD%95&quot; tabindex=&quot;-1&quot;&gt;查看安装成功后的PHP7目录&lt;/h2&gt;
&lt;p&gt;编译安装成功后，查看PHP7的安装目录&lt;code&gt;ls /usr/local/php7&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/php-installed-dir.png&quot; alt=&quot;PHP7安装目录&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E8%AE%BE%E7%BD%AEphp7%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&quot; tabindex=&quot;-1&quot;&gt;设置PHP7的配置文件&lt;/h2&gt;
&lt;p&gt;cp /usr/local/src/php7/php.ini-production /usr/local/php7/etc/php.ini
cp /usr/local/src/php7/sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm
cp /usr/local/php7/etc/php-fpm.conf.default /usr/local/php7/etc/php-fpm.conf
cp /usr/local/php7/etc/php-fpm.d/www.conf.default /usr/local/php7/etc/php-fpm.d/www.conf&lt;/p&gt;
&lt;h2 id=&quot;%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&quot; tabindex=&quot;-1&quot;&gt;添加环境变量&lt;/h2&gt;
&lt;p&gt;在/etc/profile 文件的最后一行加上&lt;/p&gt;
&lt;p&gt;export PATH=/usr/local/php7/bin:/usr/local/php7/sbin:$PATH&lt;/p&gt;
&lt;p&gt;然后执行&lt;code&gt;source /etc/profile&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E8%AE%BE%E7%BD%AEphp%E6%97%A5%E5%BF%97%E7%9B%AE%E5%BD%95%E5%92%8Cphp-fpm%E8%BF%9B%E7%A8%8B%E6%96%87%E4%BB%B6%EF%BC%88php-fpm.sock%EF%BC%89%E7%9B%AE%E5%BD%95&quot; tabindex=&quot;-1&quot;&gt;设置PHP日志目录和php-fpm进程文件（php-fpm.sock）目录&lt;/h2&gt;
&lt;p&gt;mkdir -p /var/log/php-fpm/ &amp;amp;&amp;amp; mkdir -p /var/run/php-fpm &amp;amp;&amp;amp; cd /var/run/ &amp;amp;&amp;amp; chown -R nginx:nginx php-fpm&lt;/p&gt;
&lt;h2 id=&quot;%E5%B0%86php%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8&quot; tabindex=&quot;-1&quot;&gt;将PHP设置为开机启动&lt;/h2&gt;
&lt;p&gt;chmod +x /etc/init.d/php-fpm
chkconfig php-fpm on&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以用chkconfig命令查看开机启动服务列表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E5%90%AF%E5%8A%A8php%E6%9C%8D%E5%8A%A1&quot; tabindex=&quot;-1&quot;&gt;启动PHP服务&lt;/h2&gt;
&lt;p&gt;service php-fpm start&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过&lt;code&gt;ps aux | grep &#39;php&#39;&lt;/code&gt;查看PHP是否启动成功&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/php-run.png&quot; alt=&quot;PHP启动&quot; /&gt;&lt;/p&gt;
&lt;p&gt;至此，PHP7就安装成功了，你也开始使用PHP7吧！&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>【nginx配置】nginx做非80端口转发</title>
    <link href="https://hoohack.me/blog/2015/2015-12-10-nginx-non80-port-forward/"/>
    <updated>2015-12-10T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-12-10-nginx-non80-port-forward/</id>
    <content type="html">&lt;h2 id=&quot;%E4%B8%80%E4%B8%AA%E5%9C%BA%E6%99%AF&quot; tabindex=&quot;-1&quot;&gt;一个场景&lt;/h2&gt;
&lt;p&gt;最近在使用PHP重写一个使用JAVA写的项目，因为需要查看之前的项目，所以要在本地搭建一个Tomcat来跑JAVA的项目。搭建成功后，因为Tomcat监听的端口是8080，因此，访问的URL前缀是&lt;code&gt;localhost:8080&lt;/code&gt;，每次访问项目的时候都要先输入这一串内容，感觉比较繁杂，所以想着将其变成&lt;code&gt;localhost&lt;/code&gt;来访问，但是这样的话就是访问80端口了，要达到目的，就得做端口转发。笔者见识比较少，暂时想到的是使用Nginx/Apache等程序做转发。如果有更好的方案，欢迎指教。&lt;/p&gt;
&lt;h2 id=&quot;%E5%A2%9E%E5%8A%A0nginx%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA&quot; tabindex=&quot;-1&quot;&gt;增加Nginx虚拟主机&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/nginx%E9%85%8D%E7%BD%AE.jpg&quot; alt=&quot;nginx配置&quot; /&gt;&lt;/p&gt;
&lt;p&gt;要做Nginx的转发，当然就要对Nginx做配置。可以通过添加虚拟主机配置来增强Nginx的功能。首先看看Nginx的配置文件，笔者的Nginx文件是在&lt;code&gt;/etc/nginx/nginx.conf&lt;/code&gt;。从上图可以看到Nginx在最后引入了&lt;code&gt;vhosts.d&lt;/code&gt;目录下的配置文件。那么就要在&lt;code&gt;/etc/nginx/vhosts.d&lt;/code&gt;目录下创建以.conf为后缀的文件（如果该目录不存在需要自己创建）。&lt;/p&gt;
&lt;h2 id=&quot;nginx%E5%81%9A%E9%9D%9E80%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91&quot; tabindex=&quot;-1&quot;&gt;Nginx做非80端口转发&lt;/h2&gt;
&lt;p&gt;要做转发，可以使用Nginx的&lt;code&gt;proxy_pass&lt;/code&gt;配置项。Nginx监听80端口，接收到请求之后就会转发到要转发的URL。具体的配置如下:&lt;/p&gt;
&lt;p&gt;server {
server_name &lt;a href=&quot;http://www.test.com/&quot;&gt;www.test.com&lt;/a&gt;
listen 80;&lt;/p&gt;
&lt;p&gt;location / {
proxy_pass &lt;a href=&quot;http://127.0.0.1:8080/&quot;&gt;http://127.0.0.1:8080&lt;/a&gt;;
}
}&lt;/p&gt;
&lt;p&gt;是的，就是这么简单就可以了。这是配置端口转发的核心。&lt;/p&gt;
&lt;p&gt;但是，当遇到需要获取真实IP的业务时，还需要添加关于真实IP的配置：&lt;/p&gt;
&lt;p&gt;server {
server_name &lt;a href=&quot;http://www.test.com/&quot;&gt;www.test.com&lt;/a&gt;
listen 80;&lt;/p&gt;
&lt;p&gt;location / {
proxy_pass &lt;a href=&quot;http://127.0.0.1:8080/&quot;&gt;http://127.0.0.1:8080&lt;/a&gt;;
proxy_set_header Host $host:80;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
}
}&lt;/p&gt;
&lt;p&gt;&lt;code&gt;proxy_set_header&lt;/code&gt;这句配置是改变http的请求头。而Host是请求的主机名，&lt;code&gt;X-Real-IP&lt;/code&gt;是请求的真实IP，&lt;code&gt;X-Forwarded-For&lt;/code&gt;表示请求是由谁发起的。&lt;/p&gt;
&lt;h2 id=&quot;%E5%B0%8F%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;这次的配置可能对大部分人来说都很简单，但是笔者刚接触Nginx配置这一块，因此记录下来，分享给有需要的人。如有建议和批评，欢迎指出。通过这次的学习发现，Nginx的配置是很值得学习的。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>【php爬虫】百万级别知乎用户数据爬取与分析</title>
    <link href="https://hoohack.me/blog/2015/2015-09-30-php-spider-millons-of-zhihu-user-analyze/"/>
    <updated>2015-09-30T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-09-30-php-spider-millons-of-zhihu-user-analyze/</id>
    <content type="html">&lt;p&gt;代码托管地址：&lt;a href=&quot;https://github.com/hoohackHu/zhihuSpider&quot;&gt;https://github.com/hoohackHu/zhihuSpider&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这次抓取了110万的用户数据，数据分析结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E7%9F%A5%E4%B9%8E%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%9B%BE.png&quot; alt=&quot;知乎数据统计图.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;##开发前的准备
安装Linux系统（Ubuntu14.04），在VMWare虚拟机下安装一个Ubuntu；&lt;/p&gt;
&lt;p&gt;安装PHP5.6或以上版本；&lt;/p&gt;
&lt;p&gt;安装MySQL5.5或以上版本；&lt;/p&gt;
&lt;p&gt;安装curl、pcntl扩展。&lt;/p&gt;
&lt;p&gt;##使用PHP的curl扩展抓取页面数据
PHP的curl扩展是PHP支持的允许你与各种服务器使用各种类型的协议进行连接和通信的库。&lt;/p&gt;
&lt;p&gt;本程序是抓取知乎的用户数据，要能访问用户个人页面，需要用户登录后的才能访问。当我们在浏览器的页面中点击一个用户头像链接进入用户个人中心页面的时候，之所以能够看到用户的信息，是因为在点击链接的时候，浏览器帮你将本地的cookie带上一齐提交到新的页面，所以你就能进入到用户的个人中心页面。因此实现访问个人页面之前需要先获得用户的cookie信息，然后在每次curl请求的时候带上cookie信息。在获取cookie信息方面，我是用了自己的cookie，在页面中可以看到自己的cookie信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E7%88%AC%E8%99%AB-%E6%9F%A5%E7%9C%8Bcookie.jpg&quot; alt=&quot;爬虫-查看cookie.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;一个个地复制，以&amp;quot;__utma=?;__utmb=?;&amp;quot;这样的形式组成一个cookie字符串。接下来就可以使用该cookie字符串来发送请求。&lt;/p&gt;
&lt;p&gt;初始的示例：&lt;/p&gt;
&lt;p&gt;$url = &#39;&lt;a href=&quot;http://www.zhihu.com/people/mora-hu/about&quot;&gt;http://www.zhihu.com/people/mora-hu/about&lt;/a&gt;&#39;; //此处mora-hu代表用户ID
$ch = curl_init($url); //初始化会话
curl_setopt($ch, CURLOPT_HEADER, 0);
curl_setopt($ch, CURLOPT_COOKIE, $this-&amp;gt;config_arr[&#39;user_cookie&#39;]);  //设置请求COOKIE
curl_setopt($ch, CURLOPT_USERAGENT, $_SERVER[&#39;HTTP_USER_AGENT&#39;]);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);  //将curl_exec()获取的信息以文件流的形式返回，而不是直接输出。
curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);&lt;br /&gt;
$result = curl_exec($ch);
return $result;  //抓取的结果&lt;/p&gt;
&lt;p&gt;运行上面的代码可以获得mora-hu用户的个人中心页面。利用该结果再使用正则表达式对页面进行处理，就能获取到姓名，性别等所需要抓取的信息。&lt;/p&gt;
&lt;p&gt;###图片防盗链
在对返回结果进行正则处理后输出个人信息的时候，发现在页面中输出用户头像时无法打开。经过查阅资料得知，是因为知乎对图片做了防盗链处理。解决方案就是请求图片的时候在请求头里伪造一个referer。&lt;/p&gt;
&lt;p&gt;在使用正则表达式获取到图片的链接之后，再发一次请求，这时候带上图片请求的来源，说明该请求来自知乎网站的转发。具体例子如下：&lt;/p&gt;
&lt;p&gt;function getImg($url, $u_id)
{
if (file_exists(&#39;./images/&#39; . $u_id . &amp;quot;.jpg&amp;quot;))
{
return &amp;quot;images/$u_id&amp;quot; . &#39;.jpg&#39;;
}
if (empty($url))
{
return &#39;&#39;;
}
$context_options = array(&lt;br /&gt;
&#39;http&#39; =&amp;gt;&lt;br /&gt;
array(
&#39;header&#39; =&amp;gt; &amp;quot;Referer:&lt;a href=&quot;http://www.zhihu.com/&quot;&gt;http://www.zhihu.com&lt;/a&gt;&amp;quot;//带上referer参数
　　)
　　);&lt;/p&gt;
&lt;p&gt;$context = stream_context_create($context_options);&lt;br /&gt;
$img = file_get_contents(&#39;http:&#39; . $url, FALSE, $context);
file_put_contents(&#39;./images/&#39; . $u_id . &amp;quot;.jpg&amp;quot;, $img);
return &amp;quot;images/$u_id&amp;quot; . &#39;.jpg&#39;;
}&lt;/p&gt;
&lt;p&gt;###爬取更多用户
抓取了自己的个人信息后，就需要再访问用户的关注者和关注了的用户列表获取更多的用户信息。然后一层一层地访问。可以看到，在个人中心页面里，有两个链接如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E7%88%AC%E8%99%AB-%E6%9F%A5%E7%9C%8B%E9%93%BE%E6%8E%A5.jpg&quot; alt=&quot;爬虫-查看链接.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里有两个链接，一个是关注了，另一个是关注者，以“关注了”的链接为例。用正则匹配去匹配到相应的链接，得到url之后用curl带上cookie再发一次请求。抓取到用户关注了的用于列表页之后，可以得到下面的页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E7%88%AC%E8%99%AB-%E6%9F%A5%E7%9C%8B%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF.jpg&quot; alt=&quot;爬虫-查看用户信息.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;分析页面的html结构，因为只要得到用户的信息，所以只需要框住的这一块的div内容，用户名都在这里面。可以看到，用户关注了的页面的url是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E7%88%AC%E8%99%AB-%E6%9F%A5%E7%9C%8B%E9%A1%B5%E9%9D%A2%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80.jpg&quot; alt=&quot;爬虫-查看页面链接地址.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;不同的用户的这个url几乎是一样的，不同的地方就在于用户名那里。用正则匹配拿到用户名列表，一个一个地拼url，然后再逐个发请求（当然，一个一个是比较慢的，下面有解决方案，这个稍后会说到）。进入到新用户的页面之后，再重复上面的步骤，就这样不断循环，直到达到你所要的数据量。&lt;/p&gt;
&lt;p&gt;###Linux统计文件数量
脚本跑了一段时间后，需要看看究竟获取了多少图片，当数据量比较大的时候，打开文件夹查看图片数量就有点慢。脚本是在Linux环境下运行的，因此可以使用Linux的命令来统计文件数量：&lt;/p&gt;
&lt;p&gt;ls -l | grep &amp;quot;^-&amp;quot; | wc -l&lt;/p&gt;
&lt;p&gt;其中， &lt;code&gt;ls -l&lt;/code&gt; 是长列表输出该目录下的文件信息（这里的文件可以是目录、链接、设备文件等）； &lt;code&gt;grep &amp;quot;^-&amp;quot;&lt;/code&gt; 过滤长列表输出信息， &lt;code&gt;&amp;quot;^-&amp;quot;&lt;/code&gt;  只保留一般文件，如果只保留目录是 &lt;code&gt;&amp;quot;^d&amp;quot;&lt;/code&gt; ； &lt;code&gt;wc -l&lt;/code&gt; 是统计输出信息的行数。下面是一个运行示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E7%88%AC%E8%99%AB-%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E6%95%B0%E9%87%8F.png&quot; alt=&quot;爬虫-统计文件数量.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;###插入MySQL时重复数据的处理
程序运行了一段时间后，发现有很多用户的数据是重复的，因此需要在插入重复用户数据的时候做处理。处理方案如下：&lt;/p&gt;
&lt;p&gt;1）插入数据库之前检查数据是否已经存在数据库；&lt;/p&gt;
&lt;p&gt;2）添加唯一索引，插入时使用 &lt;code&gt;INSERT INTO ... ON DUPLICATE KEY UPDATE... &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3）添加唯一索引，插入时使用 &lt;code&gt;INSERT INGNORE INTO...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4）添加唯一索引，插入时使用 &lt;code&gt;REPLACE INTO...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第一种方案是最简单但也是效率最差的方案，因此不采取。二和四方案的执行结果是一样的，不同的是，在遇到相同的数据时， &lt;code&gt;INSERT INTO ... ON DUPLICATE KEY UPDATE&lt;/code&gt; 是直接更新的，而  &lt;code&gt;REPLACE INTO&lt;/code&gt;  是先删除旧的数据然后插入新的，在这个过程中，还需要重新维护索引，所以速度慢。所以在二和四两者间选择了第二种方案。而第三种方案，  &lt;code&gt;INSERT INGNORE&lt;/code&gt;  会忽略执行INSERT语句出现的错误，不会忽略语法问题，但是忽略主键存在的情况。这样一来，使用  &lt;code&gt;INSERT INGNORE&lt;/code&gt;  就更好了。最终，考虑到要在数据库中记录重复数据的条数，因此在程序中采用了第二种方案。&lt;/p&gt;
&lt;p&gt;##使用curl_multi实现多线程抓取页面
刚开始单进程而且单个curl去抓取数据，速度很慢，挂机爬了一个晚上只能抓到2W的数据，于是便想到能不能在进入新的用户页面发curl请求的时候一次性请求多个用户，后来发现了curl_multi这个好东西。curl_multi这类函数可以实现同时请求多个url，而不是一个个请求，这类似于linux系统中一个进程开多条线程执行的功能。下面是使用curl_multi实现多线程爬虫的示例：&lt;/p&gt;
&lt;p&gt;$mh = curl_multi_init(); //返回一个新cURL批处理句柄
for ($i = 0; $i &amp;lt; $max_size; $i++)
{
$ch = curl_init();  //初始化单个cURL会话
curl_setopt($ch, CURLOPT_HEADER, 0);
curl_setopt($ch, CURLOPT_URL, &#39;&lt;a href=&quot;http://www.zhihu.com/people/&quot;&gt;http://www.zhihu.com/people/&lt;/a&gt;&#39; . $user_list[$i] . &#39;/about&#39;);
curl_setopt($ch, CURLOPT_COOKIE, self::$user_cookie);
curl_setopt($ch, CURLOPT_USERAGENT, &#39;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.130 Safari/537.36&#39;);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);
$requestMap[$i] = $ch;
curl_multi_add_handle($mh, $ch);  //向curl批处理会话中添加单独的curl句柄
}&lt;/p&gt;
&lt;p&gt;$user_arr = array();
do {
//运行当前 cURL 句柄的子连接
while (($cme = curl_multi_exec($mh, $active)) == CURLM_CALL_MULTI_PERFORM);&lt;/p&gt;
&lt;p&gt;if ($cme != CURLM_OK) {break;}
//获取当前解析的cURL的相关传输信息
while ($done = curl_multi_info_read($mh))
{
$info = curl_getinfo($done[&#39;handle&#39;]);
$tmp_result = curl_multi_getcontent($done[&#39;handle&#39;]);
$error = curl_error($done[&#39;handle&#39;]);&lt;/p&gt;
&lt;p&gt;$user_arr[] = array_values(getUserInfo($tmp_result));&lt;/p&gt;
&lt;p&gt;//保证同时有$max_size个请求在处理
if ($i &amp;lt; sizeof($user_list) &amp;amp;&amp;amp; isset($user_list[$i]) &amp;amp;&amp;amp; $i &amp;lt; count($user_list))
{
$ch = curl_init();
curl_setopt($ch, CURLOPT_HEADER, 0);
curl_setopt($ch, CURLOPT_URL, &#39;&lt;a href=&quot;http://www.zhihu.com/people/&quot;&gt;http://www.zhihu.com/people/&lt;/a&gt;&#39; . $user_list[$i] . &#39;/about&#39;);
curl_setopt($ch, CURLOPT_COOKIE, self::$user_cookie);
curl_setopt($ch, CURLOPT_USERAGENT, &#39;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.130 Safari/537.36&#39;);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);
$requestMap[$i] = $ch;
curl_multi_add_handle($mh, $ch);&lt;/p&gt;
&lt;p&gt;$i++;
}&lt;/p&gt;
&lt;p&gt;curl_multi_remove_handle($mh, $done[&#39;handle&#39;]);
}&lt;/p&gt;
&lt;p&gt;if ($active)
curl_multi_select($mh, 10);
} while ($active);&lt;/p&gt;
&lt;p&gt;curl_multi_close($mh);
return $user_arr;&lt;/p&gt;
&lt;p&gt;###HTTP 429 Too Many Requests
使用curl_multi函数可以同时发多个请求，但是在执行过程中使同时发200个请求的时候，发现很多请求无法返回了，即发现了丢包的情况。进一步分析，使用 curl_getinfo 函数打印每个请求句柄信息，该函数返回一个包含HTTP response信息的关联数组，其中有一个字段是http_code，表示请求返回的HTTP状态码。看到有很多个请求的http_code都是429，这个返回码的意思是发送太多请求了。我猜是知乎做了防爬虫的防护，于是我就拿其他的网站来做测试，发现一次性发200个请求时没问题的，证明了我的猜测，知乎在这方面做了防护，即一次性的请求数量是有限制的。于是我不断地减少请求数量，发现在5的时候就没有丢包情况了。说明在这个程序里一次性最多只能发5个请求，虽然不多，但这也是一次小提升了。&lt;/p&gt;
&lt;p&gt;###使用Redis保存已经访问过的用户
抓取用户的过程中，发现有些用户是已经访问过的，而且他的关注者和关注了的用户都已经获取过了，虽然在数据库的层面做了重复数据的处理，但是程序还是会使用curl发请求，这样重复的发送请求就有很多重复的网络开销。还有一个就是待抓取的用户需要暂时保存在一个地方以便下一次执行，刚开始是放到数组里面，后来发现要在程序里添加多进程，在多进程编程里，子进程会共享程序代码、函数库，但是进程使用的变量与其他进程所使用的截然不同。不同进程之间的变量是分离的，不能被其他进程读取，所以是不能使用数组的。因此就想到了使用Redis缓存来保存已经处理好的用户以及待抓取的用户。这样每次执行完的时候都把用户push到一个already_request_queue队列中，把待抓取的用户（即每个用户的关注者和关注了的用户列表）push到request_queue里面，然后每次执行前都从request_queue里pop一个用户，然后判断是否在already_request_queue里面，如果在，则进行下一个，否则就继续执行。&lt;/p&gt;
&lt;p&gt;在PHP中使用redis示例：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$redis = new Redis();
$redis-&amp;gt;connect(&#39;127.0.0.1&#39;, &#39;6379&#39;);
$redis-&amp;gt;set(&#39;tmp&#39;, &#39;value&#39;);
if ($redis-&amp;gt;exists(&#39;tmp&#39;))
{
echo $redis-&amp;gt;get(&#39;tmp&#39;) . &amp;quot;&#92;n&amp;quot;;
}&lt;/p&gt;
&lt;p&gt;##使用PHP的pcntl扩展实现多进程
改用了curl_multi函数实现多线程抓取用户信息之后，程序运行了一个晚上，最终得到的数据有10W。还不能达到自己的理想目标，于是便继续优化，后来发现php里面有一个pcntl扩展可以实现多进程编程。下面是多编程编程的示例：&lt;/p&gt;
&lt;p&gt;//PHP多进程demo
//fork10个进程
for ($i = 0; $i &amp;lt; 10; $i++) {
$pid = pcntl_fork();
if ($pid == -1) {
echo &amp;quot;Could not fork!&#92;n&amp;quot;;
exit(1);
}
if (!$pid) {
echo &amp;quot;child process $i running&#92;n&amp;quot;;
//子进程执行完毕之后就退出，以免继续fork出新的子进程
exit($i);
}
}&lt;/p&gt;
&lt;p&gt;//等待子进程执行完毕，避免出现僵尸进程
while (pcntl_waitpid(0, $status) != -1) {
$status = pcntl_wexitstatus($status);
echo &amp;quot;Child $status completed&#92;n&amp;quot;;
}&lt;/p&gt;
&lt;p&gt;###在Linux下查看系统的cpu信息
实现了多进程编程之后，就想着多开几条进程不断地抓取用户的数据，后来开了8调进程跑了一个晚上后发现只能拿到20W的数据，没有多大的提升。于是查阅资料发现，根据系统优化的CPU性能调优，程序的最大进程数不能随便给的，要根据CPU的核数和来给，最大进程数最好是cpu核数的2倍。因此需要查看cpu的信息来看看cpu的核数。在Linux下查看cpu的信息的命令：&lt;/p&gt;
&lt;p&gt;cat /proc/cpuinfo&lt;/p&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/%E7%88%AC%E8%99%AB-%E6%9F%A5%E7%9C%8Bcpu%E4%BF%A1%E6%81%AF.png&quot; alt=&quot;爬虫-查看cpu信息.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中，model name表示cpu类型信息，cpu cores表示cpu核数。这里的核数是1，因为是在虚拟机下运行，分配到的cpu核数比较少，因此只能开2条进程。最终的结果是，用了一个周末就抓取了110万的用户数据。&lt;/p&gt;
&lt;p&gt;###多进程编程中Redis和MySQL连接问题
在多进程条件下，程序运行了一段时间后，发现数据不能插入到数据库，会报mysql too many connections的错误，redis也是如此。&lt;/p&gt;
&lt;p&gt;下面这段代码会执行失败：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
for ($i = 0; $i &amp;lt; 10; $i++) {
$pid = pcntl_fork();
if ($pid == -1) {
echo &amp;quot;Could not fork!&#92;n&amp;quot;;
exit(1);
}
if (!$pid) {
$redis = PRedis::getInstance();
// do something&lt;br /&gt;
exit;
}
}&lt;/p&gt;
&lt;p&gt;根本原因是在各个子进程创建时，就已经继承了父进程一份完全一样的拷贝。对象可以拷贝，但是已创建的连接不能被拷贝成多个，由此产生的结果，就是各个进程都使用同一个redis连接，各干各的事，最终产生莫名其妙的冲突。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;程序不能完全保证在fork进程之前，父进程不会创建redis连接实例。因此，要解决这个问题只能靠子进程本身了。试想一下，如果在子进程中获取的实例只与当前进程相关，那么这个问题就不存在了。于是解决方案就是稍微改造一下redis类实例化的静态方式，与当前进程ID绑定起来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;改造后的代码如下：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
public static function getInstance() {
static $instances = array();
$key = getmypid();//获取当前进程ID
if ($empty($instances[$key])) {
$inctances[$key] = new self();
}&lt;/p&gt;
&lt;p&gt;return $instances[$key];
}&lt;/p&gt;
&lt;p&gt;###PHP统计脚本执行时间
因为想知道每个进程花费的时间是多少，因此写个函数统计脚本执行时间：&lt;/p&gt;
&lt;p&gt;function microtime_float()
{
list($u_sec, $sec) = explode(&#39; &#39;, microtime());
return (floatval($u_sec) + floatval($sec));
}&lt;/p&gt;
&lt;p&gt;$start_time = microtime_float();&lt;/p&gt;
&lt;p&gt;//do something
usleep(100);&lt;/p&gt;
&lt;p&gt;$end_time = microtime_float();
$total_time = $end_time - $start_time;&lt;/p&gt;
&lt;p&gt;$time_cost = sprintf(&amp;quot;%.10f&amp;quot;, $total_time);&lt;/p&gt;
&lt;p&gt;echo &amp;quot;program cost total &amp;quot; . $time_cost . &amp;quot;s&#92;n&amp;quot;;&lt;/p&gt;
&lt;p&gt;若文中有不正确的地方，望各位指出以便改正。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>在MySQL的InnoDB存储引擎中count(*)函数的优化</title>
    <link href="https://hoohack.me/blog/2015/2015-09-28-optimize-count-function-in-innodb/"/>
    <updated>2015-09-28T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-09-28-optimize-count-function-in-innodb/</id>
    <content type="html">&lt;p&gt;写这篇文章之前已经看过了很多数据库方面的优化内容，大部分都是加索引、使用事务、要什么select什么等等。然而，只是停留在阅读的层面上，很少有实践，因为没有遇到真实的项目，一切都是纸上谈兵。实践是检验真理的唯一标准，于是就想在数据库上测试一些性能优化的方案，比如索引之类的，但是不想使用假的数据，于是就想着能不能抓取网上的一些数据来作分析，后来自己通过PHP抓取了一些数据，抓了大约110W的用户数据之后，当然需要统计一下具体的数量，于是我使用了以下的SQL语句（我使用的存储引擎是InnoDB）：&lt;/p&gt;
&lt;p&gt;SELECT COUNT(*) FROM zh_user;&lt;/p&gt;
&lt;p&gt;然而，发现需要运行14-20s的时间才能看到结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/count%E4%BC%98%E5%8C%961.png&quot; alt=&quot;select语句&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这样的时间开销在真实的环境的用户体验是十分差的，试想一下，打开一个页面还要等接近20s才能看到数据，别说20s，就算是3s也是十分差的，于是便想在这方面做优化。&lt;/p&gt;
&lt;p&gt;##存储引擎&lt;/p&gt;
&lt;p&gt;在MySQL中，日常开发中比较常用的有MyISAM和InnoDB两种存储引擎。两者之间的其中一个区别是使用count(*)函数计算表的具体行数。&lt;/p&gt;
&lt;p&gt;因为MyISAM会保存表的具体行数，因此这段代码在MyISAM存储引擎中执行，MyISAM只要简单地读出保存好的行数即可。因此，如果表中没有使用事务之类的操作，这是最好的优化方案。然而，InnoDB存储引擎不会保存表的具体行数，因此，在InnoDB存储引擎中执行这段代码，InnoDB要扫描一遍整个表来计算有多少行。&lt;/p&gt;
&lt;p&gt;##查询优化命令--Explain&lt;/p&gt;
&lt;p&gt;要弄懂查询性能在哪，首先，需要知道导致查询缓慢的瓶颈在哪。explain命令显示的rows是核心的性能指标，rows大，说明mysql需要扫描的行数就多，绝大部分rows大的语句执行一定很快。所以优化语句基本上都是在优化rows。&lt;/p&gt;
&lt;p&gt;首先，看看表的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/count%E4%BC%98%E5%8C%962.png&quot; alt=&quot;添加索引前的user表.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;表的当前索引：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/count%E4%BC%98%E5%8C%963.png&quot; alt=&quot;添加索引前的index结构.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;再看看Explain的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/count%E4%BC%98%E5%8C%964.png&quot; alt=&quot;explain结果&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到，mysql扫描了整个表来执行本次查询。&lt;/p&gt;
&lt;p&gt;##奇怪的地方&lt;/p&gt;
&lt;p&gt;在数据表的设计中，我是添加了唯一索引的，但是后来有一个语句是根据其中一个字段统计数量，当时添加了一个普通的索引，当我再执行了一遍上面的SQL语句，发现只需要0.2-0.3s的时间就能统计出表中的行数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/count%E4%BC%98%E5%8C%965.png&quot; alt=&quot;图片描述&quot; /&gt;&lt;/p&gt;
&lt;p&gt;不禁吓了一跳，误打误撞就发现了优化的方法：在InnoDB中，除了唯一索引之外，在其他字段添加一个普通索引（称为辅助索引）就能够提升count(*)函数的性能。但是这是为什么呢？
加了索引之后的表结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/count%E4%BC%98%E5%8C%966.png&quot; alt=&quot;添加索引后的user表.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;当前的索引：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/count%E4%BC%98%E5%8C%967.png&quot; alt=&quot;添加索引后的index结构.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Explain一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/count%E4%BC%98%E5%8C%968.png&quot; alt=&quot;图片描述&quot; /&gt;&lt;/p&gt;
&lt;p&gt;同样是扫描一样的行数，为什么添加一个普通索引就可以提高这么多的性能？于是便开始查找资料和阅读文档弄懂这个问题。&lt;/p&gt;
&lt;p&gt;##count(*)函数执行原理&lt;/p&gt;
&lt;p&gt;正如在不同的存储引擎中，count(&lt;em&gt;)函数的执行是不同的。在MyISAM存储引擎中，count(&lt;/em&gt;)函数是直接读取数据表保存的行记录数并返回，而在InnoDB存储引擎中，count(*)函数是先从内存中读取表中的数据到内存缓冲区，然后扫描全表获得行记录数的。在使用count函数中加上where条件时，在两个存储引擎中的效果是一样的，都会扫描全表计算某字段有值项的次数。&lt;/p&gt;
&lt;p&gt;##索引原理&lt;/p&gt;
&lt;p&gt;因为是添加了索引之后才得到性能上的提升，于是便想到从索引的角度来探索。&lt;/p&gt;
&lt;p&gt;根据官方文档上的定义：索引是帮助MySQL高效获取数据的数据结构。可以得知，索引的本质就是数据结构，添加索引的目的就是为了提高查询的效率。&lt;/p&gt;
&lt;p&gt;使用索引的查询可以类比到字典，如果要查”mysql“这个单词，我们首先会定位到m字母，然后在m字母下面的单词中找y字母，以此类推，直到找到mysql这个单词，就能看到它在第几页，然后就去该页获取该单词更多的信息。想象一下，如果没有索引，那你就要在字典里一页一页的翻阅，效率十分低下。使用索引就是通过这样不断地缩小查询的范围来筛选出最终的结果。&lt;/p&gt;
&lt;p&gt;那么在数据库也是一样的，但显然在数据库里使用索引要复杂许多。&lt;/p&gt;
&lt;p&gt;##磁盘存取与预读&lt;/p&gt;
&lt;p&gt;一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。那么数据库在构建索引的时候就需要先从磁盘读取数据了，此时就要产生磁盘I/O消耗。而每次的数据读取，都要经历寻道时间、旋转延迟、传输时间三个部分。寻道时间是指磁臂移动到指定磁道所需要的时间，一般在5ms以内；旋转延迟就是磁盘转速；传输时间指的是将数据从磁盘读出并写入到内存的时间，这个时间较短，可以忽略不计。相对于内存存取，I/O存取的消耗要高几个数量级。因此，评价一个数据结构作为索引的优劣最重要的指标就是查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。&lt;/p&gt;
&lt;p&gt;从上面的描述可以得知磁盘I/O是非常高昂的操作，根据操作系统的局部性原理：
当一个数据被用到时，其附近的数据也通常会马上被使用。&lt;/p&gt;
&lt;p&gt;计算机操作系统在这方面做了一些优化，当一次I/O时，不光把当前磁盘地址的数据读取到内存缓冲区内，而且把相邻的数据也都读取到内存缓冲区内。这样一来，在读取数据时产生的I/O就少了很多了。因为在数据库中，每一次I/O读取的数据我们称之为一页(page)，一般为4k或8k，也就是说，我们读取一页内的数据时，实际上才发生了一次I/O。&lt;/p&gt;
&lt;p&gt;根据以上的描述，我们可以初步得出结论，增加索引前后的性能差距体现在磁盘读取过程。但是在添加新的索引之前，我是添加了一个唯一索引的，后来发现在mysql中，我添加的唯一索引被称为聚簇索引，而后面添加的索引称为辅助索引，因此，让我们再来看看聚簇索引和辅助索引的区别。&lt;/p&gt;
&lt;p&gt;##聚簇索引(clustered index)和辅助索引(secondary index)&lt;/p&gt;
&lt;p&gt;###聚簇索引(clustered index)&lt;/p&gt;
&lt;p&gt;每一个InnoDB存储引擎下的表都有一个特殊的索引用来保存每一行的数据，称为聚簇索引。通常情况下，聚簇索引是主键的同义词。在InnoDB中，mysql是这样选择聚簇索引的：&lt;/p&gt;
&lt;p&gt;如果表中定义了PRIMARY KEY，那么InnoDB就会使用它作为聚簇索引；&lt;/p&gt;
&lt;p&gt;否则，如果没有定义PRIMARY KEY，InnoDB会选择第一个有NOT NULL约束的唯一索引作为PRIMARY KEY，然后InnoDB会使用它作为聚簇索引；&lt;/p&gt;
&lt;p&gt;如果表中没有定义PRIMARY KEY或者合适的唯一索引。InnoDB会在一个合成的列中自动生成一个包含行ID的隐含的聚簇索引。这些行使用InnoDB赋予这些表的ID进行排序。行ID是6个字节的字段，且作为新行单一地自增。因此，根据行ID排序的行数据在物理上是根据插入的顺序进行排序。&lt;/p&gt;
&lt;p&gt;###聚簇索引如何加速查询&lt;/p&gt;
&lt;p&gt;因为所有的行数据都跟聚簇索引存放在同一个地方，因此，通过聚簇索引访问数据行会更快。如果表十分大，跟使用不同地方保存数据和索引的存储组织来说，聚簇索引的结构会节省很多的I/O操作。（比如说，MyISAM使用了一个文件来保存数据以及另一个文件保存索引记录）。&lt;/p&gt;
&lt;p&gt;###辅助索引(secondary index)&lt;/p&gt;
&lt;p&gt;除了聚簇索引之外的所有索引都被称为辅助索引。在InnoDB里，辅助索引的每一行记录都包含每一行的主键列，辅助索引指向主键。InnoDB使用这个主键来查找在聚簇索引中的行。如果主键很长，辅助索引会使用更多的空间，因此辅助索引有利于存储引擎拥有长度更短的主键。&lt;/p&gt;
&lt;p&gt;##结论&lt;/p&gt;
&lt;p&gt;在第一次使用了唯一索引(u_id)的时候，InnoDB使用了唯一索引作为表的聚簇索引。而在InnoDB存储引擎中，count(*)函数是先从内存中读取表中的数据到内存缓冲区，然后扫描全表获得行记录数的。因此，使用唯一索引作为聚簇索引的时候，InnoDB需要先读取110W条的数据到数据缓冲区中，这里发生了很多次I/O，因此造成了主要的时间消耗。而添加了辅助索引后，mysql在执行查询时会使用内部的优化机制：即使用辅助索引来统计数量。辅助索引保存的是index的值，此时只需要读取一个字段，I/O减少了，性能就提高了。因此在InnoDB中，如果有统计整张表的数量的需求，可以考虑增加一个辅助索引。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>在PHP中获取脚本执行时间</title>
    <link href="https://hoohack.me/blog/2015/2015-09-16-get-excute-time-in-php/"/>
    <updated>2015-09-16T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-09-16-get-excute-time-in-php/</id>
    <content type="html">&lt;p&gt;首先介绍一个PHP的函数&lt;code&gt;microtime()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;##microtime函数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mixed microtime([ bool $get_as_float = false ])&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个函数返回当前的UNIX时间戳和毫秒数。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;$get_as_float&lt;/code&gt;被设置为TRUE，那么microtime()会返回float类型的值，否则返回string类型的值。&lt;/p&gt;
&lt;p&gt;获取脚本执行时间思路：在脚本开始时使用microtime获取一次时间，在脚本结束时获取再获取一次时间。在获取完时间后需要对结果进行处理，因为该函数返回的字符串使用空格将时间戳和微妙数分割开，所以使用空格分隔字符串，然后将两部分加起来组成一个float类型的值。然后用结束时间减去开始时间就得到脚本执行的时间值。最终要使用什么格式输出看自己的需求选择。&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
function microtime_float()
{
list($u_sec, $sec) = explode(&#39; &#39;, microtime());
return (floatval($u_sec) + floatval($sec));
}&lt;/p&gt;
&lt;p&gt;$start_time = microtime_float();&lt;/p&gt;
&lt;p&gt;//do something
usleep(100);&lt;/p&gt;
&lt;p&gt;$end_time = microtime_float();
$total_time = $end_time - $start_time;&lt;/p&gt;
&lt;p&gt;$time_cost = sprintf(&amp;quot;%.10f&amp;quot;, $total_time);&lt;/p&gt;
&lt;p&gt;echo &amp;quot;program cost total &amp;quot; . $time_cost . &amp;quot;s&#92;n&amp;quot;;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>PHP是怎么运行的</title>
    <link href="https://hoohack.me/blog/2015/2015-09-02-how-php-excute/"/>
    <updated>2015-09-02T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-09-02-how-php-excute/</id>
    <content type="html">&lt;p&gt;这篇文章，研究一下PHP代码是如何解释和执行以及PHP脚本运行的生命周期。&lt;/p&gt;
&lt;p&gt;##概述
PHP服务的启动。严格来说，PHP的相关进程是不需要手动启动的，它是随着Apache的启动而运行的。当然，如果有需要重启PHP服务的情况下也是可以手动重启PHP服务的。比如说在有开启opcode的正式环境更新了代码之后，需要重启PHP以重新编译PHP代码。&lt;/p&gt;
&lt;p&gt;从宏观上来看，PHP内核的实现就是接收输入的数据，内部做相应的处理然后输出结果。对于PHP内核来说，我们编写的PHP代码就是内核接收的输入数据，PHP内核接收代码数据后，对我们编写的的代码进行代码解析和运算执行，最后返回相应的运算结果。&lt;/p&gt;
&lt;p&gt;然而，不同于平时的C语言代码，要执行PHP代码，首先需要将PHP代码“翻译”成机器语言来执行相应的功能。而要执行“翻译”这个步骤，就需要PHP内核进行：词法分析、语法分析等步骤。最后交给PHP内核的Zend Engine进行顺次的执行。&lt;/p&gt;
&lt;p&gt;###词法分析
将PHP代码分隔成一个个的“单元”（TOKEN）&lt;/p&gt;
&lt;p&gt;###语法分析
将“单元”转换为Zend Engine可执行的操作&lt;/p&gt;
&lt;p&gt;###Zend Engine执行
对语法分析得到的操作进行顺次的执行&lt;/p&gt;
&lt;p&gt;一切PHP程序（CGI/CLI）的开始都是从SAPI（Server Application Programming Interface）接口开始。SAPI指的是PHP具体应用的编程接口。例如Apache的mod_php。&lt;/p&gt;
&lt;p&gt;PHP开始执行以后会经过两个主要的阶段：处理请求之前的开始阶段和请求之后的结束阶段。&lt;/p&gt;
&lt;p&gt;##开始阶段
PHP的整一个开始阶段会经历模块初始化和模块激活两个阶段。&lt;/p&gt;
&lt;p&gt;###MINIT
即模块初始化阶段，发生在Apache/Nginx启动以后的整个生命周期或者命令行程序整个执行过程中，此阶段只进行一次&lt;/p&gt;
&lt;p&gt;###RINIT
模块激活，发生在请求阶段。做一些初始化工作：如注册常量、定义模块使用的类等等&lt;/p&gt;
&lt;p&gt;模块在实现时可以通过如下宏来实现这些回调函数：&lt;/p&gt;
&lt;p&gt;PHP_MINIT_FUNCTION(myphpextension)
{
//注册常量或者类等初始化操作
return SUCCESS;
}&lt;/p&gt;
&lt;p&gt;PHP_RINIT_FUNCTION(myphpextension)
{
//例如记录请求开始时间
//随后在请求结束的时候记录结束时间。这样我们就能够记录处理请求所花费时间了
return SUCCESS;
}&lt;/p&gt;
&lt;p&gt;PHP脚本请求处理完就进入了结束阶段，一般脚本执行到末尾或者调用exit或die函数，PHP就进入结束阶段。&lt;/p&gt;
&lt;p&gt;##结束阶段
PHP的结束阶段分为停用模块和关闭模块两个环节。&lt;/p&gt;
&lt;p&gt;###RSHUTDOWN
停用模块（对应RINIT）&lt;/p&gt;
&lt;p&gt;###MSHUTDOWN
关闭模块（对应MINIT）&lt;/p&gt;
&lt;p&gt;CLI/CGI模式的PHP属于单进程的SAPI模式。意思就是说，PHP脚本在执行一次之后就关闭掉，所有的变量和函数都不能继续使用。即在CGI模式下，同一个php文件的变量在其他php文件中不能使用。&lt;/p&gt;
&lt;p&gt;下面用一个例子看看单线程PHP的SAPI生命周期。&lt;/p&gt;
&lt;p&gt;##单线程SAPI生命周期
如：&lt;code&gt;php -f test.php&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;调用各个扩展的MINIT 模块初始化
请求test.php
调用各个扩展的RINIT 模块激活
执行test.php
调用各个扩展的RSHUTDOWN 停用模块
执行完test.php后清理变量和内存
调用各个扩展的MSHUTDOWN 关闭模块
停止PHP执行&lt;/p&gt;
&lt;p&gt;以上是一个简单的执行流程，下面做一些补充。&lt;/p&gt;
&lt;p&gt;PHP在调用每个模块的模块初始化前，会有一个初始化的过程，包括：&lt;/p&gt;
&lt;p&gt;###初始化若干全局变量
大多数情况下是将其设置为NULL。&lt;/p&gt;
&lt;p&gt;###初始化若干常量
这里的常量是PHP自身的一些常量。&lt;/p&gt;
&lt;p&gt;###初始化Zend引擎和核心组件
这里的初始化操作包括内存管理初始化、全局使用的函数指针初始化，对PHP源文件进行词法分析、语法分析、中间代码执行的函数指针的赋值，初始化若干HashTable（比如函数表，常量表等等），为ini文件解析做准备，为PHP源文件解析做准备，注册内置函数、标准常量、GLOBALS全局变量等&lt;/p&gt;
&lt;p&gt;###解析php.ini
读取php.ini文件，设置配置参数，加载zend扩展并注册PHP扩展函数。&lt;/p&gt;
&lt;p&gt;###全局操作函数的初始化
初始化在用户空间所使用频率很高的一些全局变量，如：$_GET、$_POST、$_FILES 等。&lt;/p&gt;
&lt;p&gt;###初始化静态构建的模块和共享模块(MINIT)
初始化默认加载的模块。
模块初始化执行操作：
将模块注册到已注册模块列表
将每个模块中包含的函数注册到函数表&lt;/p&gt;
&lt;p&gt;###禁用函数和类
会调用zend_disable_function函数将PHP的配置文件中的disable_functions变量代表的函数从CG(function_table)函数表中删除。&lt;/p&gt;
&lt;p&gt;###激活Zend引擎
使用init_compiler函数来初始化编译器。&lt;/p&gt;
&lt;p&gt;###激活SAPI
使用sapi_activate函数来初始化SG(sapi_headers)和SG(request_info)，并且针对HTTP请求的方法设置一些内容。&lt;/p&gt;
&lt;p&gt;###环境初始化
初始化在用户控件需要用到的一些环境变量。包括服务器环境、请求数据环境等。&lt;/p&gt;
&lt;p&gt;###模块请求初始化
PHP调用zend_activate_modules函数遍历注册在module_registry变量中的所有模块，调用其RINIT方法方法实现模块的请求初始化操作。&lt;/p&gt;
&lt;p&gt;在处理了文件相关的内容后，PHP会调用php_request_startup做请求初始化操作：&lt;/p&gt;
&lt;p&gt;激活Zend引擎
激活SAPI
环境初始化
模块请求初始化&lt;/p&gt;
&lt;p&gt;##代码的运行
以上所有准备工作完成后，就开始执行PHP程序。PHP通过zend_compile_file做词法分析、语法分析和中间代码生成操作，返回此文件的所有中间代码。如果解析的文件有生成有效的中间代码，则调用zend_excute执行中间代码。。如果在执行过程中出现异常并且用户有定义对这些异常的处理，则调用这些异常处理函数。在所有的操作都处理完后，PHP通过EG(return_value_ptr_ptr)返回结果。&lt;/p&gt;
&lt;p&gt;##DEACTIVATION(关闭请求)
PHP关闭请求的过程是一个若干个关闭操作的集合，这个集合存在于php_request_shutdown函数中。这个包括：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;调用所有通过register_shutdown_function()注册的函数。这些在关闭时调用的函数是在用户空间添加进来的。&lt;/li&gt;
&lt;li&gt;执行所有可用的__destruct函数。这里的析构函数包括在对象池（EG(objects_store）中的所有对象的析构函数以及EG(symbol_table)中各个元素的析构方法。&lt;/li&gt;
&lt;li&gt;将所有的输出刷出去。&lt;/li&gt;
&lt;li&gt;发送HTTP应答头。&lt;/li&gt;
&lt;li&gt;销毁全局变量表（PG(http_globals)）的变量。&lt;/li&gt;
&lt;li&gt;通过zend_deactivate函数，关闭词法分析器、语法分析器和中间代码执行器。&lt;/li&gt;
&lt;li&gt;调用每个扩展的post-RSHUTDOWN函数。只是基本每个扩展的post_deactivate_func函数指针都是NULL。
关闭SAPI，通过sapi_deactivate销毁SG(sapi_headers)、SG(request_info)等的内容。&lt;/li&gt;
&lt;li&gt;关闭流的包装器、关闭流的过滤器。&lt;/li&gt;
&lt;li&gt;关闭内存管理。&lt;/li&gt;
&lt;li&gt;重新设置最大执行时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;##结束
PHP结束一个进程是，会调用sapi_flush函数将最后的内容刷新出去。然后调用zend_shutdown函数关闭Zend引擎。&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://www.php-internals.com/book/&quot;&gt;http://www.php-internals.com/book/&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>读书笔记--PHP安全编程</title>
    <link href="https://hoohack.me/blog/2015/2015-08-21-php-secure-program/"/>
    <updated>2015-08-21T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-08-21-php-secure-program/</id>
    <content type="html">&lt;p&gt;##register_globals的安全性
本特性已自php5.3.0起废弃并自PHP5.4.0起移除，故不作研究。&lt;/p&gt;
&lt;p&gt;##不要让不相关的人看到报错信息&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只要关闭display_errors就可以做到，如果你希望得到出错信息，可以打开log_errors选项，并在error_log选项中设置出错日志文件的保存路径。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;所有的出错报告级别可以在任意级别进行修改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;PHP允许通过set_error_handler()函数指定自己的出错处理函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##网站安全设计的一些原则&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;深度防范：冗余安全措施&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最小权限：只能给予每个人完成他本职工作所必须的尽量少的权限。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;简单就是美：没有必要的复杂与没有必要的风险一样糟糕。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;暴露最小化：数据暴露必须尽量最小化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##可用性与数据跟踪&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;平衡风险与可用性：用户操作的友好性与安全措施是一对矛盾，在提高安全性的同时，通常会降低可用性。尽量是安全措施对用户透明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;跟踪数据：不只是要知道它是什么和它在哪里，还要知道它从哪里来，要到哪里去。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##过滤用户输入&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;过滤输入的步骤：识别输入；过滤输入；区分已过滤及被污染数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;输入是指所有源自外部的数据。一般来说，把session保存位置与数据库看成是输入是更为安全的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;过滤是防止非法数据进入你的应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最好的过滤方法是把过滤看成一个检查的过程。请不要试图好心地去纠正非法数据，要让你的用户按你的规则去做，历史证明了试图纠正非法数据往往会导致安全漏洞。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;使用一个命名约定或其他可以帮助你正确和可靠地区分已过滤和被污染数据的方法。如：$clean&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;经常初始化$clean为一个空数组&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;加入检查及阻止来自外部数据源的变量命名为clean。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##对输出要进行转义&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对输出进行转义或对特殊字符进行编码，以保证原意不变。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;输出转义三步：识别输出；输出转义；区分已转义与未转义数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;只对已过滤数据进行转义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;对一些常见的输出目标（包括客户端、数据库和URL）的转义，PHP中有内置函数可用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;使用htmlentities()在数据发出前进行转义是最好的方法。使用此函数的最佳方式是指定它的两个可选参数：引号的转义方式及字符集。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;使用一个命名参数保存转义数据：$html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;对于mysql用户，最好的转义函数时mysql_real_escape_string()，如果你使用的数据库没有PHP内建转义函数可用的话，addslashed()是最后的选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##表单与数据安全&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数据分类：已过滤数据；被污染数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;所有你自己设定的可信数据，可以认为是已过滤数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;任何来自远程数据源的数据都是输入，而所有的输入数据都是被污染的，必须在要在使用前对其进行过滤。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##从URL的语义进行攻击&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例子：找回密码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;漏洞：在URL中暴露用户名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;解决方法：使用session跟踪正确回答问题的用户&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##文件上传攻击的防御&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上传文件参数数组$_FILES是一个超级全局数组，里面的内容tmp_name,error及size是PHP所提供的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;需要对这些参数进行检查。如tmp_name使用is_uploaded_file()函数判断是否为一个上传的文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;如果希望只把上传的文件移到一个固定位置，可以使用move_uploaded_file()
可以用filesize()函数来校验文件的大小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最佳的方法是永远尽可能少地去信任。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##跨站脚本攻击的防御
输入和输出要做过滤和转义 htmlentities&lt;/p&gt;
&lt;p&gt;##跨站请求伪造CSRF的防御
CSRF(Cross-Site Request Forgery)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CSRF攻击：攻击者盗用了你的身份，以你的名义发送而已请求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;只允许GET请求检索数据，但是不允许它修改服务器上的任何数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;防御：在客户端页面增加伪随机数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所有表单包含同一个伪随机数
验证码图片
所有表单包含不同的伪随机数&lt;/p&gt;
&lt;p&gt;##表单欺骗提交&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;攻击者可以通过查看网页源代码来获取表单中的action查看POST的目的地，进而推断出POST的绝对地址。然后再伪造一个表单，并取消各种限制进行攻击。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这种攻击是不能防止的。但只要做好数据的过滤，用户就必须遵守你的规则，与攻击者如何提交无关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##HTTP请求欺骗
即伪造一个HTTP请求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;欺骗HTTP请求的做法并不多，对它不应该过多关注。但这个现象的出现再次强调了过滤输入的重要性和HTTP请求提供的任何信息都是不可信的这个事实。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##不要暴露数据库访问权限&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;把数据库配置文件放在网站根目录以外的目录下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;或者把配置文件后缀改为.php&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##防止SQL注入&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;过滤输入，转义输出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;转义发送给数据库的数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;使用占位符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##cookie暴露导致session被劫持&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用cookie而产生的一个风险是用户的cookie会被攻击者所盗窃。如果会话标识保存在cookie中，cookie的暴露就是一个严重的风险，因为它能导致会话劫持。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##session劫持的防御&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用SSL&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;验证User-Agent&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##防止源代码的暴露&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;把所有包含文件放在网站主目录之外&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;修改apache/nginx文件，把配置文件当做php文件一样处理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##留心后门URL&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;后门URL是指虽然无需直接调用的资源能直接通过URL访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;为了防止后门URL，需要确认所有包含文件保存在网站主目录以外。所有保存在网站主目录下的文件都是必须要通过URL直接访问的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##阻止文件名被操纵&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用动态包含时目录名或文件名中的部分会保存在一个变量中。比如放在$_GET。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;防止的方案：在动态包含时永远不要使用被污染数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##文件包含的代码注入攻击&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果引入的外部文件中包含可执行代码（如PHP代码）的话，就会被程序解析，造成攻击。
解决方法：在include和require语句前对数据进行过滤。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##文件目录猜测漏洞&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;防御方案：
让使用者遵从你制定的规则。（如：文件名只包含字母）
basename函数在检查是否有不必要的路径时非常有用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##打开远程文件的风险&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;永远不要用被污染的数据去执行一个文件名。坚持过滤输入，同时确信在数据指向另一个文件名之前被过滤即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##shell命令注入&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可能的话，避免使用shell命令。实在要用的话，确保对构造命令串的数据进行过滤，同时必须要对输出进行转义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##暴力破解攻击&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;暴力攻击是一种不使用任何特殊手段而去穷举各种可能性的攻击方式。即穷举攻击法。
限制在上一次验证失败后对同一用户再试尝试的频率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##密码嗅探和重播攻击&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用SSL可以有效地防止HTTP请求和回应不被暴露。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;防止重播攻击：设定受保护资源永久访问权的数据的使用；设定受保护资源访问权的数据的暴露（甚至是只提供临时访问权的数据）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##记住登录状态的做法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;永久登录是指在浏览器会话间进行持续验证的机制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;永久登录降低了验证机制的安全性，但它增加了可用性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;应该从三个方面来限制永久登录cookie的使用：cookie需在一周内过期；cookie最好只能用于一次验证（在一次成功验证后即删除或重新生成）；在服务端限定cookie在一周内过期。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;应该设计一个方法来减轻被捕获的永久登录cookie造成的风险&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;另一个有用的原则是：在用户执行敏感操作前需要用户提供密码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;需要确认登出系统的用户是确实登出了。（如setcookie(&#39;auth&#39;, &#39;DELETED!&#39;, time())）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##共享主机的源码安全&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此问题没有完美的解决方案。你必须考虑所有你的源码都是公开的，甚至是保存在WEB目录之外的代码也是如此。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最好的办法是把所有的敏感数据存放在数据库中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;保存数据库密码的方案是把你的数据库访问权限保存在一个只有系统管理员才能读取的文件中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##更优的会话数据安全&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;把会话信息保存在数据库。（&lt;code&gt;session_set_save_handler&lt;/code&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##会话数据注入&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此类攻击的原因是因为WEB服务器除了对会话存储目录有读取权限外，还有写入权限。解决这个问题的方法是将会话数据保存在数据库中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##主机文件目录浏览&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;攻击者可以写脚本获取主机的文件目录。因为共享服务器上的文件都是公开的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##PHP的安全模式
PHP的安全模式可以认为是一种深度防范机制。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>读书笔记--SQL基础教程</title>
    <link href="https://hoohack.me/blog/2015/2015-08-17-sql-basic-corse/"/>
    <updated>2015-08-17T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-08-17-sql-basic-corse/</id>
    <content type="html">&lt;p&gt;&lt;img src=&quot;https://www.hoohack.me/assets/images/sql_basic_course.png&quot; alt=&quot;SQL基础教程脑图&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.hoohack.me/assets/images/sql_basic_course.png&quot;&gt;查看大图&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>在php中使用array_values函数调整数组键值</title>
    <link href="https://hoohack.me/blog/2015/2015-08-03-using-array-values-to-reorganize-array-in-php/"/>
    <updated>2015-08-03T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-08-03-using-array-values-to-reorganize-array-in-php/</id>
    <content type="html">&lt;p&gt;来看看这段代码。&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$arr = array(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;&#39;, &#39;d&#39;, &#39;&#39;, &#39;e&#39;);&lt;/p&gt;
&lt;p&gt;print_r($arr);&lt;/p&gt;
&lt;p&gt;$filter_arr = array_filter($arr);&lt;/p&gt;
&lt;p&gt;print_r($filter_arr);&lt;/p&gt;
&lt;p&gt;上面这段程序的运行结果是这样的&lt;/p&gt;
&lt;p&gt;$arr
Array ( [0] =&amp;gt; a [1] =&amp;gt; b [2] =&amp;gt; c [3] =&amp;gt; [4] =&amp;gt; d [5] =&amp;gt; [6] =&amp;gt; e )&lt;/p&gt;
&lt;p&gt;$filter_arr
Array ( [0] =&amp;gt; a [1] =&amp;gt; b [2] =&amp;gt; c [4] =&amp;gt; d [6] =&amp;gt; e )&lt;/p&gt;
&lt;p&gt;当在纯数字键值的数组中进行了元素删除操作的同时，也将数组元素的键值删去了，而且在PHP中不会将数组键值重新调整。那么当需要在删除操作之后再次利用到数组的下标时就不能使用到正确的下标了。&lt;/p&gt;
&lt;p&gt;比如说$arr是从一个字符串分割得到的数据数组，然后需要去除掉空值后继续使用，此时使用$arr[3]希望得到d。但是因为数组的下标已经被打乱了，因此只能得到空值。&lt;/p&gt;
&lt;p&gt;这个问题的解决方案就是使用array_values函数。先看看此函数的定义。&lt;/p&gt;
&lt;p&gt;##array_values
返回数组中所有的值&lt;/p&gt;
&lt;p&gt;array array_values (array $input)&lt;/p&gt;
&lt;p&gt;array_values() 返回 input 数组中所有的值并给其建立数字索引。但不保留键名。被返回的数组将使用数值键，并从0开始且以1递增。&lt;/p&gt;
&lt;p&gt;这个函数正好解决了上面的问题。那么来验证一下这个函数的效果。&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$arr = array(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;&#39;, &#39;d&#39;, &#39;&#39;, &#39;e&#39;);&lt;/p&gt;
&lt;p&gt;print_r($arr);&lt;/p&gt;
&lt;p&gt;$filter_arr = array_values(array_filter($arr));&lt;/p&gt;
&lt;p&gt;print_r($filter_arr);&lt;/p&gt;
&lt;p&gt;上面代码运行的结果是：&lt;/p&gt;
&lt;p&gt;Array ( [0] =&amp;gt; a [1] =&amp;gt; b [2] =&amp;gt; c [3] =&amp;gt; d [4] =&amp;gt; e )&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>JavaScript中[]==![]比较的分析</title>
    <link href="https://hoohack.me/blog/2015/2015-07-30-javascript-equal-expression/"/>
    <updated>2015-07-30T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-07-30-javascript-equal-expression/</id>
    <content type="html">&lt;p&gt;最近发现一个有趣的比较表达式:&lt;/p&gt;
&lt;p&gt;[] == ![]   //结果是true&lt;/p&gt;
&lt;p&gt;为什么会是true呢?好吧,先来看看下面这个:&lt;/p&gt;
&lt;p&gt;[] == []    //结果是false&lt;/p&gt;
&lt;p&gt;这个比较好理解,&lt;code&gt;[]&lt;/code&gt;相当于一个数组实例,那么两个实例使用==来比较是不相等的.&lt;/p&gt;
&lt;p&gt;现在回到上面的表达式,先看表达式右边的操作数:逻辑非运算&lt;code&gt;![]&lt;/code&gt;的结果一定是布尔值,而&lt;code&gt;[]&lt;/code&gt;是一个数组对象实例,经过逻辑非运算之后结果是&lt;code&gt;false&lt;/code&gt;.那么就能知道其实上面的表达式可以写成&lt;/p&gt;
&lt;p&gt;[] == false&lt;/p&gt;
&lt;p&gt;当时就想,那么表达式就是将&lt;code&gt;[]&lt;/code&gt;转换成布尔值做比较了,发现&lt;code&gt;Boolean([])&lt;/code&gt;的值是true,&lt;code&gt;true == false&lt;/code&gt;的结果当然就是false了,所以这个解释是不对的.&lt;/p&gt;
&lt;p&gt;继续查资料,在&lt;code&gt;javascript高级程序设计&lt;/code&gt;中关于==运算符的比较有这么一个规则:&lt;/p&gt;
&lt;p&gt;如果比较运算符的操作数是布尔值的话,那么Javascript会将其转换成数字做比较,那么就能得出&lt;code&gt;[] == false&lt;/code&gt;可以写成&lt;/p&gt;
&lt;p&gt;[] == 0&lt;/p&gt;
&lt;p&gt;此时可以知道,在进行比较时左边的操作数会被转成数字类型的数据,&lt;code&gt;Number([])&lt;/code&gt;的结果是0,&lt;code&gt;0==0&lt;/code&gt;的结果是true.于是乎就能得出结论,&lt;code&gt;[] == ![]&lt;/code&gt;表达式比较的实质是进行数字的比较.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>MySQL LEFT JOIN, RIGHT JOIN INNER JOIN区别分析</title>
    <link href="https://hoohack.me/blog/2015/2015-07-21-mysql-left-right-inner-join-usage/"/>
    <updated>2015-07-21T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-07-21-mysql-left-right-inner-join-usage/</id>
    <content type="html">&lt;p&gt;在参与中大型的项目开发中，所用的数据表比较多，如果需要在两张有联系的表中查找数据，那么就需要用到&lt;code&gt;JOIN&lt;/code&gt;关键字。一般来说都会直接使用JOIN，但是有时候看到同事或其他开发者会使用LEFT JOIN，刚开始不以为然，没有深入思考，然而，经过了一段时间，发现越来越多的代码都是如此，于是乎就觉得必须好好学习一下，以下是学习得到的总结。&lt;/p&gt;
&lt;p&gt;##JOIN的定义&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;内联结：将两个表中存在联结关系的字段符合联结关系的那些记录形成记录集的联结。&lt;/li&gt;
&lt;li&gt;外联结：左外联结和右外联结
左外联结A、B表的意思就是以表A为基础，将表A中的全部记录和B中符合条件的记录联结起来。最后的结果中，A的记录将全部显示出来，而B则只会显示符合搜索条件的记录。B中记录不足的地方均为NULL。
右外联结可以看做是左外联结的相反。是以B表为基础。右外联结A、B跟左外联结B、A的结果是一样的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;##JOIN的用法
假设有两个表A和B，它们的表结构和字段为：&lt;/p&gt;
&lt;p&gt;表A&lt;/p&gt;
&lt;p&gt;aID aMonth
1   01
2   02
3   03
4   04
5   05&lt;/p&gt;
&lt;p&gt;表B&lt;/p&gt;
&lt;p&gt;bID bName
1   Jan
2   Feb
3   Mar
4   April
6   June&lt;/p&gt;
&lt;p&gt;###LEFT JOIN&lt;/p&gt;
&lt;p&gt;SELECT *
FROM A LEFT JOIN B
ON A.aID = B.bID&lt;/p&gt;
&lt;p&gt;结果如下&lt;/p&gt;
&lt;p&gt;aID aMonth bID  bName
1   01      1   Jan
2   02      2   Feb
3   03      3   Mar
4   04      4   April
5   05      NULL NULL&lt;/p&gt;
&lt;p&gt;结果说明&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为A中05记录的aID没有在B中找到有对应的bID，因此为NULL。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###RIGHT JOIN&lt;/p&gt;
&lt;p&gt;SELECT *
FROM A RIGHT JOIN B
ON A.aID = B.bID&lt;/p&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;aID aMonth bID  bName
1   01      1   Jan
2   02      2   Feb
3   03      3   Mar
4   04      4   April
NULL NULL   6   June&lt;/p&gt;
&lt;p&gt;###INNER JOIN&lt;/p&gt;
&lt;p&gt;SELECT *
FROM A INNER JOIN B
ON A.aID = B.bID&lt;/p&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;aID aMonth bID  bName
1   01      1   Jan
2   02      2   Feb
3   03      3   Mar
4   04      4   April&lt;/p&gt;
&lt;p&gt;###隐式的内联结&lt;/p&gt;
&lt;p&gt;SELECT *
FROM A,B
WHERE A.aID = B.bID&lt;/p&gt;
&lt;p&gt;结果说明，&lt;code&gt;INNER JOIN&lt;/code&gt;只显示A.aID=B.bID的结果。说明INNER JOIN只显示符合条件的记录。&lt;/p&gt;
&lt;p&gt;注：
NATURAL JOIN等价于INNER JOIN&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Linux获取文件内容命令总结--tail和head</title>
    <link href="https://hoohack.me/blog/2015/2015-07-18-linux-command-head-and-tail/"/>
    <updated>2015-07-18T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-07-18-linux-command-head-and-tail/</id>
    <content type="html">&lt;p&gt;##head&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;取出文件前面几行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###命令格式&lt;/p&gt;
&lt;p&gt;head [参数]...[文件]...&lt;/p&gt;
&lt;p&gt;###命令参数&lt;/p&gt;
&lt;p&gt;-c, --bytes=[-]K 输出文件的前K个字节；如果有-参数，输出文件的所有内容但不包含最后K个字节。&lt;/p&gt;
&lt;p&gt;-n, --lines=[-]K 输出文件的前K行，默认输出前10行；如果有-参数，则输出所有内容但不包括最后K行。&lt;/p&gt;
&lt;p&gt;-q, --quiet, --slient 从不输出给出文件名的首部&lt;/p&gt;
&lt;p&gt;###使用实例&lt;/p&gt;
&lt;p&gt;文件test_head.log内容&lt;/p&gt;
&lt;p&gt;1
2
3
4
5
6
7
8
9
10
11
12&lt;/p&gt;
&lt;p&gt;###实例1 查看文件前5行内容&lt;/p&gt;
&lt;p&gt;head -n 5 test_head.log&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;1
2
3
4
5&lt;/p&gt;
&lt;p&gt;###实例2 查看除了文件最后5行的内容&lt;/p&gt;
&lt;p&gt;head -n -5 test_head.log&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;1
2
3
4
5
6
7&lt;/p&gt;
&lt;p&gt;##tail&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输出文件的最后一部分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近在Linux开发过程中,经常使用tail命令来查看日志文件进行调试,这是因为在开发过程中,每运行一次程序,log就会被追加到日志文件中,所以使用tail命令来查看新增的日志内容十分方便.由于经常使用,而且在平时的使用过程中只用到了&lt;code&gt;-n&lt;/code&gt;的参数,于是就想多学几个参数,并记录一下.&lt;/p&gt;
&lt;p&gt;###命令格式&lt;/p&gt;
&lt;p&gt;tail [必要参数][选择参数][文件]&lt;/p&gt;
&lt;p&gt;###命令参数&lt;/p&gt;
&lt;p&gt;-f --follow 表示持续监测后面所接的文档名,直到按下&lt;code&gt;ctrl c&lt;/code&gt;才会结束tail的监测&lt;/p&gt;
&lt;p&gt;-v --verbase 输出给出文件名的首部&lt;/p&gt;
&lt;p&gt;-c,--byte=K 输出最后的K个字节数的内容;或使用-c +k输出每一行的K个字节数的内容&lt;/p&gt;
&lt;p&gt;-n,--line=K 输出最后的K行,默认输出10行.或使用-n +K 输出从第K行开始的内容&lt;/p&gt;
&lt;p&gt;--pid=PID 与-f合用,表示在进程ID-PID结束之后也结束&lt;/p&gt;
&lt;p&gt;-q --quiet --slient 从不输出给出文件名的首部&lt;/p&gt;
&lt;p&gt;###使用实例&lt;/p&gt;
&lt;p&gt;文件test_tail.log内容&lt;/p&gt;
&lt;p&gt;1
2
3
4
5
6
7
8
9
10
11
12&lt;/p&gt;
&lt;p&gt;###实例1 查看文件最后5行内容&lt;/p&gt;
&lt;p&gt;tail -n 5 test_tail.log&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;8
9
10
11
12&lt;/p&gt;
&lt;p&gt;###实例2 从第5行开始显示文件&lt;/p&gt;
&lt;p&gt;tail -n +5 test_tail.log&lt;/p&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;p&gt;5
6
7
8
9
10
11
12&lt;/p&gt;
&lt;p&gt;##head和tail结合使用
在取出文件的内容是，将head和tail命令结合起来可以实现很多功能。
比如，要取出一个文件(test.log)的第11到第20行，可以先从文件取出前20行，然后再从已经取出来的文件内容中取出后10行即可：&lt;/p&gt;
&lt;p&gt;head -n 20 test.log | tail -n 10&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>PHP函数--array_map</title>
    <link href="https://hoohack.me/blog/2015/2015-07-16-php-function-array-map/"/>
    <updated>2015-07-16T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-07-16-php-function-array-map/</id>
    <content type="html">&lt;p&gt;最近开发过程中经常使用到这个函数，这个函数用在不遍历数组而通过回调函数处理数组的每一项很有用。记录一下这个函数的使用以及自己最近常用的功能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;array_map-将回调函数作用到给定数组的单元上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##说明&lt;/p&gt;
&lt;p&gt;array_map (callable $callback, array $arr1 [, array $...])&lt;/p&gt;
&lt;p&gt;array_map() 返回一个数组，该数组包含了arr1中的所有单元经过callback作用后的单元。callback接受的参数数目应该和传递给array_map()函数的数组数目一样。&lt;/p&gt;
&lt;p&gt;##参数&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;callback 对每个数组的每个元素作用的回调函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;arr1 将被回调函数（callback）执行的数组&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;...(array) 将被回调函数（callback）执行的数组列表&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;##返回值
返回一个数组，该数组的每个元素都是数组（arr1）里面的每个元素经过回调函数（callback）处理了的。&lt;/p&gt;
&lt;p&gt;##使用范例&lt;/p&gt;
&lt;p&gt;1、例子
&amp;lt;?php
function cube($n)
{
return $n * $n;
}&lt;/p&gt;
&lt;p&gt;$a = array(1, 2, 3);
$b = array_map(&amp;quot;cube&amp;quot;, $a);&lt;/p&gt;
&lt;p&gt;print_r($b); //Array([0] =&amp;gt; 1, [1] =&amp;gt; 4, [2] =&amp;gt; 9)&lt;/p&gt;
&lt;p&gt;二、匿名函数
&amp;lt;?php
$func = function ($value) {
return $value * 2;
};
print_r(array_map($func, range(1, 3))); //Array([0] =&amp;gt; 2, [1] =&amp;gt; 4, [2] =&amp;gt; 4)&lt;/p&gt;
&lt;p&gt;//print_r(array_map(function ($value) { return $value * 2; }, range(1, 3))); //Array([0] =&amp;gt; 2, [1] =&amp;gt; 4, [2] =&amp;gt; 4)&lt;/p&gt;
&lt;p&gt;三、使用更多的数组
&amp;lt;?php
function show_Spanish($n, $m)
{
return(&amp;quot;The number $n is called $m in Spanish&amp;quot;);
}&lt;/p&gt;
&lt;p&gt;function map_Spanish($n, $m)
{
return(array($n =&amp;gt; $m));
}&lt;/p&gt;
&lt;p&gt;$a = array(1, 2, 3, 4, 5);
$b = array(&amp;quot;uno&amp;quot;, &amp;quot;dos&amp;quot;, &amp;quot;tres&amp;quot;, &amp;quot;cuatro&amp;quot;, &amp;quot;cinco&amp;quot;);&lt;/p&gt;
&lt;p&gt;$c = array_map(&amp;quot;show_Spanish&amp;quot;, $a, $b);
print_r($c);&lt;/p&gt;
&lt;p&gt;$d = array_map(&amp;quot;map_Spanish&amp;quot;, $a , $b);
print_r($d);&lt;/p&gt;
&lt;p&gt;输出结果:$c&lt;/p&gt;
&lt;p&gt;Array
(
[0] =&amp;gt; The number 1 is called uno in Spanish
[1] =&amp;gt; The number 2 is called dos in Spanish
[2] =&amp;gt; The number 3 is called tres in Spanish
[3] =&amp;gt; The number 4 is called cuatro in Spanish
[4] =&amp;gt; The number 5 is called cinco in Spanish
)&lt;/p&gt;
&lt;p&gt;$d&lt;/p&gt;
&lt;p&gt;Array
(
[0] =&amp;gt; Array
(
[1] =&amp;gt; uno
)
[1] =&amp;gt; Array
(
[2] =&amp;gt; dos
)
[2] =&amp;gt; Array
(
[3] =&amp;gt; tres
)
[3] =&amp;gt; Array
(
[4] =&amp;gt; cuatro
)
[4] =&amp;gt; Array
(
[5] =&amp;gt; cinco
)
)&lt;/p&gt;
&lt;p&gt;通常使用了两个或更多数组时，它们的长度应该相同，因为回调函数是平行作用于相应的单元上的。如果数组的长度不同，则最短的一个将被用空的单元扩充。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本函数一个有趣的用法是构造一个数组的数组，这可以很容易的通过用 NULL 作为回调函数名来实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;建立一个数组的数组
&amp;lt;?php
$a = array(1, 2, 3);
$b = array(&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;);
$c = array(&amp;quot;uno&amp;quot;, &amp;quot;dos&amp;quot;, &amp;quot;tres&amp;quot;);&lt;/p&gt;
&lt;p&gt;$d = array_map(null, $a, $b, $c);
print_r($d);&lt;/p&gt;
&lt;p&gt;输出
Array
(
[0] =&amp;gt; Array
(
[0] =&amp;gt; 1
[1] =&amp;gt; one
[2] =&amp;gt; uno
)
[1] =&amp;gt; Array
(
[0] =&amp;gt; 2
[1] =&amp;gt; two
[2] =&amp;gt; dos
)
[2] =&amp;gt; Array
(
[0] =&amp;gt; 3
[1] =&amp;gt; three
[2] =&amp;gt; tres
)
)&lt;/p&gt;
&lt;p&gt;最近最常用到的是获取一个数组的某一个键值对应的值组成的数组。比如从数据库中获取某个数据表的id，经常会返回以下数组&lt;/p&gt;
&lt;p&gt;$arr = array(
0 =&amp;gt; array(
&#39;id&#39; =&amp;gt; 111
),
1 =&amp;gt; array(
&#39;id&#39; =&amp;gt; 222
),
2 =&amp;gt; array(
&#39;id&#39; =&amp;gt; 333
)
);&lt;/p&gt;
&lt;p&gt;有时候需要获取数组&lt;code&gt;$arr&lt;/code&gt;所有单元的&lt;code&gt;id&lt;/code&gt;组成的数组，以便进行进一步的操作（比如获得这些id数组组成的字符串然后去其他数据表获取更多的数据）。以前的做法会使用一个foreach，然后返回每一项，学习到了array_map函数之后，则可以使用下面的代码。&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$id_arr = array_map(function($v) {return $v[&#39;id&#39;];}, $arr);
print_r($id_arr); //Array(0 =&amp;gt; &#39;111&#39;, 1 =&amp;gt; &#39;222&#39;, &#39;2&#39; =&amp;gt; 333)&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>PHP函数--array_key_exists</title>
    <link href="https://hoohack.me/blog/2015/2015-07-14-php-function-array-key-exists/"/>
    <updated>2015-07-14T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-07-14-php-function-array-key-exists/</id>
    <content type="html">&lt;p&gt;好记性不如烂笔头，虽然手册上都有函数的说明，但是自己记录一遍的话能记得更加牢固。&lt;/p&gt;
&lt;p&gt;##array_key_exists--检查给定的键名或索引是否存在于数组中。&lt;/p&gt;
&lt;p&gt;###说明&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;bool array_key_exists (mixed $key, array $search)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;array_key_exists()在给定的key存在于数组中时返回TRUE。key可以是任何能作为数组索引的值。array_key_exists()也可以用于对象。&lt;/p&gt;
&lt;p&gt;###参数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;key 要检查的键值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;search 一个数组，包含待检查的键。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###返回值
成功时返回TRUE，或者在失败时返回FALSE。&lt;/p&gt;
&lt;p&gt;###使用例子&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$search_array = array(&#39;first&#39; =&amp;gt; 1, &#39;second&#39; =&amp;gt; 4);&lt;/p&gt;
&lt;p&gt;if (array_key_exists(&#39;key&#39;, $search_array))
{
echo &amp;quot;The &#39;first&#39; element in the array&amp;quot;;
}&lt;/p&gt;
&lt;p&gt;###array_key_exists()与isset()的区别
isset()对于数组中为NULL的值不会返回TRUE，而array_key_exists()会。&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$search_array = array(&#39;first&#39; =&amp;gt; null, &#39;second&#39; =&amp;gt; 4);&lt;/p&gt;
&lt;p&gt;var_dump(isset($search_array[&#39;first&#39;]));    //false&lt;/p&gt;
&lt;p&gt;var_dump(array_key_exists(&#39;first&#39;, $search_array));&lt;/p&gt;
&lt;p&gt;这是在工作中新学到的函数，在此总结。如有好的建议，望指出。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>PHP数组遍历顺序</title>
    <link href="https://hoohack.me/blog/2015/2015-07-13-php-traversal-order/"/>
    <updated>2015-07-13T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-07-13-php-traversal-order/</id>
    <content type="html">&lt;p&gt;##问题
上周五一位同事提出了一个问题，数组的排序是怎样的，当时理解错误，就以为是sort方法的排序规则，后来发现他想问的是数组的value的默认排序是怎样的。然后他给出下面这段代码：&lt;/p&gt;
&lt;p&gt;$arr = array(
1 =&amp;gt; &#39;a&#39;,
0 =&amp;gt; &#39;b&#39;,
2 =&amp;gt; &#39;c&#39;
);
foreach ($arr as $val)
{
echo $val . &#39; &#39;;
}&lt;/p&gt;
&lt;p&gt;输出的结果是&lt;code&gt;a b c&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;刚开始看到运行结果的时候，百思不得其解，于是自己测试一下，发现输出的结果正如同事所说的，于是乎就想弄懂为什么。&lt;/p&gt;
&lt;p&gt;##查找资料
周末花了点时间查了一些资料，发现不是排序的问题，应该从数据结构上来解释。PHP的数组使用的数据结构是hashtable，而hashtable的实现是使用双向链表，处理冲突的方式是链接法。PHP数组在增加元素的时候，新元素会插在相同Hash元素链的头部和线性列表的尾部。也就是说，元素在线性遍历的时候是根据插入的先后顺序来遍历的，这个特殊的设计使得在PHP中，当使用数字索引时，元素的先后顺序是由添加的顺序决定的，而不是索引顺序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;更详细解释可以查看PHP大神的这篇文章:&lt;a href=&quot;http://www.laruence.com/2009/08/23/1065.html&quot;&gt;深入理解PHP之数组(遍历顺序)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为上述文章里面有提到PHP的源码，所以继续研究了下，翻了一下PHP的源码，发现源码里面定义的数组的数据结构跟文章说的不一样，一直不能根据上述文章的解释来理解，，后来发现自己查看的是最新的源码，已经是PHP7的版本，而上述文章是在PHP5.6上解释的。PHP7的Zend引擎做了很大的改变，数据结构的定义也发生了改变。后来继续查找资料，发现了另一位大神针对PHP7的哈希表实现写了一篇文章。里面说到，PHP7里面的hashtable的数据结构更加的高效，在于它使用的是单向链表，每个节点少用了两个指针，节省了空间，占用的内存更少，经过测试后发现在64位的系统下，php7的数组的内存使用比起php5.6的少了3.5倍，这是是一个很大的提升。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;更详细的解释可以查看这篇文章:
&lt;a href=&quot;https://nikic.github.io/2014/12/22/PHPs-new-hashtable-implementation.html&quot;&gt;PHP&#39;s new hashtable implementation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这篇文章的一句话也说到新版本的PHP7的数组保存元素的顺序是根据元素插入顺序的&lt;code&gt;The arData array stores the elements in order of insertion. &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;##总结&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PHP的数组保存元素的顺序是根据元素插入的顺序来保存的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这次遇到的这个小问题引发了自己的很多思考，也学到了不少东西。比如说查看PHP的源码。之前自己一直没有勇气查看源码，因为觉得自己还没有达到那个层次。直到这次遇到这个问题，导师跟我说有空的话可以查看一下源码方面的知识。所以我就趁周末有时间下载了源码，查阅资料，然后翻看了部分源码。虽然源码确实很难看懂，但是发现其实没有自己想象的那么复杂。慢慢地学习，查看别人的文章，还是能看懂一点点的，只要每次碰到需要查看源码的时候看一点点，那样就可以学会怎么看了。所以说，遇到困难的问题也要解决，把困难的问题解决了，才有提升的空间。如果总是解决简单的问题，为自己找舒适区，那么就永远不会进步了。&lt;/p&gt;
&lt;p&gt;最后，分享一下学习PHP源码的网站：&lt;a href=&quot;http://www.php-internals.com/book/&quot;&gt;深入理解PHP内核&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>PHP-explode以及implode函数</title>
    <link href="https://hoohack.me/blog/2015/2015-07-09-php-explode-and-implode-function/"/>
    <updated>2015-07-09T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-07-09-php-explode-and-implode-function/</id>
    <content type="html">&lt;p&gt;##implode--将一个一维数组的值转化为字符串。&lt;/p&gt;
&lt;p&gt;###函数说明&lt;/p&gt;
&lt;p&gt;&lt;code&gt;string implode ( string $glue , array $pieces )&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;string implode ( array $pieces )&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;###参数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;glue 连接符，默认为空的字符串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;pices 你想要转换的数组&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###返回值&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;返回一个字符串，其内容由glue分割开的数组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###使用例子&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$arr = array(&#39;apple&#39;, &#39;banana&#39;, &#39;cat&#39;);
$result = implode(&#39;,&#39;, $arr);&lt;/p&gt;
&lt;p&gt;echo $result;   //apple,banana,cat&lt;/p&gt;
&lt;p&gt;###扩展使用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果调用implode函数时传入了string而不是array，函数会返回NULL&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;lt;?php
var_dump(implode(&#39;:&#39;, &#39;xxxx&#39;)); //NULL&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你想合并一个包含booleans值的数组，你会得到一个奇怪的结果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;lt;?php
var_dump(implode(&#39;&#39;, array(true, true, false, false, true)));   //&amp;quot;111&amp;quot;&lt;/p&gt;
&lt;p&gt;##explode--使用一个字符串分隔另一个字符串&lt;/p&gt;
&lt;p&gt;###函数说明&lt;/p&gt;
&lt;p&gt;&lt;code&gt;array explode ( string $delimiter , string $string [, int $limit ] )&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此函数返回由字符串组成的数组，每个元素都是string的子串，它们被字符串delimiter作为边界点分隔出来。&lt;/p&gt;
&lt;p&gt;###参数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;delimiter 边界上的分隔字符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;string 输入的字符串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;limit&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;如果设置了limit参数并且是正数，则返回的数组包含最多limit个元素，而最后的那个元素将包含string的剩余部分。
如果limit参数是负数，则返回除了最后的-limit个元素外的所有元素。
如果limit是0，则会被当做1。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###返回值&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此函数返回由字符串组成的数组，每个元素都是string的一个子串，它们被字符串delimiter作为边界点分隔出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;如果delimiter为空字符串&lt;code&gt;(&amp;quot;&amp;quot;)&lt;/code&gt;，explode()将返回FALSE。如果delimiter所包含的值在string中找不到，并且使用了负数的limit，那么会返回空的array，否则返回包含string单个元素的数组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###使用例子&lt;/p&gt;
&lt;p&gt;一
&amp;lt;?php
$people = &amp;quot;teacher student&amp;quot;;
$arr = explode(&#39; &#39;, $people);&lt;/p&gt;
&lt;p&gt;echo $arr[0];   //teacher
echo $arr[1];   //student&lt;/p&gt;
&lt;p&gt;二
//如果字符串中不包含用于分隔的字符，那么函数将直接返回只包含一个原字符串的数组
&amp;lt;?php
$input = &#39;hello&#39;;
$input2 = &#39;hello,world&#39;;
print_r(explode($input));  //array([0] =&amp;gt; &amp;quot;hello&amp;quot;)
print_r(explode($input2));  //array([0] =&amp;gt; &amp;quot;hello&amp;quot;, [1] =&amp;gt; &amp;quot;world&amp;quot;)&lt;/p&gt;
&lt;p&gt;三
//limit参数例子
&amp;lt;?php
$str = &#39;one|two|three&#39;;&lt;/p&gt;
&lt;p&gt;//正数(小于结果总数)
//输出 array([0] =&amp;gt; &amp;quot;one&amp;quot;, [1] =&amp;gt; &amp;quot;two&amp;quot;)
print_r(explode(&#39;|&#39;, $str, 2));&lt;/p&gt;
&lt;p&gt;//正数(大于结果总数)
//输出 array([0] =&amp;gt; &amp;quot;one&amp;quot;, [1] =&amp;gt; &amp;quot;two&amp;quot;, [2] =&amp;gt; &amp;quot;three&amp;quot;)
print_r(explode(&#39;|&#39;, $str, 4));&lt;/p&gt;
&lt;p&gt;//负数
//输出 array([0] =&amp;gt; &amp;quot;one&amp;quot;, [1] =&amp;gt; &amp;quot;two&amp;quot;)
print_r(explode(&#39;|&#39;, $str, -1));&lt;/p&gt;
&lt;p&gt;###扩展使用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果一个字符串有多个分隔符，而且此字符串需要被分隔，那么可以先替换所有的分隔符为其中一个，然后再进行分隔。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;lt;?php
function multiExplode($delimiters, $string)
{
$ready = str_replace($delimiters, $delimiters[0], $string);
$launch = explode($delimiters[0], $ready);
return $launch;
}&lt;/p&gt;
&lt;p&gt;$text = &amp;quot;here is a sample: this text, and this will be exploded. this also | this one too :)&amp;quot;;
$exploded = multiexplode(array(&amp;quot;,&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;|&amp;quot;,&amp;quot;:&amp;quot;),$text);&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果分隔的字符串是空的，将会得到一个包含一个空元素的数组。解决这个问题，只需要使用没有回调函数参数的array_filter函数。但是，没有回调函数的array_filter会移除等于&lt;code&gt;FALSE&lt;/code&gt;的元素。那么，如果字符串包含元素0的话，也会被移除了。因此，如果真的需要移除空元素，应该在&lt;code&gt;array_filter&lt;/code&gt;里添加&lt;code&gt;strlen&lt;/code&gt;作为回调函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;lt;?php
$str = &amp;quot;&amp;quot;;
$result = explode(&#39;,&#39;, $str);
print_r($result);   //array([0] =&amp;gt; )&lt;/p&gt;
&lt;p&gt;print_r(array_filter(explode(&#39;,&#39;, $str)));  //array()&lt;/p&gt;
&lt;p&gt;print_r(array_filter(explode(&#39;:&#39;, &amp;quot;1:2::3:0:4&amp;quot;), &#39;strlen&#39;));&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;移除分隔后每个元素两边的空白。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;lt;?php
$str=&amp;quot;one  ,two  ,       three  ,  four    &amp;quot;;
array_map(&#39;trim&#39;, explode(&#39;,&#39;, $str));&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>PDO中使用了ATTR_AUTOCOMMIT的一个坑</title>
    <link href="https://hoohack.me/blog/2015/2015-06-25-PDO-hole-ATTR-AUTOCOMMIT/"/>
    <updated>2015-06-25T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-06-25-PDO-hole-ATTR-AUTOCOMMIT/</id>
    <content type="html">&lt;p&gt;很久没有写博客了，最近工作比较多，没有做到一星期至少一文章。在这里记录下开发过程中在PDO里遇到的一个坑。&lt;/p&gt;
&lt;p&gt;有一次，在执行数据库的INSERT操作时，返回的插入结果是新增的插入行的ID，但是在数据库里面没有看到插入的记录。查找了数据库的Log发现也没有执行sql的记录。折腾了恒久，然后在配置文件将所有配置去掉之后发现执行成功了。后来逐项配置取消，最后发现是设置了&lt;code&gt;PDO::ATTR_AUTOCOMMIT =&amp;gt; 0&lt;/code&gt;这个选项。于是便上网查找相关原因如下。&lt;/p&gt;
&lt;p&gt;在配置PDO时，设置了一项&lt;code&gt;PDO::ATTR_AUTOCOMMIT =&amp;gt; 0&lt;/code&gt;。阅读PHP手册发现，如果这项设为false，那么PDO将试图禁用自动提交以便数据库连接开始一个事务。然而，通过阅读MYSQL文档发现这么一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;After disabling autocommit mode by setting the autocommit variable to zero, changes to transaction-safe tables (such as those for InnoDB or NDBCLUSTER) are not made permanent immediately. You must use COMMIT to store your changes to disk or ROLLBACK to ignore the changes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;意思是当你设置了autocommit为0时，就会将事务安全的表(如InnoDB或NDBCLUSTER)将会变成非马上提交的。你必须使用COMMIT来保存你的改变到硬盘中或者ROLLBACK来回滚事务。&lt;/p&gt;
&lt;p&gt;而UPDATE/INSERT操作会在下面两中情况下被锁住：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在一个事务中&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;不在事务中而且set autocommit = 0被启用了&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以我使用了ATTR_AUTOCOMMIT来允许PDO对象启用一个事务，我没有在程序里面使用事务语句，但PDO默认认为我使用了事务。这意味着，不管你没有使用事务的查询语句中是否使用了自动提交，PDO都会默认的开启事务，以后所有的SQL都将做为事务处理，直到你用commit确认或rollback结束。因为没有提交事务，所以PDO就没有将需要执行的SQL语句提交到MySQL中，但还是会返回成功插入后的ID，因此数据库里面没有记录。&lt;/p&gt;
&lt;p&gt;网上对这个做法的观点不一，但我认为各有各的说法，在实现过程中，只在需要使用事务的时候才使用这个选项，而不是在全局配置中设置就好了。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>PHP中call_user_func和call_user_func_array函数使用与比较</title>
    <link href="https://hoohack.me/blog/2015/2015-05-18-php-call-user-func-and-call-user-func-array-function/"/>
    <updated>2015-05-18T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-05-18-php-call-user-func-and-call-user-func-array-function/</id>
    <content type="html">&lt;p&gt;以前一直都有看到过和用过这两个回调函数，但是只是知道简单地使用，并没有深入了解两个函数的具体用法和不同之处，今天刚好有机会再次接触到这两个函数，就来做个总结，好记性不如烂笔头。&lt;/p&gt;
&lt;p&gt;##call_user_func&lt;/p&gt;
&lt;p&gt;###函数定义&lt;/p&gt;
&lt;p&gt;mixed call_user_func ( callable $callback [, mixed $parameter [, mixed $... ]] )&lt;/p&gt;
&lt;p&gt;把第一个参数作为回调函数调用，并且将其余的参数作为回调函数的参数。&lt;/p&gt;
&lt;p&gt;###参数说明&lt;/p&gt;
&lt;p&gt;callback&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将被调用的回调函数(callable)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;parameter&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;0个或更多的参数，都将被传入回调函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###返回值
返回回调函数的返回值，如果错误则返回FALSE。&lt;/p&gt;
&lt;p&gt;###注意&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;传入call_user_func函数的参数不能为引用传递。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###例子1(call_user_func)&lt;/p&gt;
&lt;p&gt;function sayName($name)
{
echo &amp;quot;My name is $name&amp;quot;;
}&lt;/p&gt;
&lt;p&gt;call_user_func(&#39;sayName&#39;, &#39;Tom&#39;);
call_user_func(&#39;sayName&#39;, &#39;Jack&#39;);&lt;/p&gt;
&lt;p&gt;以上例子输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;My name is Tom&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;My name is Jack&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###例子2(用call_user_func()来调用一个类里面的方法)&lt;/p&gt;
&lt;p&gt;class Test {
static function sayHello($name)
{
echo &amp;quot;Hello,my name is $name&amp;quot;;
}
}&lt;/p&gt;
&lt;p&gt;$class_name = &#39;Test&#39;;
call_user_func(array($class_name, &#39;sayHello&#39;), &#39;Tom&#39;);
call_user_func($class_name. &#39;::sayHello&#39;, &#39;Tom&#39;);&lt;/p&gt;
&lt;p&gt;$obj = new Test();
call_user_func(array($obj, &#39;sayHello&#39;), &#39;Tom&#39;);&lt;/p&gt;
&lt;p&gt;以上例子输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hello,my name is Tom&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Hello,my name is Tom&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##call_user_func_array&lt;/p&gt;
&lt;p&gt;##函数定义&lt;/p&gt;
&lt;p&gt;mixed call_user_func_array ( callable $callback , array $param_arr )&lt;/p&gt;
&lt;p&gt;把第一个参数作为回调函数(callback)调用，把参数数组作(param_arr)为回调函数的的参数传入。&lt;/p&gt;
&lt;p&gt;###参数
callback&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;被调用的回调函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;param_arr&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;要被传入回调函数的数组，这个数组得是索引数组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###返回值
返回回调函数的结果。如果出错的话就返回FALSE。&lt;/p&gt;
&lt;p&gt;###例子1&lt;/p&gt;
&lt;p&gt;function foobar($arg1, $arg2)
{
echo &lt;strong&gt;FUNCTION&lt;/strong&gt; . &amp;quot; got $arg1 and $arg2&#92;n&amp;quot;;
}&lt;/p&gt;
&lt;p&gt;class Foo {
function bar($arg1, $arg2)
{
echo &lt;strong&gt;METHOD&lt;/strong&gt; . &amp;quot; got $arg1 and $arg2&#92;n&amp;quot;;
}
}&lt;/p&gt;
&lt;p&gt;// 调用foobar函数并传入两个参数
call_user_func_array(&amp;quot;foobar&amp;quot;, array(&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;));&lt;/p&gt;
&lt;p&gt;// 调用$foo-&amp;gt;bar()方法并传入两个参数
$foo = new foo;
call_user_func_array(array($foo, &amp;quot;bar&amp;quot;), array(&amp;quot;three&amp;quot;, &amp;quot;four&amp;quot;));&lt;/p&gt;
&lt;p&gt;###例子2(传递引用参数)&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
error_reporting(E_ALL);
function increment(&amp;amp;$var)
{
$var++;
}&lt;/p&gt;
&lt;p&gt;$a = 0;
call_user_func(&#39;increment&#39;, $a);
echo $a.&amp;quot;&#92;n&amp;quot;;//0&lt;/p&gt;
&lt;p&gt;call_user_func_array(&#39;increment&#39;, array(&amp;amp;$a));
echo $a.&amp;quot;&#92;n&amp;quot;;//1
?&amp;gt;&lt;/p&gt;
&lt;p&gt;以上例子输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;foobar got one and two&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;foo::bar got three and four&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##注意&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在函数中注册有多个回调内容时(如使用 call_user_func() 与 call_user_func_array())，如在前一个回调中有未捕获的异常，其后的将不再被调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##区别&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;call_user_func不支持引用参数，call_user_func_array支持引用参数&lt;/li&gt;
&lt;li&gt;传入参数的方式不同&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</content>
  </entry>
  
  <entry>
    <title>PHP匿名函数</title>
    <link href="https://hoohack.me/blog/2015/2015-05-16-php-anonymous-function/"/>
    <updated>2015-05-16T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-05-16-php-anonymous-function/</id>
    <content type="html">&lt;p&gt;##定义(摘抄自PHP手册)
匿名函数(Anonymous functions)，也叫闭包函数(closures)，允许创建一个没有指定名称的函数。最经常用作回调函数(callback)参数的值。当然，也有其他应用的情况。&lt;/p&gt;
&lt;p&gt;###匿名函数示例一&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
echo preg_replace_callback(&#39;~-([a-z])~&#39;, function ($match) {
return strtoupper($match[1]);
}, &#39;hello-world&#39;);&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;helloWorld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上面的正则表达式&lt;code&gt;~-([a-z])~&lt;/code&gt;中的&lt;code&gt;~&lt;/code&gt;表示正则表达式的边界，相当于平常写的正则表达式的&lt;code&gt;//&lt;/code&gt;。因此，上面的正则表达式也可以写作&lt;code&gt;/-([a-z])/&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;闭包函数也可以作为变量来使用。PHP会把此种表达式转换成内置类Closure的对象实例。把一个closure对象赋值给一个变量的方式与普通变量赋值的语法是一样的。最后也要加上分号作为结束。&lt;/p&gt;
&lt;p&gt;###匿名函数变量赋值示例&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$greet = function($name) {
printf(&amp;quot;Hello %s&#92;r&#92;n&amp;quot;, $name);
};&lt;/p&gt;
&lt;p&gt;$greet(&#39;World&#39;);
$greet(&#39;PHP&#39;);&lt;/p&gt;
&lt;p&gt;闭包可以从父作用域中继承变量。任何此类变量都应该使用&lt;code&gt;use&lt;/code&gt;语言结构传递进去。&lt;/p&gt;
&lt;p&gt;###从父作用域继承变量例子&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$message = &#39;hello&#39;;&lt;/p&gt;
&lt;p&gt;// 没有使用&amp;quot;use&amp;quot;
$example = function () {
var_dump($message);
};
echo $example();&lt;/p&gt;
&lt;p&gt;// 继承 $message
$example = function () use ($message) {
var_dump($message);
};
echo $example();&lt;/p&gt;
&lt;p&gt;// 继承变量的值是当函数定义时继承而不是调用时
$message = &#39;world&#39;;
echo $example();&lt;/p&gt;
&lt;p&gt;// 重置$message
$message = &#39;hello&#39;;&lt;/p&gt;
&lt;p&gt;// 通过引用继承
$example = function () use (&amp;amp;$message) {
var_dump($message);
};
echo $example();&lt;/p&gt;
&lt;p&gt;// 值在父作用域的改变影响到了函数调用里面的值
$message = &#39;world&#39;;
echo $example();&lt;/p&gt;
&lt;p&gt;// 闭包也接收正常的参数
$example = function ($arg) use ($message) {
var_dump($arg . &#39; &#39; . $message);
};
$example(&amp;quot;hello&amp;quot;);&lt;/p&gt;
&lt;p&gt;上面程序的输出是：&lt;/p&gt;
&lt;p&gt;Notice: Undefined variable: message in /example.php on line 6
NULL&lt;/p&gt;
&lt;p&gt;string(5) &amp;quot;hello&amp;quot;&lt;/p&gt;
&lt;p&gt;string(5) &amp;quot;hello&amp;quot;&lt;/p&gt;
&lt;p&gt;string(5) &amp;quot;hello&amp;quot;&lt;/p&gt;
&lt;p&gt;string(5) &amp;quot;world&amp;quot;&lt;/p&gt;
&lt;p&gt;string(11) &amp;quot;hello world&amp;quot;&lt;/p&gt;
&lt;p&gt;这些变量必须在函数或者类的头部声明。从父作用域中继承变量与使用全局变量是不同的。全局变量存在于一个全局的范围，无论当前在执行的是哪个函数。而闭包的父作用域是定义该闭包的函数(不一定是调用它的函数)。&lt;/p&gt;
&lt;p&gt;##递归
如果需要递归地调用闭包的话，使用下面的代码：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$recursive = function () use (&amp;amp;$recursive) {
//$recursive函数是有效的
};&lt;/p&gt;
&lt;p&gt;//这样并不行
$recusive = function() use ($recursive) {
//$recursive并不能被识别
};&lt;/p&gt;
&lt;p&gt;##注意&lt;/p&gt;
&lt;p&gt;1.当&#39;引入&#39;变量到闭包的作用域时，很容易忽略/忘记它们是真的被拷贝到闭包的作用域里而不是仅仅作为可以的值。&lt;/p&gt;
&lt;p&gt;因此当你需要在闭包里改变变量的时候，你应该使用引入变量的方式传入。&lt;/p&gt;
&lt;p&gt;2.当你调用一个保存在实例化的变量的闭包时是无效的，如下面的代码所示：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$obj = new StdClass();&lt;/p&gt;
&lt;p&gt;$obj-&amp;gt;func = function() {
echo &amp;quot;hello&amp;quot;;
}&lt;/p&gt;
&lt;p&gt;//$obj-&amp;gt;func(); 并不能执行&lt;/p&gt;
&lt;p&gt;//应该这样调用：
$func = $obj-&amp;gt;func();
$func();&lt;/p&gt;
&lt;p&gt;//或者
call_user_func($obj-&amp;gt;func);&lt;/p&gt;
&lt;p&gt;//但是，这样的方式也是可以的：
$array[&#39;func&#39;] = function() {
echo &#39;hello&#39;;
};&lt;/p&gt;
&lt;p&gt;$array&lt;a href=&quot;https://hoohack.me/blog/2015/2015-05-16-php-anonymous-function/&quot;&gt;&#39;func&#39;&lt;/a&gt;;&lt;/p&gt;
&lt;p&gt;##跟Javascript的闭包的几点比较
上面提到，在PHP中通过值传递是这样的&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$message = &#39;hello&#39;;
$example = function () use ($message) {
var_dump($message);
};
$message = &#39;world&#39;;
$example();&lt;/p&gt;
&lt;p&gt;上面输出的是&lt;code&gt;hello&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在Javascript的闭包可以通过下面的例子实现相同的效果&lt;/p&gt;
&lt;p&gt;var message = &#39;hello&#39;;&lt;/p&gt;
&lt;p&gt;var func = (function(message) { return function{ alert(message);}})(message);
message = &#39;world&#39;;
func();//输出hello&lt;/p&gt;
&lt;p&gt;PHP中在使用闭包时的引用传递如下：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$message = &#39;hello&#39;;
$example = function () use (&amp;amp;$message) {
var_dump($message);
};
$message = &#39;world&#39;;
$example();&lt;/p&gt;
&lt;p&gt;上面输出的是&lt;code&gt;world&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在Javascript中可以这么实现达到相同的效果：&lt;/p&gt;
&lt;p&gt;var message = &#39;hello&#39;;
var func = function() { alert(message); };
message = &#39;world&#39;;
func();//输出world&lt;/p&gt;
&lt;p&gt;PHP的闭包与Javascript的闭包有很大的不同。刚开始看到上面的差别时并没有弄懂，后来通过请教同学之后才知道了为什么。上面两端Javascript的不同是因为在Javascript中并没有块作用域以及两个语言之间本身的解析机制的不同。具体的解释日后再写一篇作解释。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>PHP之道--函数式编程(译)</title>
    <link href="https://hoohack.me/blog/2015/2015-05-13-php-the-right-way-functional-rogramming/"/>
    <updated>2015-05-13T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-05-13-php-the-right-way-functional-rogramming/</id>
    <content type="html">&lt;p&gt;原文出处：&lt;a href=&quot;http://www.phptherightway.com/pages/Functional-Programming.html&quot;&gt;http://www.phptherightway.com/pages/Functional-Programming.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PHP支持一流的函数，意味着函数可以被赋值到一个变量。用户自定义以及内建函数都可以被变量引用以及动态调用。函数可以作为参数传递到其他函数中，函数也可以返回其他函数(这个特性被称为高阶函数)。&lt;/p&gt;
&lt;p&gt;递归，这是一个允许函数调用它本身的特性，它在语言中被支持，但是大多数PHP代码都是用迭代。&lt;/p&gt;
&lt;p&gt;匿名函数(以及闭包支持)自从PHP5.3以后出现(2009)。&lt;/p&gt;
&lt;p&gt;PHP 5.4增加了绑定闭包作用域到对象的特性，也提高回调的支持，如回调函数几乎在任何情况下都可以与匿名函数互换。&lt;/p&gt;
&lt;p&gt;高阶函数最多的使用场景是实现策略模式。内建函数array_filter 需要一个数组参数(data)以及一个用于过滤每一个数组项的函数(一个策略或者一个回调)。&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$input = array(1, 2, 3, 4, 5, 6);&lt;/p&gt;
&lt;p&gt;// 创建一个新的匿名函数然后赋值给一个变量
$filter_even = function($item) {
return ($item % 2) == 0;
};&lt;/p&gt;
&lt;p&gt;// 内建函数 array_filter 接收数据和函数
$output = array_filter($input, $filter_even);&lt;/p&gt;
&lt;p&gt;// 函数不一定要被赋值到变量，下面这一也是可以的：
$output = array_filter($input, function($item) {
return ($item % 2) == 0;
});&lt;/p&gt;
&lt;p&gt;print_r($output);&lt;/p&gt;
&lt;p&gt;闭包是一个可以访问从外部作用域引进来的非全局变量。理论上，闭包是一个带有参数的函数。那些参数在定义时被上下文封闭起来，对外部是不可见的。闭包可以用一个很干净利索的方式解决变量作用域的限制。&lt;/p&gt;
&lt;p&gt;下面一个例子我们使用闭包来定义一个在过滤器外面返回一个过滤器到array_filter的函数。&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
/**
- 创建一个匿名过滤函数，只接收大于$min 的数
*
- 在“大于n”的过滤器之外返回单个过滤器
*/
function criteria_greater_than($min)
{
return function($item) use ($min) {
return $item &amp;gt; $min;
};
}&lt;/p&gt;
&lt;p&gt;$input = array(1, 2, 3, 4, 5, 6);&lt;/p&gt;
&lt;p&gt;// 在input数组中使用已选的过滤函数来调用array_filter函数
$output = array_filter($input, criteria_greater_than(3));&lt;/p&gt;
&lt;p&gt;print_r($output); // 大于3的元素&lt;/p&gt;
&lt;p&gt;每一个在滤子族的过滤函数接收一个大于某个最小值的值。单个被criteria_greater_than函数返回的过滤器是一个拥有在作用域中被值封闭起来的$min参数的闭包(当criteria_greater_than被调用时作为参数传入)。&lt;/p&gt;
&lt;p&gt;为了引入$min变量到创建的函数当中，提前绑定是默认被使用的。事实上，在引入的时候，延迟绑定应该使用引用。想象一个模板或验证库，此时闭包被定义于在作用域中捕捉变量然后当匿名函数执行的时候访问它们。&lt;/p&gt;
&lt;p&gt;第一次做翻译，有些地方还是翻译得不太好，希望各位指正。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>PHP优化之批量操作MySQL</title>
    <link href="https://hoohack.me/blog/2015/2015-05-11-php-optimization-batch-operate-mysql/"/>
    <updated>2015-05-11T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-05-11-php-optimization-batch-operate-mysql/</id>
    <content type="html">&lt;p&gt;设计一个数据表如下:&lt;/p&gt;
&lt;p&gt;create table optimization(
id INT NOT NULL AUTO_INCREMENT,
value VARCHAR(10) NOT NULL,
PRIMARY KEY(id)
);&lt;/p&gt;
&lt;p&gt;现在有一个业务需求需要批量插入数据。&lt;/p&gt;
&lt;p&gt;先来看看下面这一段代码：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$dsn = &#39;mysql:dbname=test;host=127.0.0.1&#39;;
$user = &#39;root&#39;;
$password = &#39;root&#39;;&lt;/p&gt;
&lt;p&gt;try {
$dbh = new PDO($dsn, $user, $password);
} catch(PDOException $e) {
echo &#39;Connection failed: &#39; , $e-&amp;gt;getMessage();
}&lt;/p&gt;
&lt;p&gt;$begin = microtime(true) * 1000;&lt;/p&gt;
&lt;p&gt;$count = 100;
$stmt = $dbh-&amp;gt;prepare(&#39;INSERT INTO &lt;code&gt;optimization&lt;/code&gt; (id, value) VALUES(:id, :value)&#39;);
$stmt-&amp;gt;bindParam(&#39;:id&#39;, $id);
$stmt-&amp;gt;bindParam(&#39;:value&#39;, $value);
for ($i = 0; $i &amp;lt; $count; $i++)
{
$id = &#39;&#39;;
$value = $i;
$stmt-&amp;gt;execute();
}&lt;/p&gt;
&lt;p&gt;$end = microtime(true) * 1000;
echo &#39;excuted : &#39; , ($end - $begin) , &#39; ms&#39;;&lt;/p&gt;
&lt;p&gt;经过测试，上面代码运行结果如下：&lt;/p&gt;
&lt;p&gt;1、excuted : 7601.4348144531 ms&lt;/p&gt;
&lt;p&gt;2、excuted : 7476.4270019531 ms&lt;/p&gt;
&lt;p&gt;3、excuted : 7674.4387207031 ms&lt;/p&gt;
&lt;p&gt;平均：7584.100179036433 ms&lt;/p&gt;
&lt;p&gt;再来看看第二段代码：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$dsn = &#39;mysql:dbname=test;host=127.0.0.1&#39;;
$user = &#39;root&#39;;
$password = &#39;root&#39;;&lt;/p&gt;
&lt;p&gt;try {
$dbh = new PDO($dsn, $user, $password);
} catch(PDOException $e) {
echo &#39;Connection failed: &#39; , $e-&amp;gt;getMessage();
}&lt;/p&gt;
&lt;p&gt;$begin = microtime(true) * 1000;
$dbh-&amp;gt;beginTransaction();
try {
$count = 100;
$sql = &#39;INSERT INTO &lt;code&gt;optimization&lt;/code&gt; (id, value) VALUES &#39;;
$sql_arr = array();
$sql_str = &#39;&#39;;
for ($i = 0; $i &amp;lt; $count; $i++)
{
$sql_arr[] = (&amp;quot;(&#39;&#39;, $i)&amp;quot;);
}
$sql_str = implode(&#39;,&#39;, $sql_arr);
$sql .= $sql_str;
$stmt = $dbh-&amp;gt;prepare($sql);
$stmt-&amp;gt;execute();
$dbh-&amp;gt;commit();
} catch(Exception $e) {
$dbh-&amp;gt;rollBack();
echo $e-&amp;gt;getMessage() . &#39;&amp;lt;br&amp;gt;&#39;;
}&lt;/p&gt;
&lt;p&gt;$end = microtime(true) * 1000;
echo &#39;excuted : &#39; , ($end - $begin) , &#39; ms&#39;;&lt;/p&gt;
&lt;p&gt;上面这段代码的运行结果如下：&lt;/p&gt;
&lt;p&gt;1、excuted : 99.005859375 ms&lt;/p&gt;
&lt;p&gt;2、excuted : 103.00610351562 ms&lt;/p&gt;
&lt;p&gt;3、excuted : 68.00390625 ms&lt;/p&gt;
&lt;p&gt;平均：90.00528971354 ms&lt;/p&gt;
&lt;p&gt;##分析
可以看出，在第二段代码中，使用了批量插入，此时的效率比第一段提高了84%。原因如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;使用第一段代码的时候，因为每一次循环里都执行了一个mysql语句，此时php需要与mysql获得连接，然后再执行mysql语句，然后再断开。这就是第一段代码最主要的时间开销--PHP与MySQL连接的网络传输IO&lt;/li&gt;
&lt;li&gt;第一段代码SQL语句解析的次数更多&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，在第二段代码中，通过合并SQL语句来实现减少SQL语句解析的次数以及PHP与MySQL连接的次数来达到减少网络传输IO的开销。&lt;/p&gt;
&lt;p&gt;注意：
1、SQL语句是有长度限制的，因此，在进行SQL语句合并时务必不能超过SQL长度限制，通过设置max_allowed_packet可以修改，默认是1M，测试时修改为8M。&lt;/p&gt;
&lt;p&gt;##总结&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在进行对数据库的批量操作（如：插入、更新、修改）时，应当尽可能将SQL语句合并后再执行而不是在循环中依次执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记录下最近在项目中犯下的一个比较大的错误，以后不能再犯了。以前一直都没有注意到，直到现在真正参与到企业项目中，自己的代码被老大指出错误后才发现自己的错误。学习了。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>TCP/IP详解读书笔记--ARP：地址解析协议</title>
    <link href="https://hoohack.me/blog/2015/2015-05-06-read-tcp-ip-illustrated-address-reverse-protocol/"/>
    <updated>2015-05-06T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-05-06-read-tcp-ip-illustrated-address-reverse-protocol/</id>
    <content type="html">&lt;p&gt;ARP为IP地址到对应的硬件地址之间提供动态映射。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;动态是指这个过程是自动完成的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##ARP解析过程
任何时候我们敲入这个形式的命令：&lt;code&gt;ftp bsdi&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;都会进行以下这些步骤。这些步骤的序号如图4-2所示。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;应用程序FTP客户端调用函数gethostbyname把主机名(bsdi)转换成32bit的IP地址。这个函数在DNS(域名系统)中称作解析器。这个转换过程或者使用DNS，或者在较小网络中使用一个静态的主机文件(/etc/hosts)；&lt;/li&gt;
&lt;li&gt;FTP客户端请求TCP用上一步得到的IP地址建立连接；&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;TCP发送一个连接请求分段到远端的主机，即用上述IP地址发送一份IP数据报；&lt;/li&gt;
&lt;li&gt;如果目的主机在本地网络上(如以太网、令牌环网或点对点链接的另一端)，那么IP数据包可以直接送到目的主机上。如果目的主机在一个远程网络上，那么就通过IP选路函数来确定位于本地网络上的下一站路由器地址，并让它转发IP数据报。在这两种情况下，IP数据报都是被送到位于本地网络上的一台主机或路由器。&lt;/li&gt;
&lt;li&gt;假定是一个以太网，那么发送端主机必须把32bit的IP地址变换成48bit的以太网地址。从逻辑Internet地址到对应的物理硬件地址需要进行翻译。这就是ARP的功能。ARP本来是用于广播网络的，有许多主机或路由器连在同一个网络上；&lt;/li&gt;
&lt;li&gt;ARP发送一份称为ARP请求的以太网数据帧给以太网上的每个主机。这个过程称为广播，如图4-2中的虚线所示。ARP请求数据帧中包含目的主机的IP地址(主机名为bsdi)，其意思是“如果你是这个IP地址的拥有者，请回答你的硬件地址。”；&lt;/li&gt;
&lt;li&gt;目的主机的ARP层收到这个广播报文后，识别出这是发送端在寻问它的IP地址，于是发送一个ARP应答。这个ARP应答包含IP地址及对应的硬件地址；&lt;/li&gt;
&lt;li&gt;收到ARP应答后，是ARP进行请求-应答交换的IP数据报现在就可以传送了；&lt;/li&gt;
&lt;li&gt;发送IP数据报到目的主机。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/tcp-ip-illustrated-4-2.png&quot; alt=&quot;ARP解析过程&quot; /&gt;&lt;/p&gt;
&lt;p&gt;##ARP高速缓存
ARP高效运行的关键是由于每个主机上都有一个ARP高速缓存。这个高速缓存存放了最近Internet地址到硬件地址之间的映射记录。高速缓存中每一项的生存时间一般为20分钟。起始时间从被创建时开始算起。&lt;/p&gt;
&lt;p&gt;##ARP的分组格式
在以太网上解析IP地址时，ARP请求和应答分组的格式如图4-3所示(ARP可以用于其他类型的网络，可以解析IP地址以外的地址。紧跟着帧类型字段的前四个字段指定了最后四个字段的类型和长度)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/tcp-ip-illustrated-4-3.png&quot; alt=&quot;ARP分组格式&quot; /&gt;&lt;/p&gt;
&lt;p&gt;以太网报头中的前两个字段是以太网的源地址和目的地址。目的地址为全1的特殊地址是广播地址。电缆上的所有以太网接口都要接收广播的数据帧。&lt;/p&gt;
&lt;p&gt;两个字节长的以太网帧类型表示后面数据的类型。对于ARP请求或应答来说，该字段的值为0x0806。&lt;/p&gt;
&lt;p&gt;形容词hardware(硬件)和protocol(协议)用来描述ARP分组中的各个字段。例如，一个ARP请求分组询问协议地址(这里是IP地址)对应的硬件地址(这里是以太网地址)。&lt;/p&gt;
&lt;p&gt;硬件类型字段表示硬件地址的类型。它的值为1即表示以太网地址。协议类型字段表示要映射的协议地址类型。它的值为0x0800即表示IP地址。它的值与包含IP数据报的以太网数据帧中的类型字段的值相同。&lt;/p&gt;
&lt;p&gt;接下来的两个1字节的字段，硬件地址长度和协议地址长度分别指出硬件地址和协议地址的长度，以字节为单位。对于以太网上IP地址的ARP请求或应答来说，它们的值分别为6和4.&lt;/p&gt;
&lt;p&gt;操作字段指出四种操作类型，它们是ARP请求(值为1)、ARP应答(值为2)、RARP请求(值为3)和RARP应答(值为4)。这个字段是必需的，因为ARP请求和ARP应答的帧类型字段值是相同的。&lt;/p&gt;
&lt;p&gt;接下来的四个字段是发送端的硬件地址(在本例中是以太网地址)、发送端的协议地址(IP地址)、目的端的硬件地址和目的端的协议地址。注意，这里有一些重复信息：在以太网的数据帧报头中和ARP请求数据帧中都有发送端的硬件地址。&lt;/p&gt;
&lt;p&gt;##ARP代理
如果ARP请求是从一个网络的主机发往另一个网络上的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程称作委托ARP或ARP代理(Proxy ARP)。这样可以欺骗发起ARP请求的发送端，使它误以为路由器就是目的主机，而事实上目的主机是在路由器的“另一边”。路由器的功能相当于目的主机的代理，把分组从其他主机转发给它。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：路由器的功能相当于目的主机的代理，把分组从其他主机转发给它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ARP代理也称作混合ARP或ARP出租(ARP hack)。这些名字来自于ARP代理的其他用途：通过两个物理网络之间的路由器可以互相隐藏物理网络。在这种情况下，两个物理网络可以使用相同的网络号，只要把中间的路由器设置成一个ARP代理，以响应一个网络到另一个网络主机的ARP请求。&lt;/p&gt;
&lt;p&gt;##免费ARP
免费ARP(gratuitous ARP)。是指主机发送ARP查找自己的IP地址。通常，它发生在系统引导期间进行接口配置的时候。&lt;/p&gt;
&lt;p&gt;免费ARP可以有两个方面的作用：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;一个主机可以通过它来确定另一个主机是否设置了相同的IP地址。主机并不希望对此ARP请求有一个回答；&lt;/li&gt;
&lt;li&gt;如果发送免费ARP的主机正好改变了硬件地址(很可能是主机关机了，并换了一块接口卡，然后重新启动)，那么这个分组就可以使其他主机高速缓存中旧的硬件地址进行相应的更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;小结：&lt;/p&gt;
&lt;p&gt;在大多数的TCP/IP实现中，ARP是一个基础协议，但是它的运行对于应用程序或系统管理员来说一般是透明的。ARP高速缓存在它的运行过程中非常关键，我们可以用arp命令对高速缓存进行检查和操作。高速缓存中的每一项内容都有一个定时器，根据它来删除不完整和完整的表项。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>TCP/IP详解读书笔记--IP：网际协议</title>
    <link href="https://hoohack.me/blog/2015/2015-05-05-read-tcp-ip-illustrated-IP-Internet-protocol/"/>
    <updated>2015-05-05T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-05-05-read-tcp-ip-illustrated-IP-Internet-protocol/</id>
    <content type="html">&lt;p&gt;IP协议是TCP/IP协议族中最核心的协议。它提供不可靠、无连接的数据传送服务。&lt;/p&gt;
&lt;p&gt;*不可靠(unreliable)*的意思是它不能保证IP数据包能成功到达目的地。IP仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区，IP有一个简单的错误处理算法：丢弃数据包，然后发送ICMP消息报给信源端。任何要求的可靠性必须由上层来提供(如TCP)。&lt;/p&gt;
&lt;p&gt;*无连接(connectionless)*这个术语的意思是IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。这也说明，IP数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报(先是A，然后是B)，每个数据报都是独立地进行路由选择，可以选择不同的路线，因此B可能在A到达之前先到达。&lt;/p&gt;
&lt;p&gt;##IP首部
IP数据报的格式如图3-1所示。普通的IP首部长为20个字节，除非含有选项字段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/tcp-ip-illustrate-3-1.png&quot; alt=&quot;IP数据报&quot; /&gt;&lt;/p&gt;
&lt;p&gt;分析首部，最高位在左边，记为0bit；最低位在右边，记为31bit。&lt;/p&gt;
&lt;p&gt;4个字节的32 bit 值以下面的次序传输：首先是 0～7 bit ，其次8～ 15 bit，然后1 6 ～23 bit，最后是24~31 bit。这种传输次序称作big endian字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。以其他形式存储二进制整数的机器，如 little endian格式，则必须在传输数据之前把首部转换成网络字节序。&lt;/p&gt;
&lt;p&gt;目前的协议版本号是4，因此IP有时也称作IPv4。&lt;/p&gt;
&lt;p&gt;首部长度指的是首部占32bit字的数目，包括任何选项。由于它是一个4比特字段，因此首部最长为60个字节。(1byte = 8bits；4比特字段，大小为2^4-1 = 15；字节数目为15*32/8 = 40)&lt;/p&gt;
&lt;p&gt;服务类型(TOS)字段包括一个3 bit的优先权子字段(现在已被忽略)，4 bit的TOS子字段和1 bit未用位但必须置0。4 bit的TOS分别代表：最小时延、最大吞吐量、最高可靠性和最小费用。4 bit中只能置其中 1bit。如果所有4 bit均为0，那么就意味着是一般服务。&lt;/p&gt;
&lt;p&gt;图3 - 2列出了对不同应用建议的TOS值。在最后一列中给出的是十六进制值，因为这就是在后面将要看到的tcpdump命令输出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/tcp-ip-illustrated-3-2.png&quot; alt=&quot;TOS值&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Telnet和Rlogin这两个交互应用要求最小的传输时延，因为人们主要用它们来传输少量的交互数据。另一方面，FTP文件传输则要求有最大的吞吐量。最高可靠性被指明给网络管理(SNMP)和路由选择协议。用户网络新闻(Usenet news, NNTP)是唯一要求最小费用的应用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：现在大多数的TCP/IP实现都不支持TOS特性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总长度字段是指整个IP数据报的长度，以字节为单位。利用首部长度字段和总长度字段，就可以知道I P数据报中数据内容的起始位置和长度。由于该字段长16比特，所以IP数据报最长可达65535字节(2^16 - 1 = 65535)当数据报被分片时，该字段的值也随着变化。标识字段唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。&lt;/p&gt;
&lt;p&gt;TTL(time-to-live生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。TTL的初始值由源主机设置(通常为32或64)，一旦经过一个处理它的路由器，它的值就减去 1。&lt;/p&gt;
&lt;p&gt;首部检验和字段是根据IP首部计算的检验和码。它不对首部后面的数据进行计算。&lt;/p&gt;
&lt;p&gt;最后一个字段是任选项，是数据报中的一个可变长的可选信息。目前，这些任选项定义
如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;安全和处理限制(用于军事领域)&lt;/li&gt;
&lt;li&gt;记录路径(让每个路由器都记下它的IP地址)&lt;/li&gt;
&lt;li&gt;时间戳(让每个路由器都记下它的IP地址和时间)&lt;/li&gt;
&lt;li&gt;宽松的源站选路(为数据报指定一系列必须经过的IP地址)&lt;/li&gt;
&lt;li&gt;严格的源站选路(与宽松的源站选路类似，但是要求只能经过指定的这些地址，不能
经过其他的地址)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;这些选项很少被使用，并非所有的主机和路由器都支持这些选项。&lt;/p&gt;
&lt;p&gt;##IP路由选择
如果目的主机与源主机直接相连(如点对点链路)或都在一个共享网络上(以太网或令牌环网)，那么I P数据报就直接送到目的主机上。否则，主机把数据报发往一默认的路由器上，由路由器来转发该数据报。&lt;/p&gt;
&lt;p&gt;在一般的体制中，IP可以从TCP、UDP、ICMP和IGMP接收数据报(即在本地生成的数据报)并进行发送，或者从一个网络接口接收数据报(待转发的数据报)并进行发送。IP层在内存中有一个路由表。当收到一份数据报并进行发送时，它都要对该表搜索一次。当数据报来自某个网络接口时，IP首先检查目的IP地址是否为本机的IP地址之一或者IP广播地址。如果确实是这样，数据报就被送到由IP首部协议字段所指定的协议模块进行处理。如果数据报的目的不是这些地址，那么(1)如果IP层被设置为路由器的功能，那么就对数据报进行转发(也就是说，像下面对待发出的数据报一样处理)；否则(2)数据报被丢弃。&lt;/p&gt;
&lt;p&gt;路由表中的每一项都包含下面这些信息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;目的I P地址。&lt;/li&gt;
&lt;li&gt;下一站(或下一跳)路由器(next-hop router)的IP地址，或者有直接连接的网络I P地
址。&lt;/li&gt;
&lt;li&gt;标志。&lt;/li&gt;
&lt;li&gt;为数据报的传输指定一个网络接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;IP路由选择主要完成以下这些功能：&lt;/p&gt;
&lt;p&gt;1)搜索路由表，寻找能与目的IP地址完全匹配的表目(网络号和主机号都要匹配)。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口(取决于标志字段的值)。&lt;/p&gt;
&lt;p&gt;2)搜索路由表，寻找能与目的网络号相匹配的表目。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标志字段的值）。目的网络上的所有主机都可以通过这个表目来处置。例如，一个以太网上的所有主机都是通过这种表目进行寻径的。这种搜索网络的匹配方法必须考虑可能的子网掩码。关于这一点我们在下一节中进行讨论。&lt;/p&gt;
&lt;p&gt;3)搜索路由表，寻找标为“默认(default)”的表目。如果找到，则把报文发送给该表目指定的下一站路由器。&lt;/p&gt;
&lt;p&gt;如果上面这些步骤都没有成功，那么该数据报就不能被传送。&lt;/p&gt;
&lt;p&gt;关键点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;事实上，大多数主机和一些路由器可以用默认路由来处理任何目的，除非它在本地局域网上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据报中的目的I P地址始终不发生任何变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个链路层可能具有不同的数据帧首部，而且链路层的目的地址（如果有的话）始终指的是下一站的链路层地址。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;##子网寻址
现在所有的主机都要求支持子网编址。不是把IP地址看成由单纯的一个网络号和一个主机号组成，而是把主机号再分成一个子网号和一个主机号。&lt;/p&gt;
&lt;p&gt;这样做的原因是因为A类和B类地址为主机号分配了太多的空间，可分别容纳的主机数为2^24-2和2^16-2。由于全0或全1的主机号都是无效的，因此我们把总数减去2。&lt;/p&gt;
&lt;p&gt;在InterNIC获得某类I P网络号后，就由当地的系统管理员来进行分配，由他（或她）来决定是否建立子网，以及分配多少比特给子网号和主机号。例如，这里有一个B类网络地址(140.252)，在剩下的16bit中，8bit用于子网号，8bit用于主机号，格式如图3-5所示。这样就允许有254个子网，每个子网可以有254台主机。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/tcp-ip-illustrated-3-5.png&quot; alt=&quot;子网编址&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;子网对于子网内部的路由器是不透明的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##子网掩码
除了IP地址以外，主机还需要知道有多少比特用于子网号及多少比特用于主机号。这是在引导过程中通过子网掩码来确定的。&lt;/p&gt;
&lt;p&gt;这个掩码是一个32bit的值，其中值为1的比特留给网络号和子网号，为0的比特留给主机号。&lt;/p&gt;
&lt;p&gt;图3-7是一个B类地址的两种不同的子网掩码格式。
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/tcp-ip-illustrated-3-7.png&quot; alt=&quot;B类地址掩码&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如图所示，子网号和主机号都是8bit宽。&lt;/p&gt;
&lt;p&gt;第二个例子是一个B类地址划分成10bit的子网号和6 bit的主机号。&lt;/p&gt;
&lt;p&gt;如果知道本机的IP地址，那么就知道它是否为A类、B类或C类地址从IP地址的高位可以得知)，也就知道网络号和子网号之间的分界线。而根据子网掩码就可知道子网号与主机号之间的分界线。&lt;/p&gt;
&lt;p&gt;举例
假设我们的主机地址是140.252.1.1(一个B类地址)，而子网掩码为255.255.255.0(其中8bit为子网号，8bit为主机号)。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果目的IP地址是140.252.4.5，那么我们就知道B类网络号是相同的(140.252)，但是子网号是不同的(1和4)。用子网掩码在两个IP地址之间的比较如图3-8所示。&lt;/li&gt;
&lt;li&gt;如果目的IP地址是140.252.1.22，那么B类网络号还是一样的(140.252)，而且子网号也是一样的(1)，但是主机号是不同的。&lt;/li&gt;
&lt;li&gt;如果目的IP地址是192.43.235.6(一个C类地址)，那么网络号是不同的，因而进一步的比较就不用再进行了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/tcp-ip-illustrated-3-8.png&quot; alt=&quot;两个IP地址比较&quot; /&gt;&lt;/p&gt;
&lt;p&gt;给定两个IP地址和子网掩码后， IP路由选择功能一直进行这样的比较。&lt;/p&gt;
&lt;p&gt;##特殊情况的 IP地址
7个特殊的IP地址，如图3-9所示。
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/tcp-ip-illustrated-3-9.png&quot; alt=&quot;特殊的IP地址&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在这个图中，0表示所有的比特位全为0；-1表示所有的比特位全为1；netid、subnetid和hostid分别表示不为全0或全1的对应字段。子网号栏为空表示该地址没有进行子网划分。&lt;/p&gt;
&lt;p&gt;这个表分成三个部分。表的头两项是特殊的源地址，中间项是特殊的环回地址，最后四项是广播地址。&lt;/p&gt;
&lt;p&gt;##题目&lt;/p&gt;
&lt;p&gt;###环回地址必须是127.0.0.1吗？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不一定，如图3-9所示，环回地址格式是以127开头的就可以了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###子网号为16bit的A类地址与子网号为8bit的B类地址的子网掩码有什么不同？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这两个的子网掩码一样，但是子网数目不同。前者为2^16 - 2，后者为2^8 - 2。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###子网掩码255.255.0.255是否对A类地址有效？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;根据掩码的定义：掩码是一个32bit的值，其中值为1的比特留给网络号和子网号，为0的比特留给主机号。这是个不合法的掩码，对A类地址无效。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
  </entry>
  
  <entry>
    <title>TCP/IP详解读书笔记--链路层</title>
    <link href="https://hoohack.me/blog/2015/2015-04-30-read-tcp-ip-illustrated-link-layer/"/>
    <updated>2015-04-30T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-04-30-read-tcp-ip-illustrated-link-layer/</id>
    <content type="html">&lt;p&gt;##引言
如图1-4所示，在TCP/UP协议族中，链路层主要有三个目的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;为IP模块发送和接收IP数据报；&lt;/li&gt;
&lt;li&gt;为ARP模块发送ARP请求和接收ARP应答；&lt;/li&gt;
&lt;li&gt;为RARP发送RARP请求和接收RARP应答。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/tpc-ip-illustrated-1-4.png&quot; alt=&quot;img-1-4&quot; /&gt;&lt;/p&gt;
&lt;p&gt;##以太网和IEEE 802封装
以太网这个术语一般是指数字设备公司(Digital Equipment Corp.)、英特尔公司(Int e lCorp.)和Xerox公司在1982年联合公布的一个标准。是当今TCP/IP采用的主要的局域网技术。它采用一种称作CSMA/CD的媒体接入方法，其意思是带冲突检测的载波侦听多路接入(Carrier Sense, Multiple Access with Collision Detection)。它的速率为10 Mb/s，地址为48 bit。&lt;/p&gt;
&lt;p&gt;##SLIP：串行线路IP
SLIP的全称是Serial Line IP。它是一种在串行线路上对IP数据报进行封装的简单形式。&lt;/p&gt;
&lt;p&gt;###SLIP协议定义的帧格式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;IP 数据报以一个称作END(0xc0)的特殊字符结束。同时，为了防止数据报到来之前
的线路噪声被当成数据报内容，大多数实现在数据报的开始处也传一个END字符(如果有线
路噪声，那么END字符将结束这份错误的报文。这样当前的报文得以正确地传输，而前一个
错误报文交给上层后，会发现其内容毫无意义而被丢弃)。&lt;/li&gt;
&lt;li&gt;如果IP报文中某个字符为END ，那么就要连续传输两个字节0xdb和0xdc来取代它。0xdb这个特殊字符被称作SLIP的ESC 字符，但是它的值与ASCII码的ESC字符(0x1b)不同。&lt;/li&gt;
&lt;li&gt;如果IP报文中某个字符为SLIP的ESC字符，那么就要连续传输两个字节0xdb和0xdd来
取代它。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;图2-2中的例子就是含有一个END字符和一个ESC字符的IP报文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/tcp-ip-illustruated-2-2.png&quot; alt=&quot;img-2-2&quot; /&gt;&lt;/p&gt;
&lt;p&gt;###缺陷&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;每一端必须知道对方的IP地址。没有办法把本端的 P地址通知给另一端。&lt;/li&gt;
&lt;li&gt;数据帧中没有类型字段(类似于以太网中的类型字段)。如果一条串行线路用于SLIP，
那么它不能同时使用其他协议。&lt;/li&gt;
&lt;li&gt;SLIP没有在数据帧中加上检验和(类似于以太网中的CRC字段)。如果SLIP传输的报
文被线路噪声影响而发生错误，只能通过上层协议来发现(另一种方法是，新型的调制解调
器可以检测并纠正错误报文)。这样，上层协议提供某种形式的CRC就显得很重要。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;##压缩的 SLIP
承认SLIP性能上的缺陷，于是人们提出一个被称作CSLIP(即压缩SLIP)的新协议。CSLIP一般能把上面的40个字节压缩到3或5个字节。它能在CSLIP的每一端维持多达16个TCP连接，并且知道其中每个连接的首部中的某些字段一般不会发生变化。对于那些发生变化的字段，大多数只是一些小的数字和的改变。这些被压缩的首部大大地缩短了交互响应时间。&lt;/p&gt;
&lt;p&gt;##PPP：点对点协议
PPP包括以下三个部分：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在串行链路上封装I P数据报的方法。PPP既支持数据为8位和无奇偶检验的异步模式
(如大多数计算机上都普遍存在的串行接口)，还支持面向比特的同步链接。&lt;/li&gt;
&lt;li&gt;建立、配置及测试数据链路的链路控制协议(LCP：Link Control Protocol)。它允许通信双方进行协商，以确定不同的选项。&lt;/li&gt;
&lt;li&gt;针对不同网络层协议的网络控制协议(NCP：Network Control Protocol)体系。当前RFC定义的网络层有IP、OSI网络层、DECnet以及AppleTalk。例如，IPNCP允许双方商定是否对报文首部进行压缩，类似于CSLIP(缩写词NCP也可用在TCP的前面)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;图2-3是PPP数据帧的格式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/tcp-ip-illustrated-2-3.png&quot; alt=&quot;img-2-3&quot; /&gt;&lt;/p&gt;
&lt;p&gt;###说明
每一帧都以标志字符0x7e开始和结束。紧接着是一个地址字节，值始终是0xff，然后是一个值为0x03的控制字节。接下来是协议字段，类似于以太网中类型字段的功能。当它的值为0x0021时，表示信息字段是一个IP数据报；值为0xc021时，表示信息字段是链路控制数据；值为0x8021时，表示信息字段是网络控制数据。CRC字段(或FCS，帧检验序列)是一个循环冗余检验码，以检测数据帧中的错误。&lt;/p&gt;
&lt;p&gt;标志字符0x7e出现在信息字段中时，PPP需要对它进行转义。&lt;/p&gt;
&lt;p&gt;总的来说， P P P比S L I P具有下面这些优点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;PPP支持在单根串行线路上运行多种协议，不只是IP协议；&lt;/li&gt;
&lt;li&gt;每一帧都有循环冗余检验；&lt;/li&gt;
&lt;li&gt;通信双方可以进行IP地址的动态协商(使用IP网络控制协议)；&lt;/li&gt;
&lt;li&gt;与CSLIP类似，对TCP和IP报文首部进行压缩；&lt;/li&gt;
&lt;li&gt;链路控制协议可以对多个数据链路选项进行设置。为这些优点付出的代价是在每一帧的首部增加3个字节，当建立链路时要发送几帧协商数据，以及更为复杂的实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;##环回接口
环回接口(Loopback Interface)，允许运行在同一台主机上的客户程序和服务器程序通过TCP/IP进行通信。A类网络号127就是为环回接口预留的。&lt;/p&gt;
&lt;p&gt;图2-4是环回接口处理I P数据报的简单过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/tcp-ip-illustrated-2-4.png&quot; alt=&quot;img-2-4&quot; /&gt;&lt;/p&gt;
&lt;p&gt;###关键点&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;传给环回地址(一般是127.0.0.1)的任何数据均作为IP输入。&lt;/li&gt;
&lt;li&gt;传给广播地址或多播地址的数据报复制一份传给环回接口，然后送到以太网上。这是
因为广播传送和多播传送的定义(第12章)包含主机本身。&lt;/li&gt;
&lt;li&gt;任何传给该主机IP地址的数据均送到环回接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;图2-4一个隐含的意思是送给主机本身IP地址的IP数据报一般不出现在相应的网络上。&lt;/p&gt;
&lt;p&gt;##最大传输单元 MTU
如果IP层有一个数据报要传，而且数据的长度比链路层的MTU还大，那么IP层就需要进行分片(fragmentation)，把数据报分成若干片，这样每一片都小于MTU。&lt;/p&gt;
&lt;p&gt;图2-5列出了一些典型的MTU值，它们摘自RFC 1191[Mogul and Deering 1990]。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/tcp-ip-illustrated-2-5.png&quot; alt=&quot;img-2-5&quot; /&gt;&lt;/p&gt;
&lt;p&gt;##路径MTU
路径MTU。两台通信主机路径中的最小MTU。&lt;/p&gt;
&lt;p&gt;两台主机之间的路径MTU不一定是个常数。它取决于当时所选择的路由。而选路不一定是对称的(从A到B的路由可能与从B到A的路由不同)，因此路径MTU在两个方向上不一定是一致的。&lt;/p&gt;
&lt;p&gt;##串行线路吞吐量计算
如果线路速率是9600b/s，而一个字节有8bit，加上一个起始比特和一个停止比特，那么线路的速率就是960B/s(字节/秒)。以这个速率传输一个1024字节的分组需要1066ms。如果用SLIP链接运行一个交互式应用程序，同时还运行另一个应用程序如FTP发送或接收1024字节的数据，那么一般来说就必须等待一半的时间(533ms)才能把交互式应用程序的分组数
据发送出去。&lt;/p&gt;
&lt;p&gt;对于交互应用来说，等待533 ms是不能接受的。关于人的有关研究表明，交互响应时间超过100～200ms就被认为是不好的。这是发送一份交互报文出去后，直到接收到响应信息(通常是出现一个回显字符)为止的往返时间。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>一步步学习Dwoo模板引擎--函数/修饰符</title>
    <link href="https://hoohack.me/blog/2015/2015-04-29-learning-dwoo-step-by-step-functions-modifiers/"/>
    <updated>2015-04-29T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-04-29-learning-dwoo-step-by-step-functions-modifiers/</id>
    <content type="html">&lt;p&gt;###assign
赋值一个变量&lt;/p&gt;
&lt;p&gt;assign(mixed $value, string $var)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : 你想要保存的值&lt;/li&gt;
&lt;li&gt;var : 变量名称 (除了$开头的字符)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子 :&lt;/p&gt;
&lt;p&gt;{assign &#39;test string&#39; myVar}
Variable contains: {$myVar}&lt;/p&gt;
&lt;p&gt;输出:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Variable contains: test string&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;这个组件为了smarty的兼容性而提供，使用=操作符会更简单，就像在各种语言上的赋值一样：&lt;/p&gt;
&lt;p&gt;{$myVar=&#39;test string&#39;}&lt;/p&gt;
&lt;p&gt;###capitalize(转成大写)
把字符串的每一个单词的首字母转成大写。&lt;/p&gt;
&lt;p&gt;capitalize(string $value [, bool $numwords = false ] )&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : 需要转成大写的字符串&lt;/li&gt;
&lt;li&gt;numwords : 是否要转换带有数字的单词&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子:&lt;/p&gt;
&lt;p&gt;{capitalize(&#39;this is a string what2&#39;)}
输出:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This Is A String what2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###cat
连接任意数量的变量或字符串&lt;/p&gt;
&lt;p&gt;cat(array $rest)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;rest : 两个或多个字符串会被合并成一个。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;{$a=&#39;abc&#39;}
{$d=&#39;def&#39;}
{$g=&#39;ghi&#39;}
{cat $a $d $g}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;abcdefghi&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###countCharacters
计算在字符串中的字符数量&lt;/p&gt;
&lt;p&gt;countCharacters(string $value, [ bool $count_spaces = false ])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : 进行运输的字符串&lt;/li&gt;
&lt;li&gt;count_spaces : 如果为true，那么空格的个数也会被计算进去&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;{countCharacters(&#39;ab cd&#39;)}
{countCharacters(&#39;ab cd&#39;, true)}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###countParagraphs
计算字符串中的段落数&lt;/p&gt;
&lt;p&gt;countParagraphs(string $value)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : 需要计算的字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{countParagraphs(&#39;ab cd&#39;)}
{countParagraphs(&#39;ab&#92;n cd&#39;)}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###countSentences
计算字符串的句子数&lt;/p&gt;
&lt;p&gt;countSentences(string $value)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : the string to process&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;{countSentences(&#39;ab cd&#39;)}
{countSentences(&#39;ab. cd&#39;)}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###countWords
计算字符串中的单词个数&lt;/p&gt;
&lt;p&gt;countWords(string $value)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : 需要计算的字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;{countWords(&#39;ab cd&#39;)}&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###counter
初始化一个计数器，在每次调用中递增&lt;/p&gt;
&lt;p&gt;counter([ string $name = &#39;default&#39;, [ int $start = 1, [ int $skip = 1, [ string $direction = &amp;quot;up&amp;quot;, [ bool $print = true, [ string $assign = null ]]]]]])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;name : 计数器名字，如果你需要多个计数器的话就定义它吧&lt;/li&gt;
&lt;li&gt;start : 初始值，如果设置了，那么它会被重置为这个值，默认是1&lt;/li&gt;
&lt;li&gt;skip : 在每一次调用中counter的增量，默认是1
direction : &amp;quot;up&amp;quot;(默认)或者&amp;quot;down&amp;quot;，定义counter是增还是减&lt;/li&gt;
&lt;li&gt;print : 如果为false，counter的值不会被输出。默认是true&lt;/li&gt;
&lt;li&gt;assign : 如果设置了，counter的值会被保存到所给的变量中而不会输出任何东西，重写了print变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{counter start=10 skip=5}
{counter}
{counter}
{counter start=10 direction=down}
{counter}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;15&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;20&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###cycle
几个值之间的轮询，每次返回它们当中的一个值&lt;/p&gt;
&lt;p&gt;cycle([ string $name = &#39;default&#39;, [ mixed $values = null, [ bool $print = true, [ bool $advance = true, [ string $delimiter = &#39;,&#39;, [ string $assign = null, [ bool $reset = false ]]]]]]])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;name : 轮询名称，如果你需要多个轮询，那你就定义一个变量&lt;/li&gt;
&lt;li&gt;values : 一个包含所有值的数组或使用$delimiter分隔的字符串&lt;/li&gt;
&lt;li&gt;print : 如果是false，当前指针会继续指向下一位，但是不会输出任何内容&lt;/li&gt;
&lt;li&gt;advance : 如果为false，指针不会指向下一个值&lt;/li&gt;
&lt;li&gt;delimiter : 用来分隔是字符串的值的分隔符&lt;/li&gt;
&lt;li&gt;assign : 如果设置了，那么该值会被保存到变量中而不是输出&lt;/li&gt;
&lt;li&gt;reset : 如果是true，指针会被从新指向第一个值&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;{cycle values=array(&amp;quot;1red&amp;quot;,&amp;quot;2blue&amp;quot;,&amp;quot;3green&amp;quot;)}
{cycle}
{cycle advance=false}
{cycle}
{cycle}
{cycle}
{cycle reset=true}&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1red&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;2blue&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;3green&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;3green&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;1red&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;2blue&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;1red&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###dateFormat
格式化日期&lt;/p&gt;
&lt;p&gt;dateFormat([string $value = &#39;now&#39;, [ string $format = &#39;M n, Y&#39;, [ int $timestamp = 0, [int $timeZone = 2047, [string $modify = &#39;&#39;]]]]])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : 任何时间格式或DateTime类能支持的日期/时间字符串&lt;/li&gt;
&lt;li&gt;format : 输出的格式，更多详情请见&lt;a href=&quot;http://www.php.net/manual/en/function.date.php&quot;&gt;http://www.php.net/manual/en/function.date.php&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;timestamp : 一个有效的时间戳&lt;/li&gt;
&lt;li&gt;timeZone : DateTimeZone类支持的地区值&lt;/li&gt;
&lt;li&gt;modify : 修改时间戳，更多详情见&lt;a href=&quot;http://www.php.net/manual/en/datetime.modify.php&quot;&gt;http://www.php.net/manual/en/datetime.modify.php&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;{$.now}
{dateFormat value=&amp;quot;now&amp;quot; format=&amp;quot;Y-m-j&amp;quot;}
{dateFormat format=&amp;quot;m/d/y&amp;quot; timestamp=$.now modify=&amp;quot;+150 day&amp;quot;}
{dateFormat &amp;quot;1994-3-15 10:24:22&amp;quot;}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1382017201.358&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;2013-10-17&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;03/16/14&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Mar 3, 1994&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###default
返回一个值，如果是空的话就返回默认值&lt;/p&gt;
&lt;p&gt;default(mixed $value, [ mixed $default = &amp;quot;&amp;quot;])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : 需要检查的变量&lt;/li&gt;
&lt;li&gt;default : 后备值，如果第一个为空就返回它&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;{$var1=&amp;quot;foo&amp;quot;}
{$var2=&amp;quot;&amp;quot;}
{default $var1 &amp;quot;bar&amp;quot;}
{default $var2 &amp;quot;bar&amp;quot;}
{default $var3 &amp;quot;bar&amp;quot;}&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;foo&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;bar&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;bar&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###do
执行一些语句，但不会输出。这是一个简单的可选清洁器，执行如&lt;code&gt;{assign func(&amp;quot;foo&amp;quot;) var}&lt;/code&gt;或使用&lt;code&gt;{capture}&lt;/code&gt;这样的语句而不输出。
我暂时还想不到模板中任何使用它的原因，但是基于一些内部原因，它存在了，因此你可以在你需要的时候使用它。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;{do &amp;quot;foo&amp;quot;}
{do reverse(&amp;quot;bar&amp;quot;)}
输出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;nothing&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###docType
输出一个有效的(X)HTML DOCTYPE&lt;/p&gt;
&lt;p&gt;docType([$docType = &#39;&#39;])
docType : doctype的名称, 默认为HTML5如果该值无法识别或没有给以下的有效值:&lt;/p&gt;
&lt;p&gt;HTML5&lt;/p&gt;
&lt;p&gt;XHTML11&lt;/p&gt;
&lt;p&gt;XHTML1_STRICT&lt;/p&gt;
&lt;p&gt;XHTML1_TRANSITIONAL&lt;/p&gt;
&lt;p&gt;XHTML1_FRAMESET&lt;/p&gt;
&lt;p&gt;XHTML_BASIC1&lt;/p&gt;
&lt;p&gt;HTML4_STRICT&lt;/p&gt;
&lt;p&gt;HTML4_LOOSE&lt;/p&gt;
&lt;p&gt;HTML4_FRAMESET&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;{docType XHTML1_STRICT}
{docType}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;!DOCTYPE html PUBLIC &amp;quot;-//W3C//DTD XHTML 1.0 Strict//EN&amp;quot; &amp;quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###dump
输出变量的值，就像PHP里的var_dump()函数&lt;/p&gt;
&lt;p&gt;dump($value)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : 需要展示的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;{dump $}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Will output an array of all variables global.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###escape
为字符串提供多种过滤模式&lt;/p&gt;
&lt;p&gt;escape([ $value = &amp;quot;&amp;quot;, [ $format = &#39;html&#39;, [ $charset = null ]]])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : 需要处理的字符串&lt;/li&gt;
&lt;li&gt;format : 使用的过滤格式,有效的格式有 : html, htmlall, url, urlpathinfo, quotes, hex, hexentity, javascript 以及 mail&lt;/li&gt;
&lt;li&gt;charset : 转换所使用的编码(只提供给某些格式)，默认是当前Dwoo的编码&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{&amp;quot;some &amp;lt;strong&amp;gt;html&amp;lt;/strong&amp;gt; tags&amp;quot;|escape}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;some &amp;amp;lt;strong&amp;amp;gt;html&amp;amp;lt;/strong&amp;amp;gt; tags&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###eval&lt;/p&gt;
&lt;p&gt;执行一个所给的模板字符串&lt;/p&gt;
&lt;p&gt;eval(string $var, [ $assign = null ])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;var : 用于作为模板的字符串&lt;/li&gt;
&lt;li&gt;assign : 如果设置了，那模板的输出将会被保存到改变了而不是输出
尽管这个组件有点像优化而且不会重新编译你的字符串，但还是不建议使用它。如果你希望你的模板被保存到数据库或其他地方，你应该使用Dwoo&#92;Template&#92;String 类或集成它来实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;###exectime
返回php程序的执行时间&lt;/p&gt;
&lt;p&gt;exectime([$precision = 0])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;$precision : 一个十进制的数字，用于表示程序执行次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{exectime 3}ms
输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;62.064ms&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###extends
继承一个模板&lt;/p&gt;
&lt;p&gt;extends(string $file)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;file : 继承的模板(资源名称)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;注: 你不能使用&lt;code&gt;../&lt;/code&gt;等路径来继承父模板。但是如果是根目录的话可以使用&lt;code&gt;./&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;{extends &amp;quot;base.tpl&amp;quot;}&lt;/p&gt;
&lt;p&gt;###fetch
读取一个文件&lt;/p&gt;
&lt;p&gt;fetch(string $file, [ string $assign = null ])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;file : 需要读取的文件的路径或URI (但是为了性能问题，不推荐读取其他网站的文件)&lt;/li&gt;
&lt;li&gt;assign : 如果设置了，文件将会被保存到该变量而不会输出&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{fetch &#39;&lt;a href=&quot;http://php.net/&quot;&gt;http://php.net&lt;/a&gt;&#39;}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;把网站内容输出到你的模板中(没有展示任何iframe)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###formatSize
格式化一个给定的字节大小的文件为人类可阅读的文件大小&lt;/p&gt;
&lt;p&gt;formatSize($size)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;size : 文件的字节大小&lt;/li&gt;
&lt;li&gt;unit : 输出的单元大小&lt;/li&gt;
&lt;li&gt;decimals : 展示的次数&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{&amp;quot;123&amp;quot;|formatSize}
{&amp;quot;2049&amp;quot;|formatSize}
{&amp;quot;123456&amp;quot;|formatSize}
{&amp;quot;5000000&amp;quot;|formatSize}
{&amp;quot;1572864&amp;quot;|formatSize}
{formatSize(&amp;quot;1572864&amp;quot;, &amp;quot;KB&amp;quot;, 3)}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;123.00 B&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;2.00 KB&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;120.56 KB&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;4.77 MB&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;1.50 MB&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;1536.000 KB&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###googleAnalytics
生成谷歌分析脚本&lt;/p&gt;
&lt;p&gt;googleAnalytics($code, [$domain = &#39;&#39;])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;$code : 谷歌分析的代码&lt;/li&gt;
&lt;li&gt;$domain : 定义一个主机名&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{googleAnalytics code=&amp;quot;UA-xxxxxxxx-1&amp;quot;}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;&amp;lt;script&amp;gt;
var _gaq = _gaq || [];
_gaq.push([&#39;_setAccount&#39;, &#39;UA-xxxxxxxx-1&#39;]);&lt;/p&gt;
&lt;p&gt;_gaq.push([&#39;_setAllowLinker&#39;, true]);
_gaq.push([&#39;_trackPageview&#39;]);&lt;/p&gt;
&lt;p&gt;(function() {
var ga = document.createElement(&#39;script&#39;); ga.type = &#39;text/javascript&#39;;
ga.async = true;
ga.src = (&#39;https:&#39; == document.location.protocol ? &#39;&lt;a href=&quot;https://ssl/&quot;&gt;https://ssl&lt;/a&gt;&#39; :
&#39;&lt;a href=&quot;http://www/&quot;&gt;http://www&lt;/a&gt;&#39;) + &#39;.google-analytics.com/ga.js&#39;;
var s = document.getElementsByTagName(&#39;script&#39;)[0];
s.parentNode.insertBefore(ga, s);
})();
&amp;lt;/script&amp;gt;&lt;/p&gt;
&lt;p&gt;###gravatar(Globally Recognized Avatar:全球通用头像)
根据一个人的邮箱地址返回某个用户的头像，如果你不知道是什么的话，那就查看Grabatar网站。&lt;/p&gt;
&lt;p&gt;gravatar(string $email, [ int $size = 80, [ string $default = &amp;quot;&amp;quot;, [ string $rating = &amp;quot;g&amp;quot; ]]] )&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;email : 你需要头像的用户的email地址&lt;/li&gt;
&lt;li&gt;size : 图片的像素大小，默认为80&lt;/li&gt;
&lt;li&gt;default : ，默认展示的图片的URL, 或者下面三种图片生成器的一种: identicon(Hash值的默认表示), monsterid 或者 wavatar, 点击这里&lt;a href=&quot;http://en.gravatar.com/site/implement/url&quot;&gt;查看更多&lt;/a&gt;, 这个默认为gravator的logo&lt;/li&gt;
&lt;li&gt;rating : 图片的最高访问级别, 默认为g (普通级) 以及其他值 (按顺序) pg (家长指引), r (限制级) and x (成人级)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;&amp;lt;img src=&amp;quot;{gravatar &amp;quot;&lt;a href=&quot;mailto:test@gravatar.com&quot;&gt;test@gravatar.com&lt;/a&gt;&amp;quot; 20 &amp;quot;identicon&amp;quot; &amp;quot;x&amp;quot;}&amp;quot; alt=&amp;quot;Test gravatar&amp;quot; /&amp;gt;&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;&amp;lt;img src=&amp;quot;&lt;a href=&quot;http://www.gravatar.com/avatar/df3d4780faaf2446a65ce39eafdfe1c0?s=20&amp;amp;r=x&quot;&gt;http://www.gravatar.com/avatar/df3d4780faaf2446a65ce39eafdfe1c0?s=20&amp;amp;r=x&lt;/a&gt;&amp;quot; alt=&amp;quot;T&lt;/p&gt;
&lt;p&gt;###htmlStateSelect
返回简单的包含所有美国城市的HTML的select元素&lt;/p&gt;
&lt;p&gt;htmlStateSelect(string $name, [ string $width = &amp;quot;100%&amp;quot;, [int $size = false, [bool $multiselect = false]]])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;name : select元素的id和名字&lt;/li&gt;
&lt;li&gt;width : select元素垂直展示的大小&lt;/li&gt;
&lt;li&gt;size : 大小，默认为false&lt;/li&gt;
&lt;li&gt;multiselect : 多选标志，默认为false&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{htmlStateSelect name=&amp;quot;state&amp;quot; width=&amp;quot;200px&amp;quot;}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;&amp;lt;select name=&amp;quot;state&amp;quot; id=&amp;quot;state&amp;quot; style=&amp;quot;width:200px;&amp;quot;&amp;gt;
&amp;lt;option value=&amp;quot;AL&amp;quot;&amp;gt;Alabama&amp;lt;/option&amp;gt;
...
&amp;lt;option value=&amp;quot;WY&amp;quot;&amp;gt;Wyoming&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;&lt;/p&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{htmlStateSelect name=&amp;quot;state&amp;quot; size=&amp;quot;5&amp;quot; multiselect=&amp;quot;true&amp;quot;}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;&amp;lt;select name=&amp;quot;state&amp;quot; id=&amp;quot;state&amp;quot; style=&amp;quot;width:100%;&amp;quot; size=&amp;quot;5&amp;quot; multiple=&amp;quot;multiple&amp;quot;&amp;gt;
&amp;lt;option value=&amp;quot;AL&amp;quot;&amp;gt;Alabama&amp;lt;/option&amp;gt;
...
&amp;lt;option value=&amp;quot;WY&amp;quot;&amp;gt;Wyoming&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;&lt;/p&gt;
&lt;p&gt;###htmlSelectTime
为时，分，秒和子午线创建一个select框。&lt;/p&gt;
&lt;p&gt;htmlSelectTime( [$prefix = &amp;quot;Time_&amp;quot;, [$time = null, [$display_hours = true, [$display_minutes = true, [$display_seconds = true, [$display_meridian = true, [$use_24_hours = true, [$minute_interval = 1, [$second_interval = 1, [$field_array = null, [$all_extra = &amp;quot;&amp;quot;, [$hour_extra = &amp;quot;&amp;quot;, [$minute_extra = &amp;quot;&amp;quot;, [$second_extra = &amp;quot;&amp;quot;, [$meridian_extra = &amp;quot;&amp;quot;]]]]]]]]]]]]]]] )&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;prefix : 名字前缀&lt;/li&gt;
&lt;li&gt;time : 使用的时间，可以是任何可被strtotime()函数处理的值，mysql或unix的时间戳&lt;/li&gt;
&lt;li&gt;display_hours : 显示小时选择框的标志&lt;/li&gt;
&lt;li&gt;display_minutes : 显示分钟选择框的标志&lt;/li&gt;
&lt;li&gt;display_seconds : 显示秒选择框的标志&lt;/li&gt;
&lt;li&gt;display_meridian : 显示子午线选择框(am/pm)的标志&lt;/li&gt;
&lt;li&gt;use_24_hours : 使用24小时制&lt;/li&gt;
&lt;li&gt;minute_interval : 分钟选择框的间隔&lt;/li&gt;
&lt;li&gt;second_interval : 秒选择框的间隔&lt;/li&gt;
&lt;li&gt;field_array : 使用命名数组。如： foo[hour], foo[minute]...&lt;/li&gt;
&lt;li&gt;all_extra : 添加到所有选择框的附件属性&lt;/li&gt;
&lt;li&gt;hour_extra : 添加到小时选择框的附件属性&lt;/li&gt;
&lt;li&gt;minute_extra : 添加到分钟选择框的附件属性&lt;/li&gt;
&lt;li&gt;second_extra : 添加到秒选择框的附件属性&lt;/li&gt;
&lt;li&gt;meridian_extra : 添加到子午线选择框的附件属性&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本使用&lt;/p&gt;
&lt;p&gt;{htmlSelectTime}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;&amp;lt;select name=&#39;Time_Hour&#39;&amp;gt;
&amp;lt;option value=&#39;0&#39;&amp;gt;0&amp;lt;/option&amp;gt;
&amp;lt;option value=&#39;1&#39;&amp;gt;1&amp;lt;/option&amp;gt;
...
&amp;lt;option value=&#39;22&#39;&amp;gt;22&amp;lt;/option&amp;gt;
&amp;lt;option value=&#39;23&#39; selected=&#39;selected&#39;&amp;gt;23&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;
&amp;lt;select name=&#39;Time_Minute&#39;&amp;gt;
&amp;lt;option value=&#39;0&#39;&amp;gt;0&amp;lt;/option&amp;gt;
&amp;lt;option value=&#39;1&#39;&amp;gt;1&amp;lt;/option&amp;gt;
...
&amp;lt;option value=&#39;35&#39; selected=&#39;selected&#39;&amp;gt;35&amp;lt;/option&amp;gt;
&amp;lt;option value=&#39;36&#39;&amp;gt;36&amp;lt;/option&amp;gt;
...
&amp;lt;option value=&#39;58&#39;&amp;gt;58&amp;lt;/option&amp;gt;
&amp;lt;option value=&#39;59&#39;&amp;gt;59&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;
&amp;lt;select name=&#39;Time_Second&#39;&amp;gt;
&amp;lt;option value=&#39;0&#39;&amp;gt;0&amp;lt;/option&amp;gt;
&amp;lt;option value=&#39;1&#39;&amp;gt;1&amp;lt;/option&amp;gt;
...
&amp;lt;option value=&#39;14&#39; selected=&#39;selected&#39;&amp;gt;14&amp;lt;/option&amp;gt;
&amp;lt;option value=&#39;15&#39;&amp;gt;15&amp;lt;/option&amp;gt;
...
&amp;lt;option value=&#39;58&#39;&amp;gt;58&amp;lt;/option&amp;gt;
&amp;lt;option value=&#39;59&#39;&amp;gt;59&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;&lt;/p&gt;
&lt;p&gt;扩展例子&lt;/p&gt;
&lt;p&gt;{htmlSelectTime prefix=&amp;quot;MyTime_&amp;quot; display_seconds=false use_24_hours=false}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;&amp;lt;select name=&#39;MyTime_Hour&#39;  &amp;gt;
&amp;lt;option value=&#39;1&#39;&amp;gt;1&amp;lt;/option&amp;gt;
...
&amp;lt;option value=&#39;11&#39; selected=&#39;selected&#39;&amp;gt;11&amp;lt;/option&amp;gt;
&amp;lt;option value=&#39;12&#39;&amp;gt;12&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;
&amp;lt;select name=&#39;MyTime_Minute&#39;  &amp;gt;
&amp;lt;option value=&#39;0&#39;&amp;gt;0&amp;lt;/option&amp;gt;
&amp;lt;option value=&#39;1&#39;&amp;gt;1&amp;lt;/option&amp;gt;
...
&amp;lt;option value=&#39;38&#39;&amp;gt;38&amp;lt;/option&amp;gt;
&amp;lt;option value=&#39;39&#39; selected=&#39;selected&#39;&amp;gt;39&amp;lt;/option&amp;gt;
...
&amp;lt;option value=&#39;58&#39;&amp;gt;58&amp;lt;/option&amp;gt;
&amp;lt;option value=&#39;59&#39;&amp;gt;59&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;
&amp;lt;select name=&#39;MyTime_Meridian&#39;&amp;gt;
&amp;lt;option value=&#39;am&#39;&amp;gt;AM&amp;lt;/option&amp;gt;
&amp;lt;option value=&#39;pm&#39; selected=&#39;selected&#39;&amp;gt;PM&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;&lt;/p&gt;
&lt;p&gt;###include
include允许你插入其他模板到当前模板中&lt;/p&gt;
&lt;p&gt;include(string $file [, int $cache_time = null [, string $cache_id = null [, string $compile_id = null [, mixed $data = &#39;_root&#39; [, string $assign = null [, array $rest = array() ]]]]]])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;file : include的资源名称&lt;/li&gt;
&lt;li&gt;cache_time : 模板缓存时间，单位是秒，默认为null (= 会使用Dwoo对象的缓存时间)&lt;/li&gt;
&lt;li&gt;cache_id : 模板的cache_id&lt;/li&gt;
&lt;li&gt;compile_id : 模板的编译id&lt;/li&gt;
&lt;li&gt;data : 这是一个包含数据的数组，会作为被引入模板的根数据，默认为当前传送的数据&lt;/li&gt;
&lt;li&gt;assign : 如果设置了，引入进来的文件会被赋值到该变量中而不会输出&lt;/li&gt;
&lt;li&gt;rest : 会覆盖$data参数的值 (详情见下面)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;注: 所有的赋值变量都是从引入文件来的旧的且有效的数据！&lt;/p&gt;
&lt;p&gt;注: 你不能使用&lt;code&gt;../&lt;/code&gt;等路径来引入模板。但是如果是根目录的话可以使用&lt;code&gt;./&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如例子所示，你要有一个被引入到你的所有页面中的公用的头部。可以通过这样来实现：&lt;/p&gt;
&lt;p&gt;index.html:&lt;/p&gt;
&lt;p&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;Some awesome website&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&lt;/p&gt;
&lt;p&gt;{include file=&amp;quot;header.html&amp;quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/p&gt;
&lt;p&gt;header.html:&lt;/p&gt;
&lt;p&gt;&amp;lt;h1&amp;gt;Some awesome website&amp;lt;/h1&amp;gt;
&amp;lt;div id=&amp;quot;menu&amp;quot;&amp;gt;
{loop $menuItems}&amp;lt;a href=&amp;quot;{$url}&amp;quot;&amp;gt;{$title}&amp;lt;/a&amp;gt;{/loop}
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;Some awesome website&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;h1&amp;gt;Some awesome website&amp;lt;/h1&amp;gt;
&amp;lt;div id=&amp;quot;menu&amp;quot;&amp;gt;
&amp;lt;a href=&amp;quot;index.html&amp;quot;&amp;gt;Home&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;products.html&amp;quot;&amp;gt;Products&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;contact.html&amp;quot;&amp;gt;Contact&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/p&gt;
&lt;p&gt;重写或解析模板变量&lt;/p&gt;
&lt;p&gt;有时你需要在不引入使用Dwoo类的get/output方法得到的变量的模板的情况下解析变量。下面的例子可以帮你实现：&lt;/p&gt;
&lt;p&gt;site_header.tpl:&lt;/p&gt;
&lt;p&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;{$title} - Awesome Inc.&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&lt;/p&gt;
&lt;p&gt;page_about.tpl:&lt;/p&gt;
&lt;p&gt;{include file=&amp;quot;site_header.tpl&amp;quot; title=&amp;quot;About Us&amp;quot;}&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- 公司的About us的页面内容如下 --&amp;gt;
在上面的例子中有两个文件，一个是头部和一些&#39;关于我们&#39;的片段的页面。page_about.tpl文件是在include语句中用title变量解析和传递它的标题--&#39;About Us&#39;以输出下面的内容：&lt;/p&gt;
&lt;p&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;About Us - Awesome Inc.&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&lt;/p&gt;
&lt;p&gt;###indent
在每一行的开头插入给定数量的字符&lt;/p&gt;
&lt;p&gt;indent(string $value, [ int $by = 4, [ string $char = &#39; &#39; ]])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : 要缩进的字符串&lt;/li&gt;
&lt;li&gt;by : 需要在每一行的头部插入的字符数&lt;/li&gt;
&lt;li&gt;char : 需要插入的字符&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;baseline
{indent &amp;quot;foo bar baz
qux and then what was it
again? quux quuux and so on I think&amp;quot;}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;baseline&lt;/p&gt;
&lt;p&gt;foo bar baz&lt;/p&gt;
&lt;p&gt;qux and then what was it&lt;/p&gt;
&lt;p&gt;again? quux quuux and so on I think&lt;/p&gt;
&lt;p&gt;###isset
检查变量是否非空&lt;/p&gt;
&lt;p&gt;isset(mixed $var)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;var : 需要检查的变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{if isset($foo)}SET{else}not set or null{/if}
{$foo=1}
{if isset($foo)}SET{else}not set or null{/if}
{$bar=null}
{if isset($bar)}SET{else}not set or null{/if}&lt;/p&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;not set or null
SET
not set or null&lt;/p&gt;
&lt;p&gt;注意下面这句：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{if $foo}{$foo}{/if}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;是跟下面的这句一样作用的：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{if isset($foo)}{$foo}{/if}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;###loadTemplates
在当前模板中加载其他模板，当前模板的任何有效变量在被引入的模板中也是有效的。&lt;/p&gt;
&lt;p&gt;loadTemplates(string $file)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;file : 需要被子模板(使用{template}定义)解析的资源/模板名称。模板只在它们被引入的情况下可见，因此，如果你需要引入其他文件的话你需要调用load_templates函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{loadTemplates &amp;quot;subtemplates.tpl&amp;quot;}&lt;/p&gt;
&lt;p&gt;###lower
将所给的字符串转换成小写&lt;/p&gt;
&lt;p&gt;lower(string $value)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : 需要转换的字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{lower(&#39;ThiS IS a STRING&#39;)}&lt;/p&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;this is a string&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###mailto
使用可选的垃圾邮件证明(可能失效)编码输出邮件地址&lt;/p&gt;
&lt;p&gt;mailto(string $address, [ string $text = null, [ string $subject = null, [ string $encode = null, [ string $cc = null, [ string $bcc = null, [ string $newsgroups = null, [ string $followupto = null, [ string $extra = null ]]]]]]]])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;address : 目标邮件地址&lt;/li&gt;
&lt;li&gt;text : 链接的展示文本，默认为邮箱地址&lt;/li&gt;
&lt;li&gt;subject : 邮件主题&lt;/li&gt;
&lt;li&gt;encode : 有效的编码方式(none, js, jscharcode or hex)&lt;/li&gt;
&lt;li&gt;cc : 抄送地址, 用逗号分隔&lt;/li&gt;
&lt;li&gt;bcc : 密件抄送地址, 用逗号分隔&lt;/li&gt;
&lt;li&gt;newsgroups : 发送到新闻组邮箱地址, 用逗号分隔&lt;/li&gt;
&lt;li&gt;followupto : 跟进的邮箱地址, 用逗号分隔&lt;/li&gt;
&lt;li&gt;extra : 添加到标签的附加属性&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{mailto &amp;quot;&lt;a href=&quot;mailto:test@gmail.com&quot;&gt;test@gmail.com&lt;/a&gt;&amp;quot; &amp;quot;Name&amp;quot; &amp;quot;subject&amp;quot;}&lt;/p&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;p&gt;&amp;lt;a &lt;a href=&quot;mailto:href=%22mailto:test@gmail.com&quot;&gt;href=&amp;quot;mailto:test@gmail.com&lt;/a&gt;?subject=subject&amp;quot; &amp;gt;Name&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;###math
计算一个数学方程式&lt;/p&gt;
&lt;p&gt;math(string $equation, [ string $format = &amp;quot;&amp;quot;, [ string $assign = &amp;quot;&amp;quot;, [ array $rest = array() ]]])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;equation : 需要计算的方程式，可以使用$foo或特殊的数学变量来包含一些基本的变量&lt;/li&gt;
&lt;li&gt;format : 输出的结果的格式，与printf的相似&lt;/li&gt;
&lt;li&gt;assign : 如果设置了，结果会被赋值到该变量中而不会输出&lt;/li&gt;
&lt;li&gt;rest : 你所用到的数学变量都需要被定义，见例子&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{$c=2}
{math &amp;quot;(a+b)&lt;em&gt;$c/4&amp;quot; a=3 b=5} {&lt;/em&gt; which translates to: ((3+5)*2/4) *}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###nl2br
转换换行为&lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;标签&lt;/p&gt;
&lt;p&gt;nl2br(string $value)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : 需要处理的字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{nl2br(&amp;quot;string
breaking&amp;quot;)}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;string&lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;breaking&lt;/p&gt;
&lt;p&gt;###optional
输出一个变量，如果不存在的话不给予任何提示&lt;/p&gt;
&lt;p&gt;optional(mixed $value)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : 要输出的变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{optional $var}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;(如果$var没有定义的话，没有任何输出，也没有warning提示)&lt;/p&gt;
&lt;p&gt;###regexReplace
使用正则表达式搜索和替换字符串&lt;/p&gt;
&lt;p&gt;regexReplace(string $value, string $search, string $replace)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : 搜索的字符串&lt;/li&gt;
&lt;li&gt;search : 使用的搜索字符串&lt;/li&gt;
&lt;li&gt;replace : 用于替换的内容，必须为完整的正则表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意，如果你想使用反向应用的话，使用&lt;code&gt;&#92;$1&lt;/code&gt;、&lt;code&gt;&#92;$2&lt;/code&gt;而不是&lt;code&gt;$1&lt;/code&gt;、&lt;code&gt;$2&lt;/code&gt;，Dwoo会替换掉$1如果$1是一个变量的话。&lt;/p&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{regexReplace &amp;quot;abcdABCD&amp;quot; &amp;quot;/([a-z])/&amp;quot; &amp;quot;$1*&amp;quot;}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a*b*c*d*ABCD&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###replace
字符串替换&lt;/p&gt;
&lt;p&gt;replace(string $value, mixed $search, mixed $replace)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : 被搜索的字符串&lt;/li&gt;
&lt;li&gt;search : 需要搜索的内容或一个数组&lt;/li&gt;
&lt;li&gt;replace : 用于替换的字符串或者一个字符串数组(与搜索的数组一一对应)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{replace &amp;quot;abc&amp;quot; &amp;quot;b&amp;quot; &amp;quot;B&amp;quot;} or {&amp;quot;abc&amp;quot;|replace:array(a,c):array(A,C)}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;aBc or AbC&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###reverse
逆转字符串或者数组&lt;/p&gt;
&lt;p&gt;reverse(string $value, [ bool $preserve_keys = false ])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : 需要逆转的字符串或者数组&lt;/li&gt;
&lt;li&gt;preserve_keys : 如果value是一个数组而且这个值是true，那么数组的键值会在左边&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{loop reverse(array(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))}{$} {/loop}
{&amp;quot;abc&amp;quot;|reverse}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;c b a&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;cba&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###safe
标记变量为安全的且移除自动转义函数，当且仅当你开启了自动转义函数时有效&lt;/p&gt;
&lt;p&gt;safe(mixed $var)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;var : 需要处理的变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{auto_escape on}
{safe $user}
{/auto_escape}&lt;/p&gt;
&lt;p&gt;###spacify
在字符串的每一个字符之间增加空格(或者给定的字符)&lt;/p&gt;
&lt;p&gt;spacify(string $value, [ $space_char = &#39; &#39; ])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : 字符串&lt;/li&gt;
&lt;li&gt;space_char : 插入的字符&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{spacify &#39;abcd&#39;}
{spacify &#39;abcd&#39; &#39;-&#39;}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a b c d&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a-b-c-d&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###stringFormat
使用springf函数格式化字符串&lt;/p&gt;
&lt;p&gt;stringFormat(string $value, string $format)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : 需要格式化的字符串&lt;/li&gt;
&lt;li&gt;format : 使用的格式，详情见sprintf函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{stringFormat(&#39;23.5787446&#39;, &amp;quot;%.2f&amp;quot;)}
{stringFormat(&#39;23.5787446&#39;, &amp;quot;%d&amp;quot;)}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;23.58&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;23&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###stripTags
移除所有的html标签&lt;/p&gt;
&lt;p&gt;stripTags(string $value, [ bool $addspace = true ])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : 处理的字符串&lt;/li&gt;
&lt;li&gt;addspace : 如果是true，每个被移除的标签都会加上空格&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{stripTags &amp;quot;foo&amp;lt;strong&amp;gt;bold&amp;lt;/strong&amp;gt;bar&amp;quot;}
{stripTags &amp;quot;foo&amp;lt;strong&amp;gt;bold&amp;lt;/strong&amp;gt;bar&amp;quot; false}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;foo bold bar&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;fooboldbar&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###tif
三元if运算符。&lt;/p&gt;
&lt;p&gt;tif(array $rest)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;rest : 你不能使用命名参数来调用此函数，必须是三个按顺序排列的参数(表达式，true的值，false的值) or 或者使用PHP的语法 (expression ? true result : false result)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{$foo = &amp;quot;foo&amp;quot;}
{tif $foo == &amp;quot;bar&amp;quot; ? &amp;quot;true&amp;quot; : &amp;quot;false&amp;quot;} {* full syntax &lt;em&gt;}
{tif $foo ?: &amp;quot;false&amp;quot;} {&lt;/em&gt; 你可以忽略true的值，expression部分会被重用为true的结果 &lt;em&gt;}
{tif $foo ? &amp;quot;true&amp;quot;} {&lt;/em&gt; 你可以忽略false的值，expression部分会被重用为false的结果 &lt;em&gt;}
{tif $foo} {&lt;/em&gt; 你可以忽略两个值，这种情况下，如果是true，那将输出$foo，否者没有任何输出 *}&lt;/p&gt;
&lt;p&gt;{$foo = null}
{tif $foo == &amp;quot;bar&amp;quot; ? &amp;quot;true&amp;quot; : &amp;quot;false&amp;quot;}
{tif $foo ?: &amp;quot;false&amp;quot;}
{tif $foo ? &amp;quot;true&amp;quot;}
{tif $foo}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;true&lt;/p&gt;
&lt;p&gt;foo&lt;/p&gt;
&lt;p&gt;true&lt;/p&gt;
&lt;p&gt;foo&lt;/p&gt;
&lt;p&gt;false&lt;/p&gt;
&lt;p&gt;false&lt;/p&gt;
&lt;p&gt;(empty)&lt;/p&gt;
&lt;p&gt;(empty)&lt;/p&gt;
&lt;p&gt;###truncate
截断字符串&lt;/p&gt;
&lt;p&gt;truncate(string $value, [ int $length = 80, [ string $etc = &#39;...&#39;, [ bool $break = false, [ bool $middle = false ]]]])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : 字符串&lt;/li&gt;
&lt;li&gt;length : 字符串的最大长度&lt;/li&gt;
&lt;li&gt;etc : 当字符串被截断后，添加到字符串后面的字符&lt;/li&gt;
&lt;li&gt;break : 如果是true，在精确的长度位置开始截断，而不是从最近的空间了&lt;/li&gt;
&lt;li&gt;middle : 如果是true，那么会从中间截断字符&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{truncate &amp;quot;this text is really too long, or let&#39;s just pretend it is will you?&amp;quot; 30 middle=true}
{strlen truncate(&amp;quot;this text is really too long, or let&#39;s just pretend it is will you?&amp;quot; 30 middle=true)} {* 检查是否为30个字符 *}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;this text is r... is will you?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;30&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###upper
转换成大写&lt;/p&gt;
&lt;p&gt;upper(string $value)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : 字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{upper(&#39;This is a String&#39;)}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;THIS IS A STRING&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###whitespace
替换所有字符串的空格&lt;/p&gt;
&lt;p&gt;whitespace(string $value, [ string $with = &#39; &#39;])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : 字符串&lt;/li&gt;
&lt;li&gt;with : 替换到被移除位置的字符，注意，每一个连续的空格都会被一个字符串替换&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{&amp;quot;a    b  c        d&#92;ne&amp;quot;|whitespace}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a b c d e&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###wordwrap
将字符串包成给定长度&lt;/p&gt;
&lt;p&gt;wordwrap(string $value, [ int $length = 80, [ string $break = &amp;quot;&#92;n&amp;quot;, [ bool $cut = false ]]])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;value : 字符串&lt;/li&gt;
&lt;li&gt;length : 最大长度&lt;/li&gt;
&lt;li&gt;break : 用于分行的字符&lt;/li&gt;
&lt;li&gt;cut : 如果是true，将会从某长度的位置开始截断&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{wordwrap &amp;quot;abcdefghijklmnopqrstuvwxyz&amp;quot; 8 cut=true}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;abcdefgh&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;ijklmnop&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;qrstuvwx&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;yz&lt;/p&gt;
&lt;/blockquote&gt;
</content>
  </entry>
  
  <entry>
    <title>说说PHP中foreach引用的一个坑</title>
    <link href="https://hoohack.me/blog/2015/2015-04-25-talk-about-a-hole-in-php-foreach-quote/"/>
    <updated>2015-04-25T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-04-25-talk-about-a-hole-in-php-foreach-quote/</id>
    <content type="html">&lt;p&gt;先来看看下面这段代码：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$arr = array(&#39;apple&#39;,&#39;banana&#39;,&#39;cat&#39;,&#39;dog&#39;);
foreach($arr as $key=&amp;gt;$val)
{
//some code
}&lt;/p&gt;
&lt;p&gt;echo $val;  //输出dog
echo $key;  //输出3&lt;/p&gt;
&lt;p&gt;//下面对val进行赋值
$val = &#39;e&#39;;
print_r($arr);  //输出Array ( [0] =&amp;gt; apple [1] =&amp;gt; banana [2] =&amp;gt; cat [3] =&amp;gt; dog )&lt;/p&gt;
&lt;p&gt;说明：在上面的foreach循环中，当循环结束后，$key和$val变量都不会被自动释放掉。值会被保存下来。而且此时修改$val的值不会影响$arr。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;引用：如果想在遍历数组的过程中修改数组的元素，可以在foreach中对$val使用引用。此时被引用的元素$val指向当前数组元素的内存地址，即共享一段内存地址。因此修改$val的值会同时改变$arr[$key]的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再来看看下面一段在foreach中使用引用的代码，这是最近在项目中遇到的一种情况：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$arr = array(&#39;apple&#39;,&#39;banana&#39;,&#39;cat&#39;,&#39;dog&#39;);
//在foreach中使用引用
foreach($arr as $key =&amp;gt; &amp;amp;$val)
{
$val = &#39;new value&#39;;
}&lt;/p&gt;
&lt;p&gt;echo $val;  //输出new value
echo $key;  //输出3&lt;/p&gt;
&lt;p&gt;$val = &#39;egg&#39;;
print_r($arr);  //输出Array ( [0] =&amp;gt; new value [1] =&amp;gt; new value [2] =&amp;gt; new value [3] =&amp;gt; egg )&lt;/p&gt;
&lt;p&gt;说明：在foreach中使用&amp;amp;引用后，当foreach结束后，$key和$val变量也都不会被自动释放掉，但是此时$val和$arr&lt;a href=&quot;https://hoohack.me/blog/2015/2015-04-25-talk-about-a-hole-in-php-foreach-quote/%E6%AD%A4%E5%A4%84%E6%98%AF$arr%5B3%5D&quot;&gt;count($arr) - 1&lt;/a&gt;指向相同的内存地址。因此，此时修改$val的值也会改变了$arr[3]的值。&lt;/p&gt;
&lt;p&gt;这种情况下很容易犯的错误就是像上面例子所示，在循环外面继续使用被foreach引用的变量，这样会使开发者得不到预期的数据。因此，为了避免这种情况的发生，应该在适当的位置释放变量的引用。以上面的代码为例：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$arr = array(&#39;apple&#39;,&#39;banana&#39;,&#39;cat&#39;,&#39;dog&#39;);
//在foreach中使用引用
foreach($arr as $key =&amp;gt; &amp;amp;$val)
{
$val = &#39;new value&#39;;
}
unset($val);&lt;/p&gt;
&lt;p&gt;echo $val;  //报错，Notice: Undefined variable: val
echo $key;  //输出3&lt;/p&gt;
&lt;p&gt;$val = &#39;egg&#39;;
print_r($arr);  //输出Array ( [0] =&amp;gt; new value [1] =&amp;gt; new value [2] =&amp;gt; new value [3] =&amp;gt; new value )
在foreach结束后unset $val，此时会释放对$val的引用。因此改变$val不会对$arr造成影响。&lt;/p&gt;
&lt;p&gt;这是最近在项目中遇到的坑和解决方案的总结，如果错误或更好地建议，欢迎指出。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>一步步学习Dwoo模板引擎--块和标签</title>
    <link href="https://hoohack.me/blog/2015/2015-04-24-learning-dwoo-step-by-step-blocks-tags/"/>
    <updated>2015-04-24T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-04-24-learning-dwoo-step-by-step-blocks-tags/</id>
    <content type="html">&lt;p&gt;##Blocks（块）&lt;/p&gt;
&lt;p&gt;###a
输出HTML的&amp;lt;a&amp;gt;标签&lt;/p&gt;
&lt;p&gt;a($href, [array $rest = array()])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;href:指定的目标URI&lt;/li&gt;
&lt;li&gt;rest:任何你想添加到标签的属性都可以作为命名参数被添加到标签中&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;{* 创建一个简单的外部链接以及添加一个class属性: *}
{a $url class=&amp;quot;external&amp;quot; /}&lt;/p&gt;
&lt;p&gt;{* 根据其他变量标记链接为可触发变量: *}
{a $link.url class=tif($link.active &amp;quot;active&amp;quot;); $link.title /}&lt;/p&gt;
&lt;p&gt;{* 同上: &amp;lt;a href=&amp;quot;{$link.url}&amp;quot; class=&amp;quot;{if $link.active}active{/if}&amp;quot;&amp;gt;{$link.title}&amp;lt;/a&amp;gt; *}&lt;/p&gt;
&lt;p&gt;###autoEscape(自动转义)
在这个块元素里可以重写自动转义编译器:&lt;/p&gt;
&lt;p&gt;autoEscape(mixed $enabled)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;enabled : 如果设为&amp;quot;on&amp;quot;，&amp;quot;enable&amp;quot;, true或1，那么自动转义编译器就会使用这个块。设为&amp;quot;off&amp;quot;，&amp;quot;disable&amp;quot;，false或者0，那么就不会启用这个块。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;{$user=&amp;quot;&amp;lt;a href=&#92;&amp;quot;javascript:jsAttack()&#92;&amp;quot;&amp;gt;EvilTroll&amp;lt;/a&amp;gt;&amp;quot;}
{$user} {* =&amp;gt; 不转义，如果你在PHP端没有哦过滤你的数据的话，那么这可能会对用户的输入造成伤害 *}&lt;/p&gt;
&lt;p&gt;{autoEscape on}
{$user} {* 这里任何注入的HTML都被转义了，所以是安全的 *}
{/autoEscape}&lt;/p&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;p&gt;&amp;lt;a href=&amp;quot;javascript:jsAttack()&amp;quot;&amp;gt;EvilTroll&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;javascript:jsAttack()&amp;quot;&amp;gt;EvilTroll&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;第一个结果会被浏览器解析为HTML标签，第二个结果会被浏览器解析为文本。&lt;/p&gt;
&lt;p&gt;###block(块)
定义一个可以被子模板集成的块&lt;/p&gt;
&lt;p&gt;block(string $name)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;name : 块名字，可以在子模板中创建一个使用相同名字的新块可以重写它。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;###capture(捕获)
默认会捕获块里面的所有输出然后保存到{$.capture.default}中，如果你提供一个变量名，那将保存到{$.capture.name}中。&lt;/p&gt;
&lt;p&gt;capture([ string $name = &#39;default&#39;, [ string $assign = null, [ bool $cat = false ]]])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;name : 捕获名，用于后面的读取变量&lt;/li&gt;
&lt;li&gt;assign : 如果有设置了，这个值也会被保存到所给的变量中&lt;/li&gt;
&lt;li&gt;cat : 如果为true，这个值会被追加到之前的那一个(如果有的话)而不是覆盖它&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;{capture &amp;quot;foo&amp;quot;}
所有在这里的内容都不会展示，会被保存起来日后使用
{/capture}
捕获到的内容: {$.capture.foo}&lt;/p&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;捕获到的内容: 所有在这里的内容都不会展示，会被保存起来日后使用&lt;/p&gt;
&lt;p&gt;###注释(comment)
注释插件允许你在模板文件中放入注释。这些注释有Dwoo处理，而且不像HTML注释那样，Dwoo的注释不会被输出到浏览器。注释使用{* 和 *}标签分隔，可以单行注释，也可以多行注释。&lt;/p&gt;
&lt;p&gt;{* 这是一个Dwoo注释 *}&lt;/p&gt;
&lt;p&gt;{*
- 这是多行的
- Dwoo 注释!
*}&lt;/p&gt;
&lt;p&gt;{*
这也是一个注释
*}&lt;/p&gt;
&lt;p&gt;###else
通用的else块，它支持所有建于选择性展示的块，如：if,loop,for,foreach以及with。&lt;/p&gt;
&lt;p&gt;如果有一个块包含else语句，那么如果块的条件不满足的话，在{else}以及{/*blockname*}(你不需要关闭else标签)之间的内容就不会被显示。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;{foreach $array val}
$array 非空，展示它的值 : {$val}
{else}
如果这里有数据，说明$array是空的或者不存在。
{/foreach}&lt;/p&gt;
&lt;p&gt;###for
与PHP的for语句十分相似：&lt;/p&gt;
&lt;p&gt;for(string $name, mixed $from, [ int $to = null, [ int $step = 1, [ int $skip = 0 ]]])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;name : 访问迭代器变量的名字&lt;/li&gt;
&lt;li&gt;from : 迭代数组的开始位置(从0开始)或者一个数字的开始值&lt;/li&gt;
&lt;li&gt;to : 迭代数组的结束位置 (如果你在$from里设置一个数组，那么这个值会自动设置为count($array))&lt;/li&gt;
&lt;li&gt;step : 定义每一次遍历过程的增量&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;注： 这个插件支持从其它命名参数传递过来的迭代器，也支持其它语句传递过来的迭代器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;{for i 0 5} {$i} {/for}&lt;/p&gt;
&lt;p&gt;{for i 0 5 2} {$i} {/for}&lt;/p&gt;
&lt;p&gt;{$arr=array(&amp;quot;Bob&amp;quot;,&amp;quot;John&amp;quot;,&amp;quot;Jim&amp;quot;)}
{for i $arr}
{$i} -&amp;gt; {$arr.$i} {* or $arr[$i] *}
{/for}&lt;/p&gt;
&lt;p&gt;输出:&lt;/p&gt;
&lt;p&gt;0  1  2  3  4  5
0  2  4
0 -&amp;gt; Bob
1 -&amp;gt; John
2 -&amp;gt; Jim&lt;/p&gt;
&lt;p&gt;###foreach
与PHP的foreach块相似，遍历一个数组&lt;/p&gt;
&lt;p&gt;foreach(array $from, [ string $key = null, [ string $item = null, [ string $name = &#39;default&#39;, [ string $implode = null ]]]])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;from : 你想遍历的数组&lt;/li&gt;
&lt;li&gt;key : 键值的变量名 (如果某项没有定义的话就是该项的变量名)&lt;/li&gt;
&lt;li&gt;item : 每项的变量名&lt;/li&gt;
&lt;li&gt;name : 访问迭代器变量的名字&lt;/li&gt;
&lt;li&gt;implode : 分隔符，如果提供了，那么将会插入到每项之间&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;注：这个插件支持从其它命名参数传递过来的迭代器，也支持其它语句传递过来的迭代器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;PHP 数据&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
array(
&#39;arr&#39; =&amp;gt; array(
array(&#39;id&#39;=&amp;gt;1, &#39;name&#39;=&amp;gt;&#39;Jim&#39;),
array(&#39;id&#39;=&amp;gt;2, &#39;name&#39;=&amp;gt;&#39;John&#39;),
array(&#39;id&#39;=&amp;gt;3, &#39;name&#39;=&amp;gt;&#39;Bob&#39;),
)
)&lt;/p&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;p&gt;{foreach $arr val implode=&amp;quot;, &amp;quot;}
{$&lt;a href=&quot;http://val.id/&quot;&gt;val.id&lt;/a&gt;} - {$&lt;a href=&quot;http://val.name/&quot;&gt;val.name&lt;/a&gt;}
{/foreach}&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;1 - Jim,
2 - John,
3 - Bob
分隔符参数允许你使用逗号或者任何你想使用来分隔每一项的符号，这比在foreach块中使用{if $.foreach.name.last}, {/if}来分隔更简单。&lt;/p&gt;
&lt;p&gt;###function
在模板文件中创建一个函数&lt;/p&gt;
&lt;p&gt;function(string $name [, array $rest = array() ])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;name : 子模板的名称，你调用时使用的名字，如果你使用一个现有的插件名，那它将会覆盖它&lt;/li&gt;
&lt;li&gt;rest : 一系列的参数以及可选参数(参数名被模板自己保存下来)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;看看{load_templates}函数，允许你从一个文件中加载多个模板，就像你在php中从外部文件include一个方法或者类。&lt;/p&gt;
&lt;p&gt;注意：不能创建相同名字的函数。&lt;/p&gt;
&lt;p&gt;递归输出菜单例子：&lt;/p&gt;
&lt;p&gt;$menuTree为一个数组：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$menuTree = array(
array(&#39;name&#39;=&amp;gt;&#39;Foo&#39;, &#39;children&#39;=&amp;gt;array(
array(&#39;name&#39;=&amp;gt;&#39;Foo-Sub&#39;, &#39;children&#39;=&amp;gt;array()),
array(&#39;name&#39;=&amp;gt;&#39;Foo-Sub2&#39;, &#39;children&#39;=&amp;gt;array()),
)),
array(&#39;name&#39;=&amp;gt;&#39;Bar&#39;, &#39;children&#39;=&amp;gt;array()),
array(&#39;name&#39;=&amp;gt;&#39;Baz&#39;, &#39;children&#39;=&amp;gt;array()),
);
{function menu data tick=&amp;quot;-&amp;quot; indent=&amp;quot;&amp;quot;}
{foreach $data entry}
{$indent}{$tick} {$&lt;a href=&quot;http://entry.name/&quot;&gt;entry.name&lt;/a&gt;}&amp;lt;br /&amp;gt;&lt;/p&gt;
&lt;p&gt;{if $entry.children}
{* 递归调用让子模板更好地输出树状结构 *}
{menu $entry.children $tick cat(&amp;quot;  &amp;quot;, $indent)}
{/if}
{/foreach}
{/function}&lt;/p&gt;
&lt;p&gt;{menu $menuTree &amp;quot;&amp;gt;&amp;quot;}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;&amp;gt; Foo&lt;/p&gt;
&lt;p&gt;&amp;gt; Foo-Sub&lt;/p&gt;
&lt;p&gt;&amp;gt; Foo-Sub2&lt;/p&gt;
&lt;p&gt;&amp;gt; Bar&lt;/p&gt;
&lt;p&gt;&amp;gt; Baz&lt;/p&gt;
&lt;p&gt;###if
条件块，语法跟PHP的十分相似，允许使用() || &amp;amp;&amp;amp;以及其他php操作符。下面是其他Dwoo操作符以及它们对应的php操作符：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;eq → ==&lt;/li&gt;
&lt;li&gt;neq or ne → !=&lt;/li&gt;
&lt;li&gt;gte or ge → &amp;gt;=&lt;/li&gt;
&lt;li&gt;lte or le → &amp;lt;=&lt;/li&gt;
&lt;li&gt;gt → &amp;gt;&lt;/li&gt;
&lt;li&gt;lt → &amp;lt;&lt;/li&gt;
&lt;li&gt;mod → %&lt;/li&gt;
&lt;li&gt;not → !&lt;/li&gt;
&lt;li&gt;X is [not] div by Y → (X % Y) == 0&lt;/li&gt;
&lt;li&gt;X is [not] even [by Y] → (X % 2) == 0 or ((X/Y) % 2) == 0&lt;/li&gt;
&lt;li&gt;X is [not] odd [by Y] → (X % 2) != 0 or ((X/Y) % 2) != 0&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;{if 3 == 5}
不会发生
{elseif 3 == 3}
一定发生
{else}
这永远不会展现
{/if}&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;一定发生&lt;/p&gt;
&lt;p&gt;#literal(字面量)
不把它们当做模板代码输出整个块的内容&lt;/p&gt;
&lt;p&gt;literal()&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个块必须使用{/literal}作为结束，使用{/}或关闭父块无效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;{$var=3}
{literal}
{$var} {* 注释和条件功能在literal会出现异常，因为它们在literal中依然是有效的行为 *}
{/literal}
{$var}&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;{$var}&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;###loop
循环遍历数组和通过自动移动作用域到每一个元素实现真正的简单/小的结构。实际上它是foreach和with的内部结合。&lt;/p&gt;
&lt;p&gt;loop(array $from [, $name = &amp;quot;default ] )&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;PHP 数据&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
array(&#39;users&#39; =&amp;gt; array(
array( &#39;id&#39; =&amp;gt; 1, &#39;name&#39; =&amp;gt; &#39;Bob&#39;),
array( &#39;id&#39; =&amp;gt; 2, &#39;name&#39; =&amp;gt; &#39;John&#39; )
)&lt;/p&gt;
&lt;p&gt;HTML显示&lt;/p&gt;
&lt;p&gt;{loop $users}
{$id}-{$name}
{/loop}&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;1-Bob&lt;/p&gt;
&lt;p&gt;2-John&lt;/p&gt;
&lt;p&gt;访问数组键值&lt;/p&gt;
&lt;p&gt;你可以在loop里面使用&lt;code&gt;{$_key}&lt;/code&gt;变量来访问数组Ian之，为了保持loop的简单性，它的名字不能自定义。&lt;/p&gt;
&lt;p&gt;##strip
删除头和尾的空格，还有去除分行。&lt;/p&gt;
&lt;p&gt;strip(string $mode = &#39;default&#39;)&lt;/p&gt;
&lt;p&gt;mode : mode定义了一些规则来保护某些内容不受伤害，现在只有js/javascript，保证JavaScript的注释不会使脚本失效。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;{strip}
spaces between words in a same line&lt;br /&gt;
+ are not removed -&lt;br /&gt;
but&lt;br /&gt;
everything&lt;br /&gt;
else&lt;br /&gt;
is&lt;br /&gt;
{/strip}&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;spaces between words in a same line- are not removed -buteverythingelseis&lt;/p&gt;
&lt;p&gt;如果你在模板中嵌入了JavaScript，如果代码中包含注释的话，{strip}组件可能会打断你的JavaScript。看个例子：&lt;/p&gt;
&lt;p&gt;{strip}
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
// say hello!
alert(&amp;quot;hello!&amp;quot;);
&amp;lt;/script&amp;gt;
{/strip}
这将会输出：&lt;/p&gt;
&lt;p&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; // say hello! alert(&amp;quot;hello!&amp;quot;); &amp;lt;/script&amp;gt;
脚本现在在一行了，因为第一行是注释，所以全部内容被解析为注释里。为了避免这种情况，可以在{strip}组件中使用js参数。&lt;/p&gt;
&lt;p&gt;{strip js}
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
// say hello!
alert(&amp;quot;hello!&amp;quot;);
&amp;lt;/script&amp;gt;
{/strip}
这样做会移除脚本里的所有注释。&lt;/p&gt;
&lt;p&gt;##textformat(文本格式化)&lt;/p&gt;
&lt;p&gt;使用所给的格式来格式化字符串，你可以限定一行字符串的长度或者使其缩进。&lt;/p&gt;
&lt;p&gt;textformat([ int $wrap = 80, [ string $wrap_char = &amp;quot;&#92;r&#92;n&amp;quot;, [ string $wrap_cut = false, [ int $indent = 0, [ string $indent_char = &amp;quot; &amp;quot;, [ int $indent_first = 0, [ string $style = &amp;quot;&amp;quot;, [ string $assign = &amp;quot;&amp;quot; ]]]]]]]])&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;wrap : 一行最大的长度&lt;/li&gt;
&lt;li&gt;wrap_char : 用于分行的字符&lt;/li&gt;
&lt;li&gt;wrap_cut : 如果是true，超过$wrap的部分将会被删除掉而不是溢出&lt;/li&gt;
&lt;li&gt;indent : 插入到每一行的缩进字符的个数&lt;/li&gt;
&lt;li&gt;indent_char : 插入到每一行的缩进字符&lt;/li&gt;
&lt;li&gt;indent_first : 每个段落第一行需要插入缩进字符的个数&lt;/li&gt;
&lt;li&gt;style : 为一些必要的变量设置了的预定义格式样式，如：email或者html&lt;/li&gt;
&lt;li&gt;assign : 如果设置了，那么格式化之后的文本会被复制到该变量而不会输出&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{textformat 10}here is some text that should wrap{/textformat}&lt;/p&gt;
&lt;p&gt;{textformat 10 wrap_cut=true}and this one should cut words that go beyoooooooond 10 chars{/textformat}&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;here is
some text
that
should
wrap&lt;/p&gt;
&lt;p&gt;and this
one should
cut words
that go
beyooooooo
ond 10
chars&lt;/p&gt;
&lt;p&gt;##with
移动作用域到数组里面的元素，在{with}块里面，允许使用{$var}代替{$array.var}&lt;/p&gt;
&lt;p&gt;with(array $var)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;var : 需要移动作用域的数组&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;{$arr.foo}
{with $arr} {$foo} / {$arr.foo} {/with}&lt;/p&gt;
&lt;p&gt;数据&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&#39;arr&#39; =&amp;gt; array( &#39;foo&#39; =&amp;gt; &#39;bar&#39; )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;bar
bar /&lt;/p&gt;
&lt;p&gt;这个组件比较狡猾的地方是，一旦你移动了作用域到其他地方，你就不能访问全局变量了。
正如你看到的上个例子，在{with}里面的{$arr.foo}是无效的并返回null。你可以使用&lt;code&gt;_parent_and_root&lt;/code&gt;解决这个问题。&lt;code&gt;$_root&lt;/code&gt;链接到最顶部的作用域，&lt;code&gt;$_parent&lt;/code&gt;是上一级作用域。$dwoo的魔法变量不会被这个影响，它们可以在任何作用域中使用相同方式访问。&lt;/p&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;{with $arr.sub}
{$foo} / {$_root.arr.sub.foo} / {$_parent.foo}
{$_root.url} / {$_parent._parent.url}
{$dwoo.version}
{/with}
数据&lt;/p&gt;
&lt;p&gt;&#39;arr&#39; =&amp;gt; array( &#39;sub&#39; =&amp;gt; array( &#39;foo&#39; =&amp;gt; &#39;bar&#39; ) )&lt;/p&gt;
&lt;p&gt;&#39;url&#39; =&amp;gt; &#39;&lt;a href=&quot;http://example.org/&quot;&gt;example.org&lt;/a&gt;&#39;&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;bar / bar / bar&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://example.org/&quot;&gt;example.org&lt;/a&gt; / &lt;a href=&quot;http://example.org/&quot;&gt;example.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;0.3.3&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>一步步学习Dwoo模板引擎--变量</title>
    <link href="https://hoohack.me/blog/2015/2015-04-23-learning-dwoo-step-by-step-variables/"/>
    <updated>2015-04-23T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-04-23-learning-dwoo-step-by-step-variables/</id>
    <content type="html">&lt;p&gt;##迭代器变量&lt;/p&gt;
&lt;p&gt;###变量&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;first (bool) : 如果元素是第一个，则为true，否则为false&lt;/li&gt;
&lt;li&gt;last (bool) : 如果元素是最后一个，则为true，否则为false&lt;/li&gt;
&lt;li&gt;index (int) : 索引数字(从0开始计数，每次迭代增加1)&lt;/li&gt;
&lt;li&gt;iteration (int) : 迭代次数 (从1开始计数，每次迭代过程增加1)&lt;/li&gt;
&lt;li&gt;show (bool) : 如果loop循环会输出东西，则为true，否则为false&lt;/li&gt;
&lt;li&gt;total (int) : 数组的元素个数总数&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;###说明&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;你可以通过&lt;code&gt;{$dwoo.&amp;lt;plugin (foreach, loop or for)&amp;gt;.&amp;lt;foreach name&amp;gt;.&amp;lt;var&amp;gt;}&lt;/code&gt;访问它们&lt;/li&gt;
&lt;li&gt;如果你没有为插件提供名字参数，它默认会使用&amp;quot;default&amp;quot;，这意味着你可以这样访问一个foreach变量：&lt;code&gt;{$dwoo.foreach.default.first}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;$dwoo变量可以被简写为$，那就是说，&lt;code&gt;{$.foreach.default.first}&lt;/code&gt;也是可以运行的&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;###例子&lt;/p&gt;
&lt;p&gt;{foreach $mArr, key, value, name=&#39;default&#39;}
{if $dwoo.foreach.default.first}
First element
{elseif $dwoo.foreach.default.index == 2}
Second element
{elseif $dwoo.foreach.default.last}
Last element
{/if}
{/foreach}&lt;/p&gt;
&lt;p&gt;#Dwoo变量
Dwoo变量的名字仅限于&lt;code&gt;/[a-z0-9_]/i&lt;/code&gt;，那就是说仅限于所有的字母数字字符加上下划线，它们区分大小写的。&lt;/p&gt;
&lt;p&gt;作为提醒，我强烈建议你使用下划线&#39;_&#39;开始的变量因为当我需要魔法变量的时候我会使用例如&lt;code&gt;$_foo&lt;/code&gt;的命名变量，这样的话所有人就避免了坏的情况。&lt;/p&gt;
&lt;p&gt;###下面的是保留变量：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;$dwoo&lt;/li&gt;
&lt;li&gt;$dwoo.parent&lt;/li&gt;
&lt;li&gt;$_key&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;###检索作用域变量
你可以在PHP端检索模板的作用域变量。例如：&lt;/p&gt;
&lt;p&gt;...
$dwoo-&amp;gt;get($tpl, $data);
var_dump($dwoo-&amp;gt;getScope()); // 会返回包含所有作用于变量的数组&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：include文件得到的作用域变量也是这样的方式返回。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##快捷方式&lt;/p&gt;
&lt;p&gt;在下面的所有例子中，FOO是你需要展示的变量名。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{ %FOO } = {$dwoo.const.FOO}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{$.FOO} = {$dwoo.FOO}, i.e. for a {$.get.user_id} = {$dwoo.get.user_id}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{$} = 当前作用域&lt;/code&gt;, 刚开始它表示全部模板数据，但如果你使用with或者loop改变其作用域的话它的值就会随着改变&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{$_} = {$_parent}&lt;/code&gt;, 这是父作用域，在模板数据中比当前作用域高一个级别&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{$_._._}&lt;/code&gt; 作为 &lt;code&gt;{$_parent._parent._parent}&lt;/code&gt; 运行&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{$__} = {$_root}&lt;/code&gt;, 这是最高级别的作用域，会一直等于全部模板数据&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{/} = closes&lt;/code&gt; 最后一个打开的块&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>一步步学习Dwoo模板引擎--后台开发者使用</title>
    <link href="https://hoohack.me/blog/2015/2015-04-23-learning-dwoo-step-by-step-dwoo-for-developer/"/>
    <updated>2015-04-23T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-04-23-learning-dwoo-step-by-step-dwoo-for-developer/</id>
    <content type="html">&lt;p&gt;##基本使用&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
// 引入主要的类和注册autoloader类(它会自己处理接下来的事情)
require &#39;lib/Dwoo/Autoloader.php&#39;;
&#92;Dwoo&#92;Autoloader::register();&lt;/p&gt;
&lt;p&gt;// 创建一个Dwoo对象
$dwoo = new &#92;Dwoo&#92;Core();&lt;/p&gt;
&lt;p&gt;// 创建一些数据
$data = array(&#39;a&#39;=&amp;gt;5, &#39;b&#39;=&amp;gt;6);&lt;/p&gt;
&lt;p&gt;// 输出结果...
$dwoo-&amp;gt;output(&#39;path/to/index.tpl&#39;, $data);
// ... 或者获得结果
echo $dwoo-&amp;gt;get(&#39;path/to/index.tpl&#39;, $data);&lt;/p&gt;
&lt;p&gt;##文件以及数据对象&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
require &#39;lib/Dwoo/Autoloader.php&#39;;
&#92;Dwoo&#92;Autoloader::register();&lt;/p&gt;
&lt;p&gt;$dwoo = new &#92;Dwoo&#92;Core();&lt;/p&gt;
&lt;p&gt;// 加载模板文件，如果你想使用不同数据多次渲染一个模板文件可以重复使用这句
$tpl = new &#92;Dwoo&#92;Template&#92;File(&#39;path/to/index.tpl&#39;);&lt;/p&gt;
&lt;p&gt;// 创建一个数据集合，如果你想渲染多个可以被这个集合填充的模板的话可以重复使用这个数据集合
$data = new &#92;Dwoo&#92;Data();&lt;/p&gt;
&lt;p&gt;// 赋值
$data-&amp;gt;assign(&#39;foo&#39;, &#39;BAR&#39;);
$data-&amp;gt;assign(&#39;bar&#39;, &#39;BAZ&#39;);&lt;/p&gt;
&lt;p&gt;// 输出结果
$dwoo-&amp;gt;output($tpl, $data);
// ... 或者获得它们的值
echo $dwoo-&amp;gt;get($tpl, $data);&lt;/p&gt;
&lt;p&gt;##编译对象&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
require &#39;lib/Dwoo/Autoloader.php&#39;;
&#92;Dwoo&#92;Autoloader::register();&lt;/p&gt;
&lt;p&gt;$dwoo = new &#92;Dwoo&#92;Core();
$tpl = new &#92;Dwoo&#92;Template&#92;File(&#39;path/to/index.tpl&#39;);
$data = array(&#39;a&#39; =&amp;gt; 5, &#39;b&#39; =&amp;gt; 6);&lt;/p&gt;
&lt;p&gt;// 实例化一个编译类
$compiler = new &#92;Dwoo&#92;Compiler();
// 增加一个插件目录的预处理器
$compiler-&amp;gt;addPreProcessor(&#39;Processor_Name&#39;, true);
// 或者使用你的过滤器
$compiler-&amp;gt;addPreProcessor(&#39;Processor_Function_Name&#39;);&lt;/p&gt;
&lt;p&gt;// 输出结果，提供给编译器使用
$dwoo-&amp;gt;output($tpl, $data, $compiler);&lt;/p&gt;
&lt;p&gt;##设置目录
学习一下怎么使用&lt;code&gt;setCompileDir&lt;/code&gt;和&lt;code&gt;setTemplateDir&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
require &#39;lib/Dwoo/Autoloader.php&#39;;
&#92;Dwoo&#92;Autoloader::register();&lt;/p&gt;
&lt;p&gt;$dwoo = new &#92;Dwoo&#92;Core();&lt;/p&gt;
&lt;p&gt;// 配置目录
$dwoo-&amp;gt;setCompileDir(&#39;path/to/compiled/dir/&#39;); // 保存编译模板的目录
$dwoo-&amp;gt;setTemplateDir(&#39;path/to/your/template/dir/&#39;); // 保存.tpl文件&lt;/p&gt;
&lt;p&gt;$data = array(&#39;a&#39;=&amp;gt;5, &#39;b&#39;=&amp;gt;6);&lt;/p&gt;
&lt;p&gt;$dwoo-&amp;gt;output(&#39;index.tpl&#39;, $data);
echo $dwoo-&amp;gt;get(&#39;index.tpl&#39;, $data);&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>一步步学习Dwoo模板引擎--前端使用</title>
    <link href="https://hoohack.me/blog/2015/2015-04-23-learning-dwoo-step-by-step-dwoo-for-designers/"/>
    <updated>2015-04-23T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-04-23-learning-dwoo-step-by-step-dwoo-for-designers/</id>
    <content type="html">&lt;p&gt;介绍完如何安装之后，现在来介绍一下前端开发者如何使用Dwoo模板引擎套模板。&lt;/p&gt;
&lt;p&gt;##简介
一个模板，简单地说就是一个文本文件。可以生成任意多种文本格式(HTML、XML、TPL等等)。Dwoo没有确定的文件后缀，.html或者.tpl都可以。&lt;/p&gt;
&lt;p&gt;一个模板包含在模板运行的时候被替换为确定的值的变量和表达式以及控制模板逻辑的标签。&lt;/p&gt;
&lt;p&gt;下面是介绍了一些基础的简易模板。细节的东西稍后附上：&lt;/p&gt;
&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;My Webpage&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;ul id=&amp;quot;navigation&amp;quot;&amp;gt;
{foreach $navigation item}
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;{$item.href}&amp;quot;&amp;gt;{$item.caption}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
{/foreach}
&amp;lt;/ul&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;h1&amp;gt;My Webpage&amp;lt;/h1&amp;gt;
{$a_variable}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/p&gt;
&lt;p&gt;在Dwoo里，只用一种定界符用来定位变量、表达式以及标签。&lt;/p&gt;
&lt;p&gt;##变量
应用程序传送变量到模板，你可以在模板中使用它。变量也许拥有一些你可以访问的属性或者元素。一个变量是怎样的很大程度依赖于应用程序的提供。&lt;/p&gt;
&lt;p&gt;你可以使用下标点(.)来访问PHP变量的属性(PHP对象的方法或者属性、数组的项)，或者被称为下标的标签的&amp;quot;[]&amp;quot;。&lt;/p&gt;
&lt;p&gt;{$foo}
{$foo.bar}
{$foor[&#39;bar&#39;]}&lt;/p&gt;
&lt;p&gt;##全局变量
下面的变量在模板中是一直有效的。&lt;/p&gt;
&lt;p&gt;{$.version} : Dwoo的版本
{$.ad} : dwoo网站的链接
{$.now} : 执行页面的请求时间
{$.charset} : 使用的编码(默认是UTF-8)&lt;/p&gt;
&lt;p&gt;你也可以使用下面的访问方式访问PHP中的全局变量。&lt;/p&gt;
&lt;p&gt;{$.get.m}
{$dwoo.get.m}
{$dwoo.post.x}
{$dwoo.session.x}&lt;/p&gt;
&lt;p&gt;##函数
函数可以被调用来生成内容。函数通过函数名和括号以及可选参数来调用。&lt;/p&gt;
&lt;p&gt;例如date_format函数：&lt;/p&gt;
&lt;p&gt;{date_format &amp;quot;now&amp;quot; &amp;quot;Y-m-j&amp;quot;}&lt;/p&gt;
&lt;p&gt;##命名参数
使用命名参数让你的模板有更明确的意义。&lt;/p&gt;
&lt;p&gt;{date_format value=&amp;quot;now&amp;quot; format&amp;quot;Y-m-j&amp;quot;}
命名参数也允许你跳过一些你不想改变其默认值的参数。&lt;/p&gt;
&lt;p&gt;{date_format format=&amp;quot;m/d/y&amp;quot; timestamp=$.now modify=&amp;quot;+150 day&amp;quot;}&lt;/p&gt;
&lt;p&gt;##注释
如果想在模板中注释一行代码，可以使用这样的语句:&lt;code&gt;{*...*}&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这些注释是Dwoo处理的，而且不像HTML注释一样，它不会被输出到浏览器上。&lt;/p&gt;
&lt;p&gt;这对于调试或增加一些信息给其他前端使用者或者你自己。&lt;/p&gt;
&lt;p&gt;{* This is a Dwoo comment *}&lt;/p&gt;
&lt;p&gt;{*
- This is a multi line
- Dwoo comment!
*}&lt;/p&gt;
&lt;p&gt;{*
This is also a comment
*}&lt;/p&gt;
&lt;p&gt;##引入其他模板
include函数对于引入模板和返回另一个模板的渲染内容到当前模板中十分有用。&lt;/p&gt;
&lt;p&gt;{include(&#39;header.html&#39;)}
有时候也许你需要在不通过Dwoo类的get或output函数来传递数据到页面中就传递参数到其他页面中。下面这个通过作为参数加到函数后面的例子可以实现：&lt;/p&gt;
&lt;p&gt;{include(file=&#39;site_header.tpl&#39; title=&#39;About Us&#39;)}&lt;/p&gt;
&lt;p&gt;##模板继承
Dwoo最强大的部分就是模板继承。模板继承允许你建立一个基于包含了你网站的所有常用元素和定义一些子模板可以重写的模块的模板骨架。&lt;/p&gt;
&lt;p&gt;听起来很复杂但实际上是很简单的。通过使用一个例子学习就能很容易地明白。&lt;/p&gt;
&lt;p&gt;定义一个基础模板:base.html。包含了简单的用于显示两列页面的HTML骨架文本。&lt;/p&gt;
&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;{block &amp;quot;title&amp;quot;}My site name{/block}&amp;lt;/title&amp;gt;
{* css includes, etc. *}
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;{block &amp;quot;page-title&amp;quot;}Default page title{/block}&amp;lt;/h1&amp;gt;
&amp;lt;div id=&amp;quot;content&amp;quot;&amp;gt;
{block &amp;quot;content&amp;quot;}
Welcome to my amazing homepage
{/block}
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
在这个例子里，模块标签定义了四个子模板可以填充的模块。所有的模块标签用来告诉模板引擎子模板可以覆盖模板的这些部分。&lt;/p&gt;
&lt;p&gt;一个字模板可以使这样的：&lt;/p&gt;
&lt;p&gt;{extends &amp;quot;base.html&amp;quot;}&lt;/p&gt;
&lt;p&gt;{block &amp;quot;title&amp;quot;}
Gallery
{/block}
可以使用parent方法来渲染父模块的内容。下面这样会返回父模块的结果：&lt;/p&gt;
&lt;p&gt;{extends &amp;quot;base.html&amp;quot;}&lt;/p&gt;
&lt;p&gt;{block &amp;quot;title&amp;quot;}Home - {$dwoo.parent}{/block}&lt;/p&gt;
&lt;p&gt;##HTML过滤
如果你需要显示HTML的代码，你可以使用escape函数：&lt;/p&gt;
&lt;p&gt;{&amp;quot;some &amp;lt;strong&amp;gt;html&amp;lt;/strong&amp;gt; tags&amp;quot;|escape}
将输出：&lt;/p&gt;
&lt;p&gt;some &amp;lt;strong&amp;gt;html&amp;lt;/strong&amp;gt; tags&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Linux命令chmod学习</title>
    <link href="https://hoohack.me/blog/2015/2015-04-22-linux-command-chmod-learning/"/>
    <updated>2015-04-22T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-04-22-linux-command-chmod-learning/</id>
    <content type="html">&lt;p&gt;chmod命令用得很多，但是有时会忘记此命令的正确用法和一些注意事项。最近用得比较多，总结一下。&lt;/p&gt;
&lt;p&gt;##chmod命令用途
用于改变Linux系统的文件的访问权限。通常用它来控制文件的访问权限，使文件可写或者使文件只允许某些用户进入。&lt;/p&gt;
&lt;p&gt;##Linux系统文件权限介绍
在Linux系统中，一切都是文件。Linux系统中的每个文件都有访问许可权限，用来确定各种用户可以通过哪种访问方式对文件录进行访问和操作。
文件的访问权限分为只读只写和可执行三种。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只读权限表示只允许读取其内容，禁止对其做任何的其他操作。可执行权限表示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;可执行表示允许将该文件作为一个程序执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;可写权限表示可以对文件进行写操作(修改或增加)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##操作文件用户的不同类型&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;owner 文件所有者
group 同组用户
other 其他用户&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每一个文件的访问权限都有三组。每组用三位表示，分别为文件所有者的读、写和执行权限；与文件所有者同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。如果需要查看文件权限的详细信息时，可以使用&lt;code&gt;ls -l&lt;/code&gt;命令。例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/ls-lcommand.png&quot; alt=&quot;ls-l&quot; /&gt;&lt;/p&gt;
&lt;p&gt;确定了一个文件的访问权限后，可以利用Linux系统提供的chmod命令来给文件重新设定不同的访问权限。&lt;/p&gt;
&lt;p&gt;##命令格式&lt;/p&gt;
&lt;p&gt;chmod [-cfvR] [--help] [--version] mode file&lt;/p&gt;
&lt;p&gt;###参数说明&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;-c 当发生改变时，报告处理信息&lt;/li&gt;
&lt;li&gt;-f 错误信息不输出&lt;/li&gt;
&lt;li&gt;-R 处理指定目录以及其子目录下的所有文件&lt;/li&gt;
&lt;li&gt;-v 运行时显示详细处理信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;###权限范围代号
u ：目录或者文件的当前的用户
g ：目录或者文件的当前的群组
o ：除了目录或者文件的当前用户或群组之外的用户或者群组
a ：所有的用户及群组&lt;/p&gt;
&lt;p&gt;###权限代号：
r ：读权限，用数字4表示
w ：写权限，用数字2表示
x ：执行权限，用数字1表示&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;：删除权限，用数字0表示
s ：特殊权限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##chmod命令用法
此命令有两种用法&lt;/p&gt;
&lt;p&gt;###文字设定法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用字母和操作符表达式。如&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;chmod a+x phptest.log #给所有用户添加可执行此文件的权限&lt;/p&gt;
&lt;p&gt;###数字设定法
数字表示的属性的含义：0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限，然后将其相加。数字属性是3歌0-7的八进制数，对应的用户是u、g、o。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用数字改变文件或目录的权限。如&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;chmod 777 phptest.log #使所有用户可读可写可执行该文件&lt;/p&gt;
&lt;p&gt;##使用实例
###实例1： 增加文件所有用户组可执行权限&lt;/p&gt;
&lt;p&gt;chmod a+x tmp.log&lt;/p&gt;
&lt;p&gt;###实例2：同时修改不同用户权限&lt;/p&gt;
&lt;p&gt;chmod ug+w,o-x log2015.log&lt;/p&gt;
&lt;p&gt;###实例3：删除文件权限&lt;/p&gt;
&lt;p&gt;chmod a-x log2015.log&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>一步步学习Dwoo模板引擎--介绍、安装</title>
    <link href="https://hoohack.me/blog/2015/2015-04-22-learning-dwoo-template-engine-step-by-step-introduction-and-installation/"/>
    <updated>2015-04-22T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-04-22-learning-dwoo-template-engine-step-by-step-introduction-and-installation/</id>
    <content type="html">&lt;p&gt;使用Dwoo模板引擎有一个多月了，网上的中文文档比较少，在这里记录自己学到的相关知识。&lt;/p&gt;
&lt;p&gt;##Dwoo是什么
Dwoo是一款基于PHP5的模板引擎。&lt;/p&gt;
&lt;p&gt;Dwoo来自一个众所周知的，已经越来越老的模板引擎--Smarty。&lt;/p&gt;
&lt;p&gt;随着年龄的增大，Smarty显得越来越重了，有着与新版本不一致的旧特性。作为一个为PHP4写的模板引擎，在某些地方，它的面向对象特征没有利用到PHP5更多的高级特性。&lt;/p&gt;
&lt;p&gt;因此Dwoo就诞生了，为了提供一个更新更强壮的引擎。&lt;/p&gt;
&lt;p&gt;自从发布以来，已被证实它在很多地方都比Smarty更快，而且它提供了一个兼容层来让使用了多年Smarty的开发者逐步地过渡到Dwoo。&lt;/p&gt;
&lt;p&gt;Dwoo2嵌入了PHP的新特性，比如：Namespaces,CamelCase等等...因此Dwoo2需要PHP5.3或以上的版本才能运行。&lt;/p&gt;
&lt;p&gt;##安装Dwoo&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、使用composer是最简单地方法。在&lt;a href=&quot;https://hoohack.me/blog/2015/2015-04-22-learning-dwoo-template-engine-step-by-step-introduction-and-installation/packagist.org&quot;&gt;https://packagist.org/packages/dwoo/dwoo&lt;/a&gt;也可以找到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、也可以使用Dwoo的PHAR包。&lt;/p&gt;
&lt;p&gt;##使用&lt;/p&gt;
&lt;p&gt;###Autoload&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
// Include autoloader
require &#39;lib/Dwoo/Autoloader.php&#39;;&lt;/p&gt;
&lt;p&gt;// Register Dwoo namespace and register autoloader
$autoloader = new Dwoo&#92;Autoloader();
$autoloader-&amp;gt;add(&#39;Dwoo&#39;, &#39;lib/Dwoo&#39;);
$autoloader-&amp;gt;register(true);&lt;/p&gt;
&lt;p&gt;// Create the controller, it is reusable and can render multiple templates
$dwoo = new Dwoo&#92;Core();&lt;/p&gt;
&lt;p&gt;// Create some data
$data = array(&#39;a&#39;=&amp;gt;5, &#39;b&#39;=&amp;gt;6);&lt;/p&gt;
&lt;p&gt;// Output the result directly ...
$dwoo-&amp;gt;output(&#39;path/to/index.tpl&#39;, $data);
// ... or get it to use it somewhere else
$var = $dwoo-&amp;gt;get(&#39;path/to/index.tpl&#39;, $data);
echo $var;&lt;/p&gt;
&lt;p&gt;###使用PHAR&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
// Include phar archive, not need to call autoloader anymore
require &#39;phar://dwoo.phar&#39;;&lt;/p&gt;
&lt;p&gt;// Create the controller, it is reusable and can render multiple templates
$dwoo = new Dwoo&#92;Core();&lt;/p&gt;
&lt;p&gt;// Create some data
$data = array(&#39;a&#39;=&amp;gt;5, &#39;b&#39;=&amp;gt;6);&lt;/p&gt;
&lt;p&gt;// Output the result directly ...
$dwoo-&amp;gt;output(&#39;path/to/index.tpl&#39;, $data);
// ... or get it to use it somewhere else
$var = $dwoo-&amp;gt;get(&#39;path/to/index.tpl&#39;, $data);
echo $var;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>PHP面试题总结</title>
    <link href="https://hoohack.me/blog/2015/2015-04-01-php-interview-questions-set/"/>
    <updated>2015-04-01T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-04-01-php-interview-questions-set/</id>
    <content type="html">&lt;p&gt;去年校园招聘的时候自己准备了挺久的，其中在PHP开发这个岗位上做的准备工作比较多，今天整理自己的印象笔记，发现当时收集了很多资料，在这里整理一下，帮助自己回顾一些基础知识，同时也分享给有需要的人。&lt;/p&gt;
&lt;p&gt;##Q:用PHP打印出前一天的时间,格式是2014-5-10 19:20:21&lt;/p&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;p&gt;echo date(&#39;Y-m-d H:i:s&#39;, strtotime(&amp;quot;-1 day&amp;quot;));//method 1
echo date(&#39;Y-m-d H:i:s&#39;, time() - 60&lt;em&gt;60&lt;/em&gt;24);//method 2&lt;/p&gt;
&lt;p&gt;##Q:echo(),print,print_r()的区别&lt;/p&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;echo是语言结构，无返回值;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;print的功能和echo基本相同，不同的是print是函数，有返回值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;print_r是递归打印，用于输出数组或对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##Q:用PHP写出显示客户端IP与服务器IP的代码&lt;/p&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;p&gt;$ip=gethostbyname (&amp;quot;&amp;quot;);
echo $ip;&lt;/p&gt;
&lt;p&gt;//获取真实IP
function getIp() {
static $realip;
if (isset($_SERVER)) {
if (isset($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;])) {
$realip = $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;];
} else if (isset($_SERVER[&#39;HTTP_CLIENT_IP&#39;])) {
$realip = $_SERVER[&#39;HTTP_CLIENT_IP&#39;];
} else {
$realip = $_SERVER[&#39;REMOTE_ADDR&#39;];
}
} else {
if (getenv(&#39;HTTP_X_FORWARDED_FOR&#39;)) {
$realip = getenv(&#39;HTTP_X_FORWARDED_FOR&#39;);
} else if (getenv(&#39;HTTP_CLIENT_IP&#39;)) {
$realip = getenv(&#39;HTTP_CLIENT_IP&#39;);
} else {
$realip = getenv(&#39;REMOTE_ADDR&#39;);
}
}
return $realip;
}
echo getIP();&lt;/p&gt;
&lt;p&gt;##Q:foo() 与 @foo() 有什么分别？&lt;/p&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;foo() 会执行这个函式，任何解译错误、语法错误、执行错误都会在页面上显示出来。
@foo() 在执行这个函式时，会隐藏所有上述的错误讯息。
很多应用程式都使用 @mysql_connect() 和 @mysql_query 来隐藏 mysql 的错误讯息，我这其实是很严重的失误，因为错误不该被隐藏，必须妥善处理它们，可能的话解决它们。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##Q:&amp;quot;===&amp;quot;是什么？试举一个&amp;quot;==&amp;quot;是真但&amp;quot;===&amp;quot;是假的例子。&lt;/p&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“===”是给既可以送回布尔值“假”，也可以送回一个不是布尔值但却可以赋与“假”值的函式，strpos() 和 strrpos() 便是其中两个例子。
例子：
if (strpos(“abc”, “a”) == true){ // 这部分永不会被执行，因为 “a” 的位置是 0，换算成布尔值“假”}if (strpos(“abc”, “a”) === true){ // 这部份会被执行，因为“===”保证函式 strpos() 的送回值不会换算成布尔值.}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##Q:哪一个函数可以把浏览器转向到另一个页面？&lt;/p&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;header() 可以用来使浏览器转向到另一个页面，例如：
&lt;code&gt;header(“Location: https://www.hoohack.me/”);&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##Q:include 和 include_once 、require 和 require_once有什么分别？&lt;/p&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.hoohack.me/2015/01/10/php-require-include-require_once-include_once/&quot;&gt;&lt;code&gt;PHP中require、include、require_once和include_once的区别&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;##Q:mysql_fetch_row() 和 mysql_fetch_array() 有什么分别？&lt;/p&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mysql_fetch_row()把数据库的一行数据存储在一个以零为基数的阵列中，第一栏在阵列的索引 0，第二栏在索引 1，如此类推。
mysql_fetch_assoc() 把数据库的一行数据储存在一个关联阵列中，阵列的索引就是栏位名称，例如我的数据库查询送回“first_name”、“last_name”、“email”三个栏位，阵列的索引便是“first_name”、“last_name”和“email”。
mysql_fetch_array() 可以同时送回 mysql_fetch_row() 和 mysql_fetch_assoc() 的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##Q:PHP中哪一个函数可以用来开启档案以便读/写&lt;/p&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;fopen()这是正确答案，fopen() 可以用来开启档案以便读/写&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##Q:sort()、asort()、arsort和 ksort() 有什么分别？它们分别在什么情况下使用？&lt;/p&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;p&gt;sort() 函数用于对数组单元从低到高进行排序，如果成功则返回 TRUE，失败则返回 FALSE。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：本函数会为排序的数组中的单元赋予新的键名，这将删除原有的键名而不仅是重新排序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;asort() 函数用于对数组单元从低到高进行排序并保持索引关系，如果成功则返回 TRUE，失败则返回 FALSE。&lt;/p&gt;
&lt;p&gt;ksort() 函数用于对数组单元按照键名从低到高进行排序，如果成功则返回 TRUE，失败则返回 FALSE。
本函数会保留原来的键名，因此常用于关联数组。&lt;/p&gt;
&lt;p&gt;arsort() 函数行为与 asort() 相反，对数组单元进行由高到低排序并保持索引关系&lt;/p&gt;
&lt;p&gt;##Q:写出一个正则表达式，过虑网页上的所有JS脚本（即把script标记及其内容都去掉）&lt;/p&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;p&gt;echo preg_replace(&amp;quot;/].&lt;em&gt;?&amp;gt;.&lt;/em&gt;?/si&amp;quot;, &amp;quot;&amp;quot;, $script);&lt;/p&gt;
&lt;p&gt;##Q:php://input和$_POST有什么区别&lt;/p&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;p&gt;首先当&lt;code&gt;$_POST&lt;/code&gt;与&lt;code&gt;php://input&lt;/code&gt;可以取到值时$HTTP_RAW_POST_DATA 为空;
$HTTP_RAW_POST_DATA是PHP内置的一个全局变量。它用于，PHP在无法识别的Content-Type的情况下，将POST过来的数据原样地填入变量$HTTP_RAW_POST_DATA。它同样无法读取Content-Type为multipart/form-data的POST数据。需要设置php.ini中的always_populate_raw_post_data值为On，PHP才会总把POST数据填入变量$HTTP_RAW_POST_DATA。&lt;/p&gt;
&lt;p&gt;然后$_POST以关联数组方式组织提交的数据，并对此进行编码处理，如urldecode，甚至编码转换;
而php://input 通过输入流以文件读取方式取得未经处理的POST原始数据;&lt;/p&gt;
&lt;p&gt;php://input 允许读取 POST 的原始数据。和 $HTTP_RAW_POST_DATA 比起来，它给内存带来的压力较小，并且不需要任何特殊的 php.ini 设置。php://input 不能用于enctype=&amp;quot;multipart/form-data&amp;quot;;的情况。&lt;/p&gt;
&lt;p&gt;php://input读取不到&lt;code&gt;$_GET&lt;/code&gt;数组的数据。是因为&lt;code&gt;$_GET&lt;/code&gt;数据作为query_path写在http请求头部(header)的PATH字段，而不是写在http请求的body部分。&lt;/p&gt;
&lt;p&gt;##Q:禁用COOKIE 后 SEESION 还能用吗?&lt;/p&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;p&gt;session是在服务器端保持用户会话数据的一种方法，对应的cookie是在客户端保持用户数据。HTTP协议是一种无状态协议，服务器响应完之后就失去了与浏览器的联系，最早，Netscape将cookie引入浏览器，使得数据可以客户端跨页面交换，那么服务器是如何记住众多用户的会话数据呢？
首先要将客户端和服务器端建立一一联系，每个客户端都得有一个唯一标识，这样服务器才能识别出来。建议唯一标识的方法有两种：cookie或者通过GET方式指定。默认配置的PHP使用session的时会建立一个名叫”PHPSESSID”的cookie（可以通过php.ini修改session.name值指定），如果客户端禁用cookie,你也可以指定通过GET方式把session id传到服务器（修改php.ini中session.use_trans_sid等参数）。&lt;code&gt;&amp;lt;a href=”p.php?&amp;lt;?php print session_name() ?&amp;gt;=&amp;lt;?php print session_id() ?&amp;gt;”&amp;gt;xxx&amp;lt;/a&amp;gt;&lt;/code&gt;,也可以通过POST来传递session值.&lt;/p&gt;
&lt;p&gt;##Q:error_reporting(2047)什么作用&lt;/p&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;p&gt;相当于 error_reporting(&#39;E_ALL&#39;); 输出所有的错误。&lt;/p&gt;
&lt;p&gt;##Q:请写一个函数，实现以下功能：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;字符串&amp;quot;open_door&amp;quot;转换成 &amp;quot;OpenDoor&amp;quot;、&amp;quot;make_by_id&amp;quot; 转换成&amp;quot;MakeById&amp;quot;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;p&gt;function str_change($str) {
$str = str_replace ( &amp;quot;_&amp;quot;, &amp;quot; &amp;quot;, $str );
$str = ucwords ( $str );
$str = str_replace ( &amp;quot; &amp;quot;, &amp;quot;&amp;quot;, $str );
return $str;
}&lt;/p&gt;
&lt;p&gt;##Q:不用新变量直接交换现有两个变量的值&lt;/p&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;p&gt;list($a,$b)=array($b,$a);//1
a=a+b,b=a-b,a=a-b;//2&lt;/p&gt;
&lt;p&gt;##Q:一个函数的参数不能是对变量的引用，除非在php.ini中把?设为on&lt;/p&gt;
&lt;p&gt;allow_call_time_pass_reference boolean //是否启用在函数调用时强制参数被按照引用传递&lt;/p&gt;
&lt;p&gt;##Q:PHP的垃圾收集机制是怎样的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PHP作为脚本语言是页面结束即释放变量所占内存的。 当一个 PHP线程结束时，当前占用的所有内存空间都会被销毁，当前程序中所有对象同时被销毁。GC进程一般都跟着每起一个SESSION而开始运行的.
gc目的是为了在session文件过期以后自动销毁删除这些文件. 在PHP中，没有任何变量指向这个对象时，这个对象就成为垃圾。PHP会将其在内存中销毁；这是PHP 的GC垃圾处理机制，防止内存溢出。
执行这些函数也可以起到回收作用 &lt;code&gt;__destruct&lt;/code&gt; /unset/mysql_close /fclose. php对session有明确的gc处理时间设定 session.gc_maxlifetime 如果说有垃圾，那就是整体的程序在框架使用中，
会多次调用同一文件等等造成的非单件模式等。所以在出来的时候，必要的用_once 引用，在声明类的时候使用单件模式。还有简化逻辑等等。而如果妄想让PHP自己本身管理内存，进行垃圾管理。
呵呵。好像PHP还办不到，对于析构函数，ANDI在他的书里写的很明白。可有可无，不可置否。而内存管理的东西一般都是桌面程序更多去考虑的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;To be continue...&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>[LeetCode]字符翻转--多种解法分析</title>
    <link href="https://hoohack.me/blog/2015/2015-03-28-rotate-array-algorithm-Analysis/"/>
    <updated>2015-03-28T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-03-28-rotate-array-algorithm-Analysis/</id>
    <content type="html">&lt;p&gt;最近在LeetCode网站上学习算法，记录一下学到的东西。&lt;/p&gt;
&lt;p&gt;##问题描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Rotate an array of n elements to the right by k steps.&lt;/p&gt;
&lt;p&gt;For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].&lt;/p&gt;
&lt;p&gt;Note:
Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##解法一：一个一个地移动
刚开始看到这道题，题目说有很多种解法，当时我的第一个想法就是一个一个地移动。于是就有下面的解法：&lt;/p&gt;
&lt;p&gt;void rotate(int nums[], int n, int k) {
int cursor = 0;
for (int i = 0; i &amp;lt; k; ++i) {
cursor = nums[n - 1];
for (int j = 0; j &amp;lt; n - 1; ++j) {
nums[n-j-1] = nums[n-j-2];
}
nums[0] = cursor;
}
}&lt;/p&gt;
&lt;p&gt;这个算法的时间复杂度是O(n*k)，空间复杂度是O(1)。提交的时候超时了，So，不能用这种方法。&lt;/p&gt;
&lt;p&gt;##解法二：杂耍算法
这个算法是比较难想到的，这个算法优点是在执行了GCD(n, k)次后即可停止，程序的走向我是明白的，至于为什么能够如此，还是上网查了很多资料才弄明白了，现在通过自己的语言描述一遍。加深理解。&lt;/p&gt;
&lt;p&gt;GCD(Greatest Common Divisor)--最大公约数&lt;/p&gt;
&lt;p&gt;###辗转相除法求最大公约数。
两个整数的最大公约数是能够同时整除它们的最大的正整数。辗转相除法基于以下原理&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;两个整数的最大公约数等于其中较小的数和两数的差的最大公约数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先来了解一些数论知识（以下内容摘自《初等数论》，潘承洞著）：&lt;/p&gt;
&lt;p&gt;####同余&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设m不等于0, 若&lt;code&gt;m|a-b&lt;/code&gt;,即&lt;code&gt;a-b=km&lt;/code&gt;, 则称m为模，a同余于b模m，以及b是a对模m的剩余。记作&lt;code&gt;a≡b(mod m)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;####同余类&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对给定的模m，有且恰有m个不同的模m的同余类，他们是
0 mod m，1 mod m，…，（m-1）mod m。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;####完全剩余系&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一组数y1,y2,…，ys称为是模m的完全剩余系，如果对任意的a有且仅有一个yj是a对模m的剩余，即a同余于yj模m。
由此可见0,1,2，…，m-1是一个完全剩余系。因此，如果m个数是两两不同余的，那么这m个数便是完全剩余系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基于以上知识，我们可以证明这样一个事实，即如果i和n互质的话，那么序列：
&lt;code&gt;0     i mod n  2i mod n       3i mod n       ….   (n-1)*i mod n&lt;/code&gt;
就包括了集合{0,1,2 … n-1}的所有元素。（下一个元素(n)*i mod n 又是0）
为什么呢？&lt;/p&gt;
&lt;p&gt;证明：
由于0,1,2，…，n-1本身是一个完全剩余系，即它们两两互不同余。设此序列为Xi（0&amp;lt;=i&amp;lt;=n-1），可得下式：
Xi≠Xj (mod n)
&lt;code&gt;注：这里由于不能打出不同余字符因此用不等于替代&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;由于i与n是互质的，所以
Xi&lt;em&gt;i ≠i&lt;/em&gt;Xj (mod n)
因此i*Xi是m个互不同余数，那么可断定它们是完全剩余系。得证。&lt;/p&gt;
&lt;p&gt;有了上面的结论，那么，如果n与k互质，下面的赋值过程就能完成所有值的赋值(设数组为X[0...n-1],长度为n)：
t = X[0]&lt;/p&gt;
&lt;p&gt;X[0] = X[i mod n]&lt;/p&gt;
&lt;p&gt;X[i mod n] = X[2i mod n]&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;X[(n-2)*i mod n] = X[(n-1)*i mod n]&lt;/p&gt;
&lt;p&gt;X[(n-1)*i mod n] = t&lt;/p&gt;
&lt;p&gt;以上操作已经把包括{0,1,…,n-1}所有元素放到了最终位置上，每次完成一个元素的放置。
根据以上我们得到了一个中间结论，如果n和k互质，我们就可以一次完成所有元素的纺织。那么如果n和k不是互质的呢？&lt;/p&gt;
&lt;p&gt;那就是让n和k互质。即让k&#39;=k/gcd(k, n),n&#39;=n/gcd(k,n)。这样就构成了一对互质的数。这就意味着需要把整个数组的每g(g=gcd(k,n))个元素组成块，每个块的k&#39;和n&#39;就互质了。每次相当于把g中的一个元素移到最终的位置，由于g是块元素，每个块含有g个元素，所以总共需要g次移动。&lt;/p&gt;
&lt;p&gt;int gcd(int m, int n) {
if (m % n == 0)
{
return n;
}
else
{
return gcd(n, m%n);
}
}&lt;/p&gt;
&lt;p&gt;void rotate(int nums[], int n, int k)
{
if (k &amp;gt; n) {
k %= n;
}
if (k % n == 0) return;
int count = gcd(n, k);
for(int j = 0; j &amp;lt; count;j++) {
int temp = nums[n - j - 1];
int current = n - j - 1;
int previous = (current - k) % n;
for (;previous != n - j - 1;previous = (previous - k + n) % n) {
nums[current] = nums[previous];
current = previous;
}
previous = (previous + k) % n;
nums[previous] = temp;
}
}&lt;/p&gt;
&lt;p&gt;##解法三 以n-k为界，分别对数组的两边进行逆置，然后再对整个数组进行一次逆置
这个算法的实现原理我能理解，但是为什么要这样做呢？推导过程是从以结果为导向来推导。&lt;/p&gt;
&lt;p&gt;以数组arr[5] = {1, 2, 3, 4, 5};为例。&lt;/p&gt;
&lt;p&gt;如果n=5，k=2，则旋转结果为{4, 5, 1, 2, 3}&lt;/p&gt;
&lt;p&gt;看上去很像整个数组的逆置{5, 4, 3, 2, 1}&lt;/p&gt;
&lt;p&gt;但是还需要变换一下才能得到想要的结果：&lt;/p&gt;
&lt;p&gt;发现如果将前面(0,k)和后面(k,n)的两部分分别逆置之后就会得到最终的结果。&lt;/p&gt;
&lt;p&gt;即&lt;/p&gt;
&lt;p&gt;{5, 4} =&amp;gt; {4, 5}&lt;/p&gt;
&lt;p&gt;{1, 2, 3} =&amp;gt; {3, 2, 1}&lt;/p&gt;
&lt;p&gt;于是就有了先将数组前后两部分逆置，然后再将整个数组逆置的解法。&lt;/p&gt;
&lt;p&gt;void swap(int arr[], int a, int b) {
int temp = arr[a];
arr[a] = arr[b];
arr[b] = temp;
}&lt;/p&gt;
&lt;p&gt;void reverse(int arr[], int begin, int end)
{
int mid = (begin + end) / 2;
for (int i = begin, j = 0; i &amp;lt; mid; i++, ++j) {
swap(arr, i, end - j - 1);
}
}&lt;/p&gt;
&lt;p&gt;void rotate(int nums[], int n, int k)
{
if (k &amp;gt;= n) k %= n;
reverse(nums, 0, n - k);
reverse(nums, n - k, n);
reverse(nums, 0, n);
}&lt;/p&gt;
&lt;p&gt;也可以先逆置整个数组，然后在逆置前后两部分。&lt;/p&gt;
&lt;p&gt;##解法四 开辟新空间
这个解法就是开辟一个新的空间p保存需要移动的值，然后将原数组移动k位，最后在将p中的值插入到原数组中。&lt;/p&gt;
&lt;p&gt;void rotate(int nums[], int n, int k) {
if (k &amp;gt;= n) {
k = k % n;
}&lt;/p&gt;
&lt;p&gt;int *p = new int[k];
for (int i = 0; i &amp;lt; k; ++i) {
p[i] = nums[n - k + i];
}
for (int j = 0; j &amp;lt; n - k; ++j) {
nums[n - j - 1] = nums[n - k - j - 1];
}
for (int i = 0; i &amp;lt; k; ++i) {
nums[i] = p[i];
}
}&lt;/p&gt;
&lt;p&gt;记录下自己的分析，如果错误和更多建议，欢迎指出。谢谢阅读。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>关于朋友的一些想法</title>
    <link href="https://hoohack.me/blog/2015/2015-03-27-some-thoughts-about-friend/"/>
    <updated>2015-03-27T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-03-27-some-thoughts-about-friend/</id>
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;朋友，我当你一世朋友。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我比较喜欢交朋友，一旦交了朋友之后，我就会把他当做最好的朋友来看待，会想跟他分享我自己的一切，包括生活和自己的想法。&lt;/p&gt;
&lt;p&gt;但是，随着年龄的长大，一些玩得很好的朋友有时候会突然间就变得陌生了，没有了任何联系。有时候会很纳闷究竟发生了什么事情导致这样的结果。也会感到忧伤和怀念，很想拥有一种魔法可以让一切恢复原样。但是我知道那是不可能的。其实朋友之间也是需要一定的距离吧，如果每时每刻都在一起生活，那么彼此的缺点就会暴露地更多更充分。此时，如果彼此之间接受不了彼此的缺点，那么渐渐地就会产生各种误会。然后感情就开始变质。也许这就是朋友之间突然变了的原因吧。&lt;/p&gt;
&lt;p&gt;有时候，因为工作或者其他原因，很长时间无法与昔日的好友进行联系。久而久之感情也会变淡的，因为在你没联系你朋友的那段时间，他也有他的生活，他也有他的圈子，他所在的环境也会慢慢地改变他。很多时候，如果你突然间就去一个很久没联系的朋友，会发现眼前的他就像一个陌生人，完全聊不上了，能聊的只是几句冷漠的寒暄。也许有句话说得很好“相见不如怀念”。与其面对相见时的尴尬，倒不如独自静静怀念昔日的感情。在心中的东西是不会变化的。&lt;/p&gt;
&lt;p&gt;偶尔我会很苦恼朋友少了，也许是因为内心的一些恐惧，一丝担心、一丝不自信。&lt;/p&gt;
&lt;p&gt;其实，在人生道路的不同期间，都有不同的圈子，不同的环境。离开一个地方，到达一个新的地方，你会遇见一群新的朋友，再到另一个地方，你又会遇见另一群新的朋友。久而久之。自然你的圈子会有所改变。以前的圈子，能给你一丝安全感，是因为当时你从内心觉得自己有朋友了，觉得当时的生活还不错。但是现在到了一个新的环境，身边的人突然变了，你觉得身边的人都很陌生，你感到伤感。但这其实不是伤感，而是一种怀念，是向往。这种怀念和向往，都是对未来的担心和对现在的不满意。给一个时间自己，静下来，仔细看看自己的内心，看看你到底需要什么？你在依赖什么？你又在恐惧什么？当下的你是否珍惜你现在所拥有的一切？&lt;/p&gt;
&lt;p&gt;以上只是一些感想，并没有别的意思。毕竟，朋友还是很重要的。好好珍惜你现在的朋友。愿天下友谊长存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/aboutfriend1.jpg&quot; alt=&quot;hello_friend&quot; /&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Redis常用命令</title>
    <link href="https://hoohack.me/blog/2015/2015-03-23-redis-common-command/"/>
    <updated>2015-03-23T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-03-23-redis-common-command/</id>
    <content type="html">&lt;p&gt;##Redis常用命令&lt;/p&gt;
&lt;p&gt;###SET 建立一个名为mykey的键，设置其键值为2
127.0.0.1:6379&amp;gt;set mykey 2&lt;/p&gt;
&lt;p&gt;OK&lt;/p&gt;
&lt;p&gt;###KEYS 获取Redis所有键(当前库只有一个键)
127.0.0.1:6379&amp;gt;KEYS *&lt;/p&gt;
&lt;p&gt;1)&amp;quot;mykey&amp;quot;&lt;/p&gt;
&lt;p&gt;注：KEYS * 会遍历Redis中所有键，当键的数量多时会影响性能，不建议在生产环境使用。&lt;/p&gt;
&lt;p&gt;###EXISTS 判断一个键是否存在
127.0.0.1:6379&amp;gt;EXISTS mykey&lt;/p&gt;
&lt;p&gt;(integer)1&lt;/p&gt;
&lt;p&gt;如果键存在则返回整数类型1，否则返回0&lt;/p&gt;
&lt;p&gt;127.0.0.1:6379&amp;gt;EXISTS var&lt;/p&gt;
&lt;p&gt;(integer)0&lt;/p&gt;
&lt;p&gt;###DEL 删除键
127.0.0.1:6379&amp;gt;DEL mykey&lt;/p&gt;
&lt;p&gt;(integer)1&lt;/p&gt;
&lt;p&gt;127.0.0.1:6379&amp;gt;DEL mykey&lt;/p&gt;
&lt;p&gt;(integer)0&lt;/p&gt;
&lt;p&gt;返回值是删除的键的个数。第二次执行DEL命令是因为bar键被删除了，实际上并没有删除任何键，所以返回值是0。&lt;/p&gt;
&lt;p&gt;###TYPE 获得键值的数据类型
127.0.0.1:6379&amp;gt;TYPE mykey&lt;/p&gt;
&lt;p&gt;String&lt;/p&gt;
&lt;p&gt;可能的类型有：string字符串类型、hash散列类型、list列表类型、set集合类型、zset有序集合类型等&lt;/p&gt;
&lt;p&gt;###INCR 递增数字
127.0.0.1:6379&amp;gt;INCR mykey&lt;/p&gt;
&lt;p&gt;(integer)2&lt;/p&gt;
&lt;p&gt;127.0.0.1:6379&amp;gt;INCR mykey&lt;/p&gt;
&lt;p&gt;(integer)3&lt;/p&gt;
&lt;p&gt;###DECR 减少数字
127.0.0.1:6379&amp;gt;DECR mykey
(integer)5&lt;/p&gt;
&lt;p&gt;###APPEND 向尾部增加值
127.0.0.1:6379&amp;gt;APPEND mykey a&lt;/p&gt;
&lt;p&gt;(integer)6&lt;/p&gt;
&lt;p&gt;返回值是追加后字符串的总长度&lt;/p&gt;
&lt;p&gt;###STRLEN 获取字符串长度
127.0.0.1:6379&amp;gt;STRLEN mykey&lt;/p&gt;
&lt;p&gt;(integer)6&lt;/p&gt;
&lt;p&gt;###EXPIRE 设置键的过期时间
在实际开发中经常会遇到一些有时效的数据，如限时优惠活动、连续签到等，过了一定时间就需要删除这些数据。在关系数据库中一般需要额外的一个字段记录到期时间，然后定期检测删除过期数据。
而在Redis中可以使用EXPIRE命令来设置一个键的生存时间，过了生存时间后它会被Redis自动删除。&lt;/p&gt;
&lt;p&gt;127.0.0.1:6379&amp;gt;SET session:12306 uid12306&lt;/p&gt;
&lt;p&gt;OK&lt;/p&gt;
&lt;p&gt;127.0.0.1:6379&amp;gt;EXPIRE session:12306 60&lt;/p&gt;
&lt;p&gt;(integer)1&lt;/p&gt;
&lt;p&gt;设置session:12306键在60s后过期。返回值为1表示设置成功，返回值为0表示设置失败。&lt;/p&gt;
&lt;p&gt;###TTL 查询一个键还有多长的生存时间，也就是多久后会被删除。&lt;/p&gt;
&lt;p&gt;返回值的单位为秒。&lt;/p&gt;
&lt;p&gt;127.0.0.1:6379&amp;gt;SET mykey hello&lt;/p&gt;
&lt;p&gt;OK&lt;/p&gt;
&lt;p&gt;127.0.0.1:6379&amp;gt;EXPIRE mykey 20&lt;/p&gt;
&lt;p&gt;(integer)2&lt;/p&gt;
&lt;p&gt;127.0.0.1:6379&amp;gt;TTL mykey&lt;/p&gt;
&lt;p&gt;(integer)16&lt;/p&gt;
&lt;p&gt;127.0.0.1:6379&amp;gt;TTL mykey&lt;/p&gt;
&lt;p&gt;(integer)2&lt;/p&gt;
&lt;p&gt;127.0.0.1:6379&amp;gt;TTL mykey&lt;/p&gt;
&lt;p&gt;(integer)-2&lt;/p&gt;
&lt;p&gt;随着时间推移，mykey键的生存时间越来越少，20s后mykey键会被删除。当 key 不存在时，返回 -2 。当 key 存在但没有设置剩余生存时间（即该键永久存在）时，返回 -1 。否则，以秒为单位，返回 key 的剩余生存时间。&lt;/p&gt;
&lt;p&gt;###PERSIST 取消键的生存时间设置（即将键恢复为永久）。&lt;/p&gt;
&lt;p&gt;返回1表示成功清除生存时间，否则返回0（即键不存在或者键本来就是永久的）：&lt;/p&gt;
&lt;p&gt;127.0.0.1:6379&amp;gt;SET mykey &amp;quot;hello&amp;quot;&lt;/p&gt;
&lt;p&gt;OK&lt;/p&gt;
&lt;p&gt;127.0.0.1:6379&amp;gt;EXPIRE mykey 20&lt;/p&gt;
&lt;p&gt;(integer)1&lt;/p&gt;
&lt;p&gt;127.0.0.1:6379&amp;gt;PERSIST mykey&lt;/p&gt;
&lt;p&gt;(integer)1&lt;/p&gt;
&lt;p&gt;127.0.0.1:6379&amp;gt;TTL mykey&lt;/p&gt;
&lt;p&gt;(integer)-1&lt;/p&gt;
&lt;p&gt;除了PERSIST命令之外，使用SET命令为键赋值同时也会清除键的生存时间；或者使用对一个已经带有生存时间的键执行EXPIRE命令，新指定的生存时间会取代旧的生存时间。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>在PHP中使用正则表达式去除字符串首尾的空格</title>
    <link href="https://hoohack.me/blog/2015/2015-03-21-php-remove-head-tail-blank/"/>
    <updated>2015-03-21T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-03-21-php-remove-head-tail-blank/</id>
    <content type="html">&lt;p&gt;最近在网上，看到一个有趣的正则表达式如下&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/^(&amp;amp;nbsp;|&#92;s)*|(&amp;amp;nbsp;|&#92;s)*$/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个正则表达式的用途是匹配字符串头或尾含有空格的字符串。&lt;/p&gt;
&lt;p&gt;下面是实现去掉字符串头尾空格的PHP代码&lt;/p&gt;
&lt;p&gt;$str = &amp;quot; dfadad abcasdasdas   &amp;quot;;&lt;br /&gt;
$str = preg_replace(&#39;/^( |&#92;s)&lt;em&gt;|( |&#92;s)&lt;/em&gt;$/&#39;, &#39;&#39;, $str);&lt;br /&gt;
var_dump($str);&lt;/p&gt;
&lt;p&gt;//输出结果如下：
//string &#39;dfadad abcasdasdas&#39; (length=23)&lt;/p&gt;
&lt;p&gt;因为&lt;code&gt;&amp;amp;nbsp;&lt;/code&gt;是空格转义，不是字符串，直接用trim()是去不掉。刚开始看这段代码的时候没有看懂，现在理解了，下面来分析一下这个表达式是如何实现其功能的。&lt;/p&gt;
&lt;p&gt;我将整个正则表达式分为三部分&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1    &lt;code&gt;(&amp;amp;nbsp;|&#92;s)*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2    &lt;code&gt;|&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;3    &lt;code&gt;(&amp;amp;nbsp;|&#92;s)*&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;1和3的括号里面的表达式都是匹配空格的正则，&#39;*&#39;代表0个或多个。1表示以空格开头，3表示已空格结尾。表达式中的2是一个与运算符，那么这个正则表达式的情况就有如下四种：&lt;/p&gt;
&lt;p&gt;A: 0 0&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首尾都没有空格&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;B: 0 1&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以空格结尾的字符串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;C: 1 0&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以空格开头的字符串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;D: 1 1&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;开头和结尾都有空格的字符串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也可以直接从与逻辑的定义去理解，只要有一个为真那么值就为真。&lt;/p&gt;
&lt;p&gt;在这里分享下自己的理解。如有错误之处或更多建议，请指出，谢谢。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Redis初体验--在Window安装Redis和配置PHPRedis扩展</title>
    <link href="https://hoohack.me/blog/2015/2015-03-19-redis-first-experience/"/>
    <updated>2015-03-19T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-03-19-redis-first-experience/</id>
    <content type="html">&lt;p&gt;这两天在学习Redis，刚在Windows下安装好，记录一下安装的过程。&lt;/p&gt;
&lt;p&gt;#Redis是什么?
Redis是完全开源免费的，遵守BSD协议，先进的key-value持久化产品。是一个高性能的key-value数据库。因为值可以是字符串(String)、哈希(Map)、
列表(List)、集合(Sets)和有序集合(Sorted sets)等类型，所以它通常也被称为数据结构服务器。&lt;/p&gt;
&lt;p&gt;你可以在这些数据类型中执行原子性操作，例如在字符串后面追加字符；在哈希表中增加值；增加一个元素到列表中；计算集合的交集，并集和差集；或者取得已排序的集合中的最大值。&lt;/p&gt;
&lt;p&gt;为了得到高效的运行，Redis与内存中的数据集一起运行。根据你的使用情况，为了使其持久化，你可以每次都将数据集导出到硬盘中或者把命令保存到日志文件中。&lt;/p&gt;
&lt;p&gt;Redis也支持简单且易用的主从复制功能。使用不会阻塞主服务器的异步复制以及自动重连。&lt;/p&gt;
&lt;p&gt;其他特性有：使用 check-and-set(CAS)操作实现乐观锁，发布/订阅和配置设置使其像缓存一样运行。&lt;/p&gt;
&lt;p&gt;#Redis的特点&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;支持数据持久化，可以将内存中的数据保存在磁盘，重启Redis可以再次加载使用；&lt;/li&gt;
&lt;li&gt;Redis不仅仅支持简单的key-value类型的数据，同时还支持list，set，hash等数据结构的存储；&lt;/li&gt;
&lt;li&gt;Redis支持类似MySQL的主从备份，即master-slave的数据备份&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;#Redis的优势：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;性能极高-Redis能达到的读的速度是11000次/s，写的速度是81000次/s；&lt;/li&gt;
&lt;li&gt;丰富的数据类型-string(字符串类型)、hash(哈希散列类型)、list(列表类型)、set(集合类型)、zset(有序集合类型);&lt;/li&gt;
&lt;li&gt;原子性-redis执行单个命令是原子性的，但是redis没有对事务进行原子性保护，如果一个事务没有执行成功，是不会进行回滚的；&lt;/li&gt;
&lt;li&gt;Redis运行在内存中，但可持续化到磁盘&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;#安装与配置&lt;/p&gt;
&lt;p&gt;##在windows下安装Redis&lt;/p&gt;
&lt;p&gt;###下载Redis&lt;/p&gt;
&lt;p&gt;官方网站：&lt;a href=&quot;http://redis.io/&quot;&gt;http://redis.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方下载：&lt;a href=&quot;http://redis.io/download&quot;&gt;http://redis.io/download&lt;/a&gt; 可以根据需要下载不同版本&lt;/p&gt;
&lt;p&gt;官网上是没有windows版本的，如果需要在windows下安装redis的话需要到github上下载。&lt;/p&gt;
&lt;p&gt;windows版：&lt;a href=&quot;https://github.com/MSOpenTech/redis&quot;&gt;https://github.com/MSOpenTech/redis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;根据网上的教程，下载完成后解压到硬盘下比如&lt;code&gt;D:&#92;Redis&#92;redis&lt;/code&gt;，在D:&#92;Redis&#92;redis&#92;bin&#92;release下有两个zip包一个32位一个64位，根据自己windows的位数 解压到D:&#92;Redis&#92;redis根目录下。但是我在该目录下找不到相应的压缩文件，于是乎需要另辟蹊径。&lt;/p&gt;
&lt;p&gt;###下载解压软件放在bin目录下(github)&lt;/p&gt;
&lt;p&gt;下载网址：&lt;a href=&quot;https://github.com/ServiceStack/redis-windows&quot;&gt;https://github.com/ServiceStack/redis-windows&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载后解压，可根据相应的版本解压相应的压缩文件到bin目录下&lt;/p&gt;
&lt;p&gt;###测试Redis运行&lt;/p&gt;
&lt;p&gt;打开控制台，进入bin目录，运行&lt;code&gt;redis-server.exe redis-windows.conf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/redis_run.png&quot; alt=&quot;redis-server运行&quot; /&gt;&lt;/p&gt;
&lt;p&gt;###开启Redis Client测试&lt;/p&gt;
&lt;p&gt;打开一个新的控制台，进入bin目录，运行&lt;code&gt;redis-cli.exe&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/redis_client_run.png&quot; alt=&quot;redis-cli运行&quot; /&gt;&lt;/p&gt;
&lt;p&gt;###运行示例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/redis_test.jpg&quot; alt=&quot;redis-test&quot; /&gt;&lt;/p&gt;
&lt;p&gt;##配置PHP-Redis的扩展&lt;/p&gt;
&lt;p&gt;###下载dll文件
本人用的是php5.5.12，网上很多教程中的下载链接都不适合。于是又要另辟蹊径，下面给出链接，根据对应的php版本以及对应的电脑配置下载就行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;php_redis-5.5-vc11-ts-x86-00233a.zip &lt;a href=&quot;http://d-h.st/4A5&quot;&gt;http://d-h.st/4A5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;php_igbinary-5.5-vc11-ts-x86-c35d48.zip &lt;a href=&quot;http://d-h.st/QGH&quot;&gt;http://d-h.st/QGH&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;php_redis-5.5-vc11-nts-x86-00233a.zip &lt;a href=&quot;http://d-h.st/uGS&quot;&gt;http://d-h.st/uGS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;php_igbinary-5.5-vc11-nts-x86-c35d48.zip &lt;a href=&quot;http://d-h.st/bei&quot;&gt;http://d-h.st/bei&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;php_redis-5.5-vc11-ts-x64-00233a.zip &lt;a href=&quot;http://d-h.st/1tO&quot;&gt;http://d-h.st/1tO&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;php_igbinary-5.5-vc11-ts-x64-c35d48.zip &lt;a href=&quot;http://d-h.st/rYb&quot;&gt;http://d-h.st/rYb&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;php_redis-5.5-vc11-nts-x64-00233a.zip &lt;a href=&quot;http://d-h.st/N0d&quot;&gt;http://d-h.st/N0d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;php_igbinary-5.5-vc11-nts-x64-c35d48.zip &lt;a href=&quot;http://d-h.st/c1a&quot;&gt;http://d-h.st/c1a&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看下自己的phpinfo的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/phpversion.png&quot; alt=&quot;php-version&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/zendversion.png&quot; alt=&quot;zend-version&quot; /&gt;&lt;/p&gt;
&lt;p&gt;就选择ts-X64的包来下载&lt;/p&gt;
&lt;p&gt;###添加extension扩展(注意顺序)&lt;/p&gt;
&lt;p&gt;将下载解压后的php_igbinary.dll和php_redis.dll放入php的ext目录下&lt;/p&gt;
&lt;p&gt;然后修改php.ini，加入这两个扩展，注意顺序不要反了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;extension=php_igbinary.dll&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;extension=php_redis.dll&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;添加完之后重启WEBServer，查看phpinfo看到有redis扩展的信息就说明可以了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/php-redis-success.png&quot; alt=&quot;php-redis-success&quot; /&gt;&lt;/p&gt;
&lt;p&gt;###PHP-Redis扩展测试&lt;/p&gt;
&lt;p&gt;PHP-Redis使用示例代码&lt;/p&gt;
&lt;p&gt;$redis = new Redis();
$redis-&amp;gt;connect(&amp;quot;127.0.0.1&amp;quot;, &amp;quot;6379&amp;quot;);  //php客户端设置的ip及端口&lt;/p&gt;
&lt;p&gt;//存储一个值
$redis-&amp;gt;set(&amp;quot;say&amp;quot;,&amp;quot;Hello World&amp;quot;);
echo $redis-&amp;gt;get(&amp;quot;say&amp;quot;);     //输出Hello World&lt;/p&gt;
&lt;p&gt;//存储多个值
$array = array(&#39;first_key&#39;=&amp;gt;&#39;first_val&#39;,
&#39;second_key&#39;=&amp;gt;&#39;second_val&#39;,
&#39;third_key&#39;=&amp;gt;&#39;third_val&#39;);
$array_get = array(&#39;first_key&#39;,&#39;second_key&#39;,&#39;third_key&#39;);
$redis-&amp;gt;mset($array);
var_dump($redis-&amp;gt;mget($array_get));&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Javascript中使用onclick函数时的闭包问题解决</title>
    <link href="https://hoohack.me/blog/2015/2015-03-06-onclick-closure-solve/"/>
    <updated>2015-03-05T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-03-06-onclick-closure-solve/</id>
    <content type="html">&lt;p&gt;在Javascript函数中，经常有遇到闭包的情况。&lt;/p&gt;
&lt;p&gt;如下面的代码&lt;/p&gt;
&lt;p&gt;for (var i = 0; i &amp;lt; arr.length; i++) {
arr[i].onclick = function() {
console.log(i);
};
}&lt;/p&gt;
&lt;p&gt;此时输出的i的值全都是arr.length的值，因为出现了闭包。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%80%E3%80%81%E5%B0%86i%E4%BF%9D%E5%AD%98%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E4%B8%AD&quot; tabindex=&quot;-1&quot;&gt;一、将i保存在每个数组对象中&lt;/h2&gt;
&lt;p&gt;for (var i = 0; i &amp;lt; arr.length; i++) {
arr[i].i = i;
arr[i].onclick = function() {
console.log(this.i);
}
}&lt;/p&gt;
&lt;h2 id=&quot;%E4%BA%8C%E3%80%81%E5%B0%86i%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E8%87%AA%E8%BA%AB&quot; tabindex=&quot;-1&quot;&gt;二、将i保存在匿名函数自身&lt;/h2&gt;
&lt;p&gt;for (var i = 0; i &amp;lt; arr.length; i++) {
(arr[i].onclick = function() {
console.log(arguments.callee.i);
}).i = i;
}&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%89%E3%80%81%E6%B7%BB%E5%8A%A0%E4%B8%80%E5%B1%82%E9%97%AD%E5%8C%85(%E4%BD%9C%E4%B8%BA%E5%BD%A2%E5%8F%82)&quot; tabindex=&quot;-1&quot;&gt;三、添加一层闭包(作为形参)&lt;/h2&gt;
&lt;p&gt;for (var i = 0; i &amp;lt; arr.length; i++) {
(function(arg) {
arr[i].onclick = function() {
console.log(arg);
}
})(i);
}&lt;/p&gt;
&lt;h2 id=&quot;%E5%9B%9B%E3%80%81%E5%8A%A0%E4%BB%A5%E5%B1%82%E9%97%AD%E5%8C%85(%E4%BD%9C%E4%B8%BA%E5%8F%98%E9%87%8F)&quot; tabindex=&quot;-1&quot;&gt;四、加以层闭包(作为变量)&lt;/h2&gt;
&lt;p&gt;for (var i = 0; i &amp;lt; arr.length; i++) {
(function(arg) {
var temp = i;
arr[i].onclick = function() {
console.log(temp);
}
})();
}&lt;/p&gt;
&lt;p&gt;在这里记录下解决方案，以便以后查阅。如有错误之处或更多建议，请指出。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>PHP过滤HTML数据</title>
    <link href="https://hoohack.me/blog/2015/2015-02-05-php-filter-html/"/>
    <updated>2015-02-05T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-02-05-php-filter-html/</id>
    <content type="html">&lt;h2 id=&quot;%E5%88%86%E4%BA%AB%E4%B8%A4%E4%B8%AA%E8%BF%87%E6%BB%A4html%E6%A0%87%E7%AD%BE%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82&quot; tabindex=&quot;-1&quot;&gt;分享两个过滤HTML标签的方法。&lt;/h2&gt;
&lt;h3 id=&quot;%E4%B8%80%E3%80%81%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%87%E6%BB%A4html%E6%A0%87%E7%AD%BE&quot; tabindex=&quot;-1&quot;&gt;一、使用正则表达式过滤html标签&lt;/h3&gt;
&lt;p&gt;$html_data = &amp;quot;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;&lt;a href=&quot;http://www.hoohack.me/&quot;&gt;www.hoohack.me&lt;/a&gt;&amp;lt;/a&amp;gt;&amp;quot;;
preg_replace(&amp;quot;/(&amp;lt;/?)(w+)([^&amp;gt;]*&amp;gt;)/e&amp;quot;, &amp;quot;&#39;&#92;1&#39;.strtoupper(&#39;&#92;2&#39;).&#39;&#92;3&#39;&amp;quot;, $html_data);&lt;/p&gt;
&lt;h3 id=&quot;%E4%BA%8C%E3%80%81php%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0strip_tags&quot; tabindex=&quot;-1&quot;&gt;二、PHP内置函数strip_tags&lt;/h3&gt;
&lt;h4 id=&quot;%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E&quot; tabindex=&quot;-1&quot;&gt;函数说明&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;string strip_tags ( string $str [, string $allowable_tags ] )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81&quot; tabindex=&quot;-1&quot;&gt;使用示例代码&lt;/h4&gt;
&lt;p&gt;$str = &amp;quot;&amp;lt;a href=&#39;#&#39;&amp;gt;&lt;a href=&quot;http://www.hoohack.me/&quot;&gt;www.hoohack.me&lt;/a&gt;&amp;lt;/a&amp;gt;&amp;lt;img src=&#39;&#39;&amp;gt;&amp;lt;p&amp;gt;hello&amp;lt;/p&amp;gt;&amp;quot;;&lt;/p&gt;
&lt;p&gt;$newStr = strip_tags($str);                               //过滤所有html标签&lt;/p&gt;
&lt;p&gt;$strNoImg = strip_tags($str,&amp;quot;&amp;lt;a&amp;gt;&amp;quot;);                       //仅过滤(某种标签，这里是a)标签&lt;/p&gt;
&lt;p&gt;$multiStr = strip_tags($str,&amp;quot;&amp;lt;a&amp;gt;&amp;lt;p&amp;gt;&amp;quot;);                    //过滤多种标签&lt;/p&gt;
&lt;h4 id=&quot;%E8%BF%87%E6%BB%A4%26nbsp%3B&quot; tabindex=&quot;-1&quot;&gt;过滤&lt;code&gt;&amp;amp;nbsp;&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;使用上面的函数时无法过滤&lt;code&gt;&amp;amp;nbsp;&lt;/code&gt;等转义字符（即HTML中的空格）。因为strip_tags的话只能过滤html的标签，而&amp;amp;nbsp;不属于html标签。如果需要过滤这个字符时，应该使用正则替换&lt;/p&gt;
&lt;p&gt;preg_replace(&#39;/ /&#39;, &#39;&#39;, $str);&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>PHP过滤器(Filter)的用法总结</title>
    <link href="https://hoohack.me/blog/2015/2015-02-01-php-filter/"/>
    <updated>2015-02-01T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-02-01-php-filter/</id>
    <content type="html">&lt;p&gt;在使用PHP进行开发时，很多时候需要判断邮箱、URL或IP地址等数据是否符合都是使用正则表达式。还有些时候需要将某些字符转换成其他字符时需要编写函数。如果在大型项目时会有很多这样的需要，对于开发和维护来说难免过于复杂。庆幸的是，现在有了filter函数库做这样的工作。&lt;/p&gt;
&lt;h2 id=&quot;%E4%BB%80%E4%B9%88%E6%98%AFphp%E8%BF%87%E6%BB%A4%E5%99%A8&quot; tabindex=&quot;-1&quot;&gt;什么是PHP过滤器&lt;/h2&gt;
&lt;p&gt;PHP过滤器用于验证和过滤来自非安全来源的数据，比如用户的输入。验证和过滤用户输入或自定义数据是任何Web应用程序的重要部分。&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8&quot; tabindex=&quot;-1&quot;&gt;为什么使用过滤器&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;几乎所有Web应用程序都依赖外部外部的输入。这些数据通常来自用户或其他应用程序（比如web服务）。通过使用过滤器，你能够确保应用程序获得正确的
输入类型。&lt;/li&gt;
&lt;li&gt;程序员应该始终对外部数据进行过滤。&lt;/li&gt;
&lt;li&gt;避免编写繁杂的正则表达式/函数对数据进行验证&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%96%E9%83%A8%E6%95%B0%E6%8D%AE&quot; tabindex=&quot;-1&quot;&gt;什么是外部数据&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;来自表单的输入数据&lt;/li&gt;
&lt;li&gt;Cookies&lt;/li&gt;
&lt;li&gt;服务器变量&lt;/li&gt;
&lt;li&gt;数据库查询结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;filter%E5%87%BD%E6%95%B0&quot; tabindex=&quot;-1&quot;&gt;filter函数&lt;/h2&gt;
&lt;p&gt;filter_var() - 通过一个指定的过滤器来过滤单一的变量&lt;/p&gt;
&lt;p&gt;mixed filter_var ( mixed $variable [, int $filter = FILTER_DEFAULT [, mixed $options ]] )&lt;/p&gt;
&lt;p&gt;filter_var_array() - 通过相同的或不同的过滤器来过滤多个变量&lt;/p&gt;
&lt;p&gt;mixed filter_var_array ( array $data [, mixed $definition [, bool $add_empty = true ]] )&lt;/p&gt;
&lt;p&gt;filter_input - 获取一个输入变量，并对它进行过滤&lt;/p&gt;
&lt;p&gt;mixed filter_input ( int $type , string $variable_name [, int $filter = FILTER_DEFAULT [, mixed $options ]] )&lt;/p&gt;
&lt;p&gt;filter_input_array - 获取多个输入变量，并通过相同的或不同的过滤器对它们进行过滤&lt;/p&gt;
&lt;p&gt;mixed filter_input_array ( int $type [, mixed $definition [, bool $add_empty = true ]] )&lt;/p&gt;
&lt;h2 id=&quot;%E8%BF%87%E6%BB%A4%E5%99%A8%E7%B1%BB%E5%9E%8B&quot; tabindex=&quot;-1&quot;&gt;过滤器类型&lt;/h2&gt;
&lt;p&gt;Filter函数有第二个参数是过滤器类型，有两种过滤器：Validating和Sanitizing&lt;/p&gt;
&lt;h3 id=&quot;validating%E8%BF%87%E6%BB%A4%E5%99%A8&quot; tabindex=&quot;-1&quot;&gt;Validating过滤器&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;用户验证用户输入&lt;/li&gt;
&lt;li&gt;严格的格式规则（比如URL或EMAIL验证）&lt;/li&gt;
&lt;li&gt;如果成功则返回预期类型的数据，如果失败则返回FALSE&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;sanitizing%E8%BF%87%E6%BB%A4%E5%99%A8&quot; tabindex=&quot;-1&quot;&gt;Sanitizing过滤器&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;用于允许或禁止字符串中指定的字符&lt;/li&gt;
&lt;li&gt;无数据格式规则&lt;/li&gt;
&lt;li&gt;始终返回字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E9%80%89%E9%A1%B9%E6%88%96%E6%A0%87%E5%BF%97&quot; tabindex=&quot;-1&quot;&gt;选项或标志&lt;/h2&gt;
&lt;p&gt;Filter函数的第三个参数是选项或标志，用于向指定的过滤器添加额外的过滤选项。&lt;/p&gt;
&lt;p&gt;不同的过滤器有不同的选项和标志。&lt;/p&gt;
&lt;h2 id=&quot;%E4%BD%BF%E7%94%A8validating%E8%BF%87%E6%BB%A4%E5%99%A8%E8%BF%87%E6%BB%A4%E8%BE%93%E5%85%A5&quot; tabindex=&quot;-1&quot;&gt;使用Validating过滤器过滤输入&lt;/h2&gt;
&lt;p&gt;当验证来自表单的输入时，我们需要做的是首先确认是否存在我们正在查找的输入数据。然后我们用filter_input()函数过滤输入的数据。如：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
if(!filter_has_var(INPUT_GET, &amp;quot;email&amp;quot;)) {
echo(&amp;quot;Input type does not exist&amp;quot;);
} else {
if (!filter_input(INPUT_GET, &amp;quot;email&amp;quot;, FILTER_VALIDATE_EMAIL)) {
echo &amp;quot;E-Mail is not valid&amp;quot;;
} else {
echo &amp;quot;E-Mail is valid&amp;quot;;
}
}
?&amp;gt;&lt;/p&gt;
&lt;h3 id=&quot;%E8%A7%A3%E9%87%8A%EF%BC%9A&quot; tabindex=&quot;-1&quot;&gt;解释：&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;上面的例子有一个通过 &amp;quot;GET&amp;quot; 方法传送的输入变量 (email)：
检测是否存在 &amp;quot;GET&amp;quot; 类型的 &amp;quot;email&amp;quot; 输入变量
如果存在输入变量，检测它是否是有效的邮件地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E4%BD%BF%E7%94%A8sanitizing%E8%BF%87%E6%BB%A4%E5%99%A8%E8%BF%87%E6%BB%A4%E8%BE%93%E5%85%A5&quot; tabindex=&quot;-1&quot;&gt;使用Sanitizing过滤器过滤输入&lt;/h2&gt;
&lt;p&gt;首先，我们要确认是否存在我们正在查找的输入数据。
然后，我们用 filter_input() 函数来净化输入数据。
在下面的例子中，输入变量 &amp;quot;url&amp;quot; 被传到 PHP 页面：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
if(!filter_has_var(INPUT_POST, &amp;quot;url&amp;quot;)) {
echo(&amp;quot;Input type does not exist&amp;quot;);
} else {
$url = filter_input(INPUT_POST, &amp;quot;url&amp;quot;, FILTER_SANITIZE_URL);
}
?&amp;gt;&lt;/p&gt;
&lt;h3 id=&quot;%E8%A7%A3%E9%87%8A%EF%BC%9A-1&quot; tabindex=&quot;-1&quot;&gt;解释：&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;上面的例子有一个通过 &amp;quot;POST&amp;quot; 方法传送的输入变量 (url)：
检测是否存在 &amp;quot;POST&amp;quot; 类型的 &amp;quot;url&amp;quot; 输入变量
如果存在此输入变量，对其进行净化（删除非法字符），并将其存储在 $url 变量中
假如输入变量类似这样：&amp;quot;&lt;a href=&quot;http://www.xn--w3ool-l39kx27v.com.xn--cn-l70dk02j/&quot;&gt;http://www.W3非o法ol.com.c字符n/&lt;/a&gt;&amp;quot;，则净化后的 $url 变量应该是这样的：
&lt;code&gt;http://www.W3School.com.cn/&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E8%BF%87%E6%BB%A4%E5%A4%9A%E4%B8%AA%E8%BE%93%E5%85%A5&quot; tabindex=&quot;-1&quot;&gt;过滤多个输入&lt;/h2&gt;
&lt;p&gt;表单通常由多个输入字段组成。为了避免对 filter_var 或 filter_input 重复调用，我们可以使用 filter_var_array 或 the filter_input_array 函数。&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
$filters = array(
&amp;quot;name&amp;quot; =&amp;gt; array(
&amp;quot;filter&amp;quot;=&amp;gt;FILTER_SANITIZE_STRING
),
&amp;quot;age&amp;quot; =&amp;gt; array(
&amp;quot;filter&amp;quot;=&amp;gt;FILTER_VALIDATE_INT,
&amp;quot;options&amp;quot;=&amp;gt;array(
&amp;quot;min_range&amp;quot;=&amp;gt;1,
&amp;quot;max_range&amp;quot;=&amp;gt;120
)
),
&amp;quot;email&amp;quot;=&amp;gt; FILTER_VALIDATE_EMAIL,
);&lt;/p&gt;
&lt;p&gt;$result = filter_input_array(INPUT_GET, $filters);&lt;/p&gt;
&lt;p&gt;if (!$result[&amp;quot;age&amp;quot;]) {
echo(&amp;quot;Age must be a number between 1 and 120.&amp;lt;br /&amp;gt;&amp;quot;);
} elseif(!$result[&amp;quot;email&amp;quot;]) {
echo(&amp;quot;E-Mail is not valid.&amp;lt;br /&amp;gt;&amp;quot;);
} else {
echo(&amp;quot;User input is valid&amp;quot;);
}
?&amp;gt;&lt;/p&gt;
&lt;h3 id=&quot;%E8%A7%A3%E9%87%8A&quot; tabindex=&quot;-1&quot;&gt;解释&lt;/h3&gt;
&lt;p&gt;上面的例子有三个通过 &amp;quot;GET&amp;quot; 方法传送的输入变量 (name, age and email)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;设置一个数组，其中包含了输入变量的名称，以及用于指定的输入变量的过滤器&lt;/li&gt;
&lt;li&gt;调用 filter_input_array 函数，参数包括 GET 输入变量及刚才设置的数组&lt;/li&gt;
&lt;li&gt;检测 $result 变量中的 &amp;quot;age&amp;quot; 和 &amp;quot;email&amp;quot; 变量是否有非法的输入。（如果存在非法输入，）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;filter_input_array() 函数的第二个参数可以是数组或单一过滤器的 ID。&lt;/p&gt;
&lt;p&gt;如果该参数是单一过滤器的 ID，那么这个指定的过滤器会过滤输入数组中所有的值。&lt;/p&gt;
&lt;p&gt;如果该参数是一个数组，那么此数组必须遵循下面的规则：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;必须是一个关联数组，其中包含的输入变量是数组的键（比如 &amp;quot;age&amp;quot; 输入变量）&lt;/li&gt;
&lt;li&gt;此数组的值必须是过滤器的 ID ，或者是规定了过滤器、标志以及选项的数组&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E4%BD%BF%E7%94%A8-filter-callback&quot; tabindex=&quot;-1&quot;&gt;使用 Filter Callback&lt;/h2&gt;
&lt;p&gt;使用FILTER_CALLBACK过滤器，可以调用自定义的函数，把它作为一个过滤器来使用。这样，我们就可以根据自己的需求来编写数据过滤器。&lt;/p&gt;
&lt;p&gt;在下面的例子中，我们使用一个自定义的函数把所有 &amp;quot;_&amp;quot; 转换为空格：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
function convertSpace($string) {
return str_replace(&amp;quot;_&amp;quot;, &amp;quot; &amp;quot;, $string);
}&lt;/p&gt;
&lt;p&gt;$string = &amp;quot;Peter_is_a_great_guy!&amp;quot;;&lt;/p&gt;
&lt;p&gt;echo filter_var($string, FILTER_CALLBACK, array(&amp;quot;options&amp;quot;=&amp;gt;&amp;quot;convertSpace&amp;quot;));
?&amp;gt;&lt;/p&gt;
&lt;p&gt;以上代码的结果是这样的：
&lt;code&gt;Peter is a great guy!&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;%E8%A7%A3%E9%87%8A-1&quot; tabindex=&quot;-1&quot;&gt;解释&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;上面的例子把所有 &amp;quot;&lt;em&gt;&amp;quot; 转换成空格：
创建一个把 &amp;quot;&lt;/em&gt;&amp;quot; 替换为空格的函数
调用 filter_var() 函数，它的参数是 FILTER_CALLBACK 过滤器以及包含我们的函数的数组&lt;/p&gt;
&lt;/blockquote&gt;
</content>
  </entry>
  
  <entry>
    <title>谈谈PHP中ob_start()函数的用法</title>
    <link href="https://hoohack.me/blog/2015/2015-01-24-php-ob_start-function/"/>
    <updated>2015-01-24T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-01-24-php-ob_start-function/</id>
    <content type="html">&lt;h2 id=&quot;ob_start&quot; tabindex=&quot;-1&quot;&gt;ob_start&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;打开输出控制缓存&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E5%AE%98%E7%BD%91%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E&quot; tabindex=&quot;-1&quot;&gt;官网文档说明&lt;/h2&gt;
&lt;p&gt;bool ob_start ([ callback $output_callback [, int $chunk_size [, bool $erase ]]] )&lt;/p&gt;
&lt;p&gt;此函数将打开输出缓冲。当输出缓冲激活后，脚本将不会输出内容（除http标头外），相反需要输出的内容被存储在内部缓冲区中。（因此可选择回调函数用于处理输出结果信息）&lt;/p&gt;
&lt;p&gt;该函数可以让你自由地控制脚本中数据的输出。比如可以用在输出静态化页面上。而且，当你想在数据已经输出后，再输出文件头的情况。输出控制函数不对使用 header() 或 setcookie(), 发送的文件头信息产生影响,只对那些类似于 echo() 和 PHP 代码的数据块有作用。原因是当打开了缓冲区，echo后面的字符不会输出到浏览器，而是保留在服务器，直到你使用flush或者ob_end_flush才会输出，所以并不会有任何文件头输出的错误。&lt;/p&gt;
&lt;h2 id=&quot;%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0&quot; tabindex=&quot;-1&quot;&gt;相关函数&lt;/h2&gt;
&lt;p&gt;ob_end_flush — 冲刷出（送出）输出缓冲区内容并关闭缓冲&lt;/p&gt;
&lt;p&gt;ob_clean — 清空（擦掉）输出缓冲区&lt;/p&gt;
&lt;p&gt;ob_end_clean — 清空（擦除）缓冲区并关闭输出缓冲&lt;/p&gt;
&lt;p&gt;ob_flush — 冲刷出（送出）输出缓冲区中的内容&lt;/p&gt;
&lt;p&gt;ob_get_contents — 返回输出缓冲区的内容&lt;/p&gt;
&lt;h2 id=&quot;%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%3A&quot; tabindex=&quot;-1&quot;&gt;使用示例:&lt;/h2&gt;
&lt;p&gt;//缓冲区F
1.ob_start();             //缓冲区A
2.echo &#39;level 1&amp;lt;br /&amp;gt;&#39;;
3.ob_start();             //缓冲区B
4.echo &#39;level 2&amp;lt;br /&amp;gt;&#39;;
5.ob_start();             //缓冲区C
6.echo &#39;level 3&amp;lt;br /&amp;gt;&#39;;
7.ob_end_clean();
8.ob_end_flush();
9.ob_end_clean();
10.$str = ob_get_contents();
11.echo $str;&lt;/p&gt;
&lt;p&gt;运行结果：&lt;code&gt;没有输出任何东西&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B&quot; tabindex=&quot;-1&quot;&gt;运行过程&lt;/h2&gt;
&lt;p&gt;可以把整个缓冲区看作一个栈，有新的缓冲区被创建，则新的缓冲区成为栈顶缓冲区。有新内容输出则输出内容会被输出到栈顶的缓冲区。&lt;/p&gt;
&lt;p&gt;本程序缓冲区层次：&lt;/p&gt;
&lt;p&gt;C-&amp;gt;B-&amp;gt;A-&amp;gt;F&lt;/p&gt;
&lt;p&gt;初始F:null&lt;/p&gt;
&lt;p&gt;运行&lt;code&gt;1.ob_start();&lt;/code&gt;后，新建缓冲区A，此时整个缓冲区情况&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A:null-&amp;gt;F:null&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;运行&lt;code&gt;2.echo &#39;level 1&amp;lt;br /&amp;gt;&#39;;&lt;/code&gt;后&lt;/p&gt;
&lt;p&gt;内容输出到缓冲区A，此时整个缓冲区情况&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A:&#39;level 1&amp;lt;br /&amp;gt;&#39; -&amp;gt; F:null&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;运行&lt;code&gt;3.ob_start();&lt;/code&gt;后，新建缓冲区B，此时整个缓冲区情况&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;B:null -&amp;gt; A:&#39;level 1&amp;lt;br /&amp;gt;&#39; -&amp;gt; F:null&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;运行&lt;code&gt;4.echo &#39;level 1&amp;lt;br /&#92;&amp;gt;&#39;;&lt;/code&gt;后&lt;/p&gt;
&lt;p&gt;内容输出到缓冲区B，此时整个缓冲区情况&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;B:&#39;level 2&amp;lt;br /&amp;gt;&#39; -&amp;gt; A: &#39;level 1&amp;lt;br /&amp;gt;&#39; -&amp;gt; F:null&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以此类推建立缓冲区C，运行到&lt;code&gt;6.echo &#39;level 3&amp;lt;br /&amp;gt;&#39;;&lt;/code&gt;后，此时整个缓冲区情况&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;C:&#39;level 3&amp;lt;br /&amp;gt;&#39; -&amp;gt; B:&#39;level 2&amp;lt;br /&amp;gt;&#39; -&amp;gt; A: &#39;level 1&amp;lt;br /&amp;gt;&#39; -&amp;gt; F:null&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着运行&lt;code&gt;7.ob_end_clean();&lt;/code&gt;，缓冲区C被清空且关闭，此时缓冲区情况&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;B:&#39;level 2&amp;lt;br /&amp;gt;&#39; -&amp;gt; A: &#39;level 1&amp;lt;br /&amp;gt;&#39; -&amp;gt; F:null&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着运行&lt;code&gt;8.ob_end_flush();&lt;/code&gt;，缓冲区B的内容输出到上一级的缓冲区且缓冲区B被关闭。此时缓冲区情况&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A: &#39;level 2&amp;lt;br /&amp;gt; level 1&amp;lt;br /&amp;gt;&#39; -&amp;gt; F:null&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着运行&lt;code&gt;9.ob_end_clean();&lt;/code&gt;，缓冲区A被情况且关闭。A的内容还没有真正输出到缓冲区F中就被关闭了，最后只剩F:null，因此程序就没有任何输出了。&lt;/p&gt;
&lt;h2 id=&quot;%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9&quot; tabindex=&quot;-1&quot;&gt;注意事项&lt;/h2&gt;
&lt;p&gt;当在输出图片前使用了ob_start()函数，由于有缓冲的缘故所以图片无法正常显示，应该先清除缓冲区再输出图片。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>父DIV浮动后无法撑开子DIV的解决方案</title>
    <link href="https://hoohack.me/blog/2015/2015-01-19-parentdiv-cannot-brace-subdiv/"/>
    <updated>2015-01-19T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-01-19-parentdiv-cannot-brace-subdiv/</id>
    <content type="html">&lt;p&gt;直奔主题。
有这样一段代码&lt;/p&gt;
&lt;p&gt;&amp;lt;div id=&amp;quot;parent&amp;quot;&amp;gt;
&amp;lt;div id=&amp;quot;sub&amp;quot;&amp;gt;DIV2&amp;lt;/div&amp;gt;
DIV1
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;很多时候我们期望实现下图的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/parentDIV-subDIV_actural.png&quot; alt=&quot;期望效果&quot; /&gt;&lt;/p&gt;
&lt;p&gt;于是添加如下样式:&lt;/p&gt;
&lt;p&gt;#parent {
background-color: #0086B3;
width: 100%;
height: auto;
}&lt;/p&gt;
&lt;p&gt;#sub {
background-color: #009926;
float: left;
width: 80%;
height: auto;
}&lt;/p&gt;
&lt;p&gt;但是却得到下图所示的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/parentDIV-subDIV.png&quot; alt=&quot;父DIV无法撑开子DIV示例&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如图所示，DIV1里面嵌有DIV2，DIV2被设置浮动了，而此时DIV1无法被完全撑开，即DIV2相当于浮动在页面上，与DIV1不再同一个层面上，导致DIV2无法把DIV1撑开。&lt;/p&gt;
&lt;h2 id=&quot;%E5%8E%9F%E5%9B%A0&quot; tabindex=&quot;-1&quot;&gt;原因&lt;/h2&gt;
&lt;p&gt;由于DIV2浮动，它不再属于标准流，DIV1自己组成了标准流，而浮动是漂浮在标准流之上的，因此DIV2就挡住了DIV1。&lt;/p&gt;
&lt;h2 id=&quot;%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&quot; tabindex=&quot;-1&quot;&gt;解决方案&lt;/h2&gt;
&lt;h3 id=&quot;%E7%AC%AC%E4%B8%80%E7%A7%8D%EF%BC%9A%E5%9C%A8%E6%B5%AE%E5%8A%A8%E7%BB%93%E6%9D%9F%E7%9A%84%E5%AE%B9%E5%99%A8(%E6%AD%A4%E5%A4%84%E4%B8%BAsub)%E5%90%8E%E9%9D%A2%E5%8A%A0%E4%B8%8A%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81&quot; tabindex=&quot;-1&quot;&gt;第一种：在浮动结束的容器(此处为sub)后面加上这段代码&lt;/h3&gt;
&lt;p&gt;&amp;lt;div style=&amp;quot;clear: both&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;意思是清除浮动。这样后面的DIV就不会继承这个浮动。&lt;/p&gt;
&lt;h3 id=&quot;%E7%AC%AC%E4%BA%8C%E7%A7%8D%EF%BC%9A%E5%9C%A8%E7%88%B6div(%E6%AD%A4%E5%A4%84%E4%B8%BAdiv1)%E5%8A%A0%E4%B8%8A%E7%9A%84%E6%A0%B7%E5%BC%8F%E5%8A%A0%E4%B8%8A%3A&quot; tabindex=&quot;-1&quot;&gt;第二种：在父DIV(此处为DIV1)加上的样式加上:&lt;/h3&gt;
&lt;p&gt;overflow: auto;&lt;/p&gt;
&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这2种方法都可以实现DIV2把DIV1撑开。不过在此建议使用第一种解决方案，要养成一个习惯，在浮动使用完后消除浮动，这样后面的DIV就不会继承这个浮动（就像在操作数据库的时候，在打开数据库，操作完后，要养成个习惯在后面把数据库关闭）。也就是说浮动这个属性会被继承，除非消除这个浮动，才不会让后面接着的DIV受到继承。其实不仅是DIV，其他的像P等其他的容器都会有继承的效应，大家要养成一个消除浮动的习惯。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>无限多级分类实现(PHP)</title>
    <link href="https://hoohack.me/blog/2015/2015-01-17-unlimited-multi-level-classification-implement/"/>
    <updated>2015-01-17T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-01-17-unlimited-multi-level-classification-implement/</id>
    <content type="html">&lt;h2 id=&quot;%E5%89%8D%E8%A8%80&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;项目中遇到需要实现多级分类的功能，刚开始想通过静态数据的方法，但是后来发现分类需要添加编辑功能，而且当分类很多的时候管理起来也不方便，于是乎就想到了使用数据库的方法。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1&quot; tabindex=&quot;-1&quot;&gt;数据库设计&lt;/h2&gt;
&lt;p&gt;tbl_category&lt;/p&gt;
&lt;p&gt;id          int     not null    auto_increment&lt;/p&gt;
&lt;p&gt;cat_id      int     not null&lt;/p&gt;
&lt;p&gt;cat_name    varchar not null&lt;/p&gt;
&lt;p&gt;parent_id   int     not null&lt;/p&gt;
&lt;h3 id=&quot;%E8%AF%B4%E6%98%8E&quot; tabindex=&quot;-1&quot;&gt;说明&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果parent_id为0说明该分类是顶级父节点&lt;/li&gt;
&lt;li&gt;如果parent_id不为0说明为孩子节点&lt;/li&gt;
&lt;li&gt;如果cat_id不属于parent_id，说明为叶子节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E6%9F%A5%E8%AF%A2%E7%AE%97%E6%B3%95&quot; tabindex=&quot;-1&quot;&gt;查询算法&lt;/h2&gt;
&lt;p&gt;首先获取顶级父节点&lt;/p&gt;
&lt;p&gt;根据顶级父节点获取子节点&lt;/p&gt;
&lt;p&gt;遍历所有子节点，如果当前节点有孩子节点&lt;/p&gt;
&lt;p&gt;先把当前孩子节点找出来&lt;/p&gt;
&lt;p&gt;再把当前孩子节点的孩子节点找出来&lt;/p&gt;
&lt;p&gt;不断重复此步骤，递归实现&lt;/p&gt;
&lt;p&gt;否则不做处理&lt;/p&gt;
&lt;h2 id=&quot;%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B&quot; tabindex=&quot;-1&quot;&gt;代码示例&lt;/h2&gt;
&lt;p&gt;$rootArr = getRootCategory();&lt;/p&gt;
&lt;p&gt;getChildren($rootArr);&lt;/p&gt;
&lt;p&gt;function getChildren(&amp;amp; $rootArr) {
foreach ($rootArr as &amp;amp;$row) {
if (haveChildren($row[&#39;cat_id&#39;])) {
$row[&#39;children&#39;] = getChildren($row[&#39;cat_id&#39;]);
getChildren($row[&#39;children&#39;]);
}
}
}&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>在Linux中使用dd刻录系统</title>
    <link href="https://hoohack.me/blog/2015/2015-01-15-use-dd-to-burn-system/"/>
    <updated>2015-01-15T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-01-15-use-dd-to-burn-system/</id>
    <content type="html">&lt;p&gt;第一次接触Linux操作系统的时候使用的是Ubuntu发行版，装系统的时候只需要使用ultraisoPE软件添加镜像文件就可以进行刻录了，但是后来经过朋友的
介绍，改为使用OpenSUSE的发行版，在刻录的时候，不可以像Ubuntu那样刻录，可以通过Linux下的dd命令进行刻录的操作。&lt;/p&gt;
&lt;h2 id=&quot;dd&quot; tabindex=&quot;-1&quot;&gt;dd&lt;/h2&gt;
&lt;p&gt;在linux查看该命令的用途：&lt;code&gt;man dd&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以看到&lt;/p&gt;
&lt;p&gt;dd - convert and copy a file&lt;/p&gt;
&lt;p&gt;可见dd命令是转换和复制文件。&lt;/p&gt;
&lt;p&gt;在Unix上，硬件的设备驱动（如硬盘）和特殊设备文件（如/dev/zero和/dev/random）就像普通文件一样，出现在文件系统中；只要在各自的驱动程序中
实现了对应的功能，dd也可以读取自和/或写入到这些文件。这样，dd也可以用在备份硬件的引导扇区、获取一定数量的随机数据等任务中。dd程序也可以在
复制时处理数据，例如转换字节序、或在ASCII与EBCDIC编码间互换。&lt;/p&gt;
&lt;h2 id=&quot;dd%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E&quot; tabindex=&quot;-1&quot;&gt;dd参数说明&lt;/h2&gt;
&lt;p&gt;dd if=&amp;quot;input file&amp;quot; of=&amp;quot;output file&amp;quot; bs=&amp;quot;block size&amp;quot; count=&amp;quot;number&amp;quot;&lt;/p&gt;
&lt;p&gt;if ： 就是input file，也可以是设备&lt;/p&gt;
&lt;p&gt;of ： 就是output file，也可以是设备&lt;/p&gt;
&lt;p&gt;bs ： 规划一个block的大小，若未指定则默认是512bytes（一个扇区的大小）&lt;/p&gt;
&lt;p&gt;count ： 多少个bs的意思&lt;/p&gt;
&lt;h2 id=&quot;%E5%88%BB%E5%BD%95%E7%9A%84%E6%AD%A5%E9%AA%A4&quot; tabindex=&quot;-1&quot;&gt;刻录的步骤&lt;/h2&gt;
&lt;h3 id=&quot;%E6%9F%A5%E6%89%BEusb%E8%AE%BE%E5%A4%87&quot; tabindex=&quot;-1&quot;&gt;查找USB设备&lt;/h3&gt;
&lt;p&gt;ls -l /dev/disk/by_id/&lt;em&gt;usb&lt;/em&gt;/&lt;/p&gt;
&lt;p&gt;此时可以看到你插入的USB设备，找到有数字后缀的设备进行卸载&lt;/p&gt;
&lt;h3 id=&quot;%E5%8D%B8%E8%BD%BDu%E7%9B%98&quot; tabindex=&quot;-1&quot;&gt;卸载U盘&lt;/h3&gt;
&lt;p&gt;umount /dev/sdX1&lt;/p&gt;
&lt;h3 id=&quot;%E5%88%BB%E5%BD%95%E9%95%9C%E5%83%8F&quot; tabindex=&quot;-1&quot;&gt;刻录镜像&lt;/h3&gt;
&lt;p&gt;dd if=/path/to/downloaded.iso of=/dev/sdX1 bs=4M&lt;/p&gt;
&lt;h2 id=&quot;%EF%BC%9F%E6%97%A0%E6%B3%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BF%AE%E5%A4%8Du%E7%9B%98&quot; tabindex=&quot;-1&quot;&gt;？无法格式化修复U盘&lt;/h2&gt;
&lt;p&gt;使用dd命令刻录U盘后，你的U盘可能在Windows下即使再次重新格式化，也无法显示正常的大小，如果您确信您的U盘是正品，那么可以使用类似如下命令修复U盘&lt;/p&gt;
&lt;p&gt;dd if=/dev/zero of=/dev/sdc bs=512 count=1&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>学习TCP三次握手总结</title>
    <link href="https://hoohack.me/blog/2015/2015-01-13-tcp-three-way-handshake/"/>
    <updated>2015-01-13T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-01-13-tcp-three-way-handshake/</id>
    <content type="html">&lt;h2 id=&quot;%E4%BB%80%E4%B9%88%E6%98%AFtcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B&quot; tabindex=&quot;-1&quot;&gt;什么是TCP三次握手&lt;/h2&gt;
&lt;h3 id=&quot;%E6%8F%A1%E6%89%8B&quot; tabindex=&quot;-1&quot;&gt;握手&lt;/h3&gt;
&lt;p&gt;握手是在通信电路建立之后，信息传输开始之前。 握手用于达成参数，如信息传输率，字母表，奇偶校验, 中断过程，和其他协议特性。&lt;/p&gt;
&lt;h3 id=&quot;tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B&quot; tabindex=&quot;-1&quot;&gt;TCP三次握手&lt;/h3&gt;
&lt;p&gt;TCP三次握手是TCP创建连接前的一个过程。TCP使用三次握手这个过程以保证TCP可以提供可靠的传送。&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B&quot; tabindex=&quot;-1&quot;&gt;三次握手过程&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一次：建立连接时，客户端发送syn包(SYN=1)到服务器，同时选择初始序号seq=x。此时进入SYN_SENT状态，等待服务器确认&lt;/li&gt;
&lt;li&gt;第二次：服务器接收到客户端的请求包，若同意建立连接，则想客户端发送确认包，SYN和ACK位都置1,确认号是ack=x+1，同时也为自己选择一个初始序号seq=y。此时服务器进入SYN_RCVD状态&lt;/li&gt;
&lt;li&gt;第三次：客户端接收到服务器的确认包后，还要向服务器发送确认包。确认报文段的ACK置1，确认号ack=y+1，而自己的序号seq=x+1。此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手过程&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E8%BF%87%E7%A8%8B%E5%9B%BE&quot; tabindex=&quot;-1&quot;&gt;过程图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png&quot; alt=&quot;TCP三次握手过程图&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;accept%E9%98%B6%E6%AE%B5&quot; tabindex=&quot;-1&quot;&gt;ACCEPT阶段&lt;/h2&gt;
&lt;p&gt;ACCEPT阶段是从已完成三次握手的队列内取走一个，与三次握手过程没有关系，即不属于TCP三次握手的任何一个阶段。&lt;/p&gt;
&lt;p&gt;内核为任何一个给定的监听套接口维护两个队列：&lt;/p&gt;
&lt;p&gt;1、未完成连接队列（incomplete connection queue），每个这样的SYN分节对应其中一项：已由某个客户发出并到达服务器，而服务器正在等待完成相应的TCP三路握手过程。这些套接口处于SYN_RCVD状态。&lt;/p&gt;
&lt;p&gt;2、已完成连接队列（completed connection queue），每个已完成TCP三路握手过程的客户对应其中一项。这些套接口处于ESTABLISHED状态。&lt;/p&gt;
&lt;p&gt;TCP三次握手过程发生在connect step。&lt;/p&gt;
&lt;p&gt;ACCEPT只是把内核中的“已完成连接队列”取出完成三次握手的连接。&lt;/p&gt;
&lt;p&gt;另一个队列是“未完成连接队列”，两个队列总和最大值是backlog(backlog参数确定了connection队列可以增长的最大长度)&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>PHP中require、include、require_once和include_once的区别</title>
    <link href="https://hoohack.me/blog/2015/2015-01-10-php-require-include-require_once-include_once/"/>
    <updated>2015-01-10T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-01-10-php-require-include-require_once-include_once/</id>
    <content type="html">&lt;p&gt;之前在做项目和面试的时候都遇到这个问题，也有上网查阅了一些资料，现在自己总结一下以便加深对这个问题的理解程度。&lt;/p&gt;
&lt;p&gt;##include
include 语句包含并运行指定文件。&lt;/p&gt;
&lt;p&gt;被包含文件先按参数给出的路径寻找，如果没有给出目录（只有文件名）时则按照 include_path 指定的目录寻找。如果在 include_path 下没找到该文
件则 include 最后才在调用脚本文件所在的目录和当前工作目录下寻找。如果最后仍未找到文件则 include 结构会发出一条警告。&lt;/p&gt;
&lt;p&gt;如果定义了路径——不管是绝对路径（在 Windows 下以盘符或者 &#92; 开头，在 Unix/Linux 下以 / 开头）还是当前目录的相对路径（以 . 或者 .. 开头
）——include_path 都会被完全忽略。例如一个文件以 ../ 开头，则解析器会在当前目录的父目录下寻找该文件。&lt;/p&gt;
&lt;p&gt;如果 include 出现于调用文件中的一个函数里，则被调用的文件中所包含的所有代码将表现得如同它们是在该函数内部定义的一样。所以它将遵循该函数
的变量范围。此规则的一个例外是魔术常量，它们是在发生包含之前就已被解析器处理的。&lt;/p&gt;
&lt;p&gt;在失败时 include 返回 FALSE 并且发出警告。成功的包含则返回 1，除非在包含文件中另外给出了返回值。&lt;/p&gt;
&lt;p&gt;##require
require 和 include 几乎完全一样，除了处理失败的方式不同之外。require 在出错时产生 E_COMPILE_ERROR 级别的错误。换句话说将导致脚本中止
而 include 只产生警告（E_WARNING），脚本会继续运行。&lt;/p&gt;
&lt;p&gt;##include_once
include_once 语句在脚本执行期间包含并运行指定文件。此行为和 include 语句类似，唯一区别是如果该文件中已经被包含过，则不会再次包含。如同
此语句名字暗示的那样，只会包含一次。&lt;/p&gt;
&lt;p&gt;include_once 可以用于在脚本执行期间同一个文件有可能被包含超过一次的情况下，想确保它只被包含一次以避免函数重定义，变量重新赋值等问题。&lt;/p&gt;
&lt;p&gt;##require_once
require_once 语句和 require 语句完全相同，唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。&lt;/p&gt;
&lt;p&gt;##include与require使用方法
require 的使用方法如 &lt;code&gt;require(&amp;quot;./inc.php&amp;quot;);&lt;/code&gt;通常放在 PHP 程式的最前面，PHP 程式在执行前，就会先读入 require 所指定引入的档案，使它变成 PHP 程式网页的一部份。
include 使用方法如 &lt;code&gt;include(&amp;quot;./inc/.php&amp;quot;);&lt;/code&gt;一般是放在流程控制的处理区段中。PHP 程式网页在读到 include 的档案时，才将它读进来。这种方式，可以把程式执行时的流程简单化。&lt;/p&gt;
&lt;p&gt;##include与require区别
除了处理失败的方式不同之外，两者还有以下区别&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;include 只要在被执行时才会读入要包含的文件;而 require 是不管如何都会引入文件(即使在条件为FALSE的时候)。&lt;/li&gt;
&lt;li&gt;include 执行文件时每次都要进行读取和评估;而 require 执行文件只处理一次(实际上，文件内容替换了require语句)，这就意味着如果有包含这些指令之一的代码和可能执行多次的代码，则使用require()效率比较高。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;##require(include)与require_once(include_once)区别
require_once的作用是会检查之前是否加载过该文件,如果没有加载则加载，如果加载过就不再加载，比如某文件定义了一个类型，如果两次加载该文件会出现错误。&lt;/p&gt;
&lt;p&gt;那么，使用require还是require_once呢？这是个老问题了。&lt;/p&gt;
&lt;p&gt;require和require_once都是PHP函数，开发人员可以使用它们在某个特定的脚本中导入外部PHP文件以供使用。你可以根据应用程序的复杂度调用一次或
若干次require_once/require。使用require（而不是require_once）可以提高应用程序的性能。&lt;/p&gt;
&lt;p&gt;由于在导入PHP脚本时将进行大量的操作状态(stat)调用，因此require要快于require_once。如果你请求的文件位于目录/var/shared/htdocs/myapp/
models/MyModels/ClassA.php下，则操作系统会在到达ClassA.php之前的某个目录中运行一次stat调用。在这个例子中，共进行了6次stat调用。当然，
require也会发起stat调用，但是次数较少。越少的函数调用，代码的运行速度越快。&lt;/p&gt;
&lt;p&gt;但是，一般情况下，也不太需要去考虑究竟require还是require_once，除非这已经严重影响到你程序的性能了。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>AJAX跨域请求----JSONP</title>
    <link href="https://hoohack.me/blog/2015/2015-01-07-ajax-cross-domain-request-jsonp/"/>
    <updated>2015-01-07T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-01-07-ajax-cross-domain-request-jsonp/</id>
    <content type="html">&lt;p&gt;##JSONP是什么
&lt;a href=&quot;http://zh.wikipedia.org/wiki/JSONP&quot;&gt;JSONP&lt;/a&gt;（JSON with Padding）是资料格式 JSON 的一种“使用模式”，可以让网页从别的网域要资料。可以理解成填充了内容的json格式数据。&lt;/p&gt;
&lt;p&gt;##跨域是什么
简单理解，&lt;a href=&quot;http://xn--a-fw3b.com/get.html%E6%96%87%E4%BB%B6%E9%9C%80%E8%A6%81%E8%8E%B7%E5%8F%96b.com/data.html%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%80%8C%E8%BF%99%E9%87%8Ca.com%E5%92%8Cb.com%E5%B9%B6%E4%B8%8D%E6%98%AF%E5%90%8C%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E8%BF%99%E5%B0%B1%E6%98%AF%E8%B7%A8%E5%9F%9F%E3%80%82&quot;&gt;当a.com/get.html文件需要获取b.com/data.html文件中的数据，而这里a.com和b.com并不是同一台服务器，这就是跨域。&lt;/a&gt;
引用一个表格，看看引起跨域的条件:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/cross-domain.png&quot; alt=&quot;跨域条件表格&quot; /&gt;&lt;/p&gt;
&lt;p&gt;##JSONP是怎么产生的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为AJAX无法实现跨域请求，凡事WEB页面中调用JavaScript文件不受是否跨域影响。于是判断，是否能通过纯WEB端跨域访问数据，只有一种可能，即在远程服务器上
设法把数据装入JavaScript格式的文件里，供客户端调用和进一步处理。因为JSON格式可以很方便地在客户端和服务器使用，所以有以下方案：
WEB客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的JavaScript格式文件，显而易见，服务器之所以要动态生成JSON文件，目的就
在于把客户端需要的数据装入进入。客户端接收到数据后就按照自己的需求进行处理和展现。久而久之，为了便于客户端使用数据，逐渐地形成一个非正式
传输协议，成为JSONP。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##基本原理
简单地说就是动态添加一个&amp;lt;script&amp;gt;标签，而script标签的src属性是没有跨域的限制的。&lt;/p&gt;
&lt;p&gt;##要点
允许用户传递一个callback参数给服务端，服务端返回数据时会将这个callback参数作为函数名来包裹JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。&lt;/p&gt;
&lt;p&gt;##缺点
只支持GET请求&lt;/p&gt;
&lt;p&gt;##执行过程
在客户端注册一个callback函数，然后把callback的名字传给服务器。客户端接收到服务器返回的callback函数后，以JavaScript语法的形式生成给一个function，function名字就是服务器返回的参数的值。
最后将JSON数据直接以入参的方式，放置到function中，这样就生成了一堆JavaScript代码，返回给客户端。&lt;/p&gt;
&lt;p&gt;##示例
说了那么多，还是看看代码实现。
现在http://www.a.com/index.html想获取http://www.b.com的航班信息数据，JavaScript代码如下&lt;/p&gt;
&lt;p&gt;//得到航班信息查询结果后的回调函数
var flightHandler = function(data){
alert(&#39;你查询的&#39; + data.code + &#39;航班结果是：票价 &#39; + data.price + &#39; 元，&#39; + &#39;余票 &#39; + data.tickets + &#39; 张。&#39;);
};&lt;/p&gt;
&lt;p&gt;// 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）
var url = &amp;quot;&lt;a href=&quot;http://localhost/jsonp.php?code=CA1998&amp;amp;callback=flightHandler&quot;&gt;http://localhost/jsonp.php?code=CA1998&amp;amp;callback=flightHandler&lt;/a&gt;&amp;quot;;&lt;/p&gt;
&lt;p&gt;// 创建script标签，设置其属性
var script = document.createElement(&#39;script&#39;);
script.setAttribute(&#39;src&#39;, url);&lt;/p&gt;
&lt;p&gt;// 把script标签加入head，此时调用开始
document.getElementsByTagName(&#39;head&#39;)[0].appendChild(script);&lt;/p&gt;
&lt;p&gt;服务端(PHP)代码&lt;/p&gt;
&lt;p&gt;&amp;lt;?php
//php服务端
if (isset($_GET[&#39;callback&#39;]) &amp;amp;&amp;amp; !empty($_GET[&#39;callback&#39;])) {
echo $_GET[&#39;callback&#39;] . &#39;({&amp;quot;code&amp;quot;:&amp;quot;CA1998&amp;quot;,&amp;quot;price&amp;quot;:1780,&amp;quot;tickets&amp;quot;:5})&#39;;
}&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>AJAX原理总结</title>
    <link href="https://hoohack.me/blog/2015/2015-01-05-ajax-theory-summary/"/>
    <updated>2015-01-05T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-01-05-ajax-theory-summary/</id>
    <content type="html">&lt;p&gt;###AJAX全称&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Asynchronous JavaScript and XML(异步的JavaScript 和XML)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###同步和异步
异步传输是面向字符的传输，单位是字符&lt;/p&gt;
&lt;p&gt;同步传输是面向比特，单位是帧，传输时要求接收方和发送方的时钟是保持一致的。&lt;/p&gt;
&lt;p&gt;###通过XMLHTTPRequest理解AJAX&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AJAX原理简单地说就是通过XMLHTTPRequest来向服务器发送异步请求，从服务器获得数据，然后用JavaScript来操作DOM而刷新页面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;####XMLHTTPRequest对象属性
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/XMLHTTPRequest%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7.png&quot; alt=&quot;XMLHTTPRequest对象属性&quot; /&gt;
&lt;a href=&quot;https://www.hoohack.me/assets/images/2015_01_05.png&quot;&gt;查看大图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;AJAX就是把JavaScript技术与XMLHTTPRequest对象放在WEB表单和服务器间，当用户向服务器请求时，数据发送给JavaScript代码而不是直接发给服务器，JavaScript代码在幕后发送异步请求，然后服务器将数据返回给JavaScript代码。JavaScript代码接收到数据后，操作DOM来更新页面数据。&lt;/p&gt;
&lt;p&gt;###AJAX同步和异步
异步：AJAX一直执行，不发生阻塞等待服务器的响应，因此在使用异步AJAX时，在函数中对变量赋值是没有效的。&lt;/p&gt;
&lt;p&gt;同步：AJAX发生阻塞，等待服务器返回数据才能执行下一步。&lt;/p&gt;
&lt;p&gt;###AJAX原理图
&lt;img src=&quot;http://7u2eqw.com1.z0.glb.clouddn.com/ajax.png&quot; alt=&quot;AJAX原理图&quot; /&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>MySQL中VARCHAR与CHAR格式数据的区别</title>
    <link href="https://hoohack.me/blog/2015/2015-01-04-difference-between-varchar-and-char-in-mysql/"/>
    <updated>2015-01-04T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-01-04-difference-between-varchar-and-char-in-mysql/</id>
    <content type="html">&lt;p&gt;#区别
CHAR与VARCHAR类型类似，但它们保存和检索的方式不同。CHAR有固定的长度，而VARCHAR属于可变长的字符类型。它们最大长度和是否尾部空格被保留等方面也不同。在存储和检索过程中不进行大小写转换。&lt;/p&gt;
&lt;p&gt;下面的表格显示了将各种字符串值保存到CHAR(4)和VARCHAR(4)列后的结果，说明了CHAR和VARCHAR之间的差别：
&amp;lt;table&amp;gt;
&amp;lt;thead&amp;gt;
&amp;lt;th&amp;gt;值   &amp;lt;/th&amp;gt;
&amp;lt;th&amp;gt;CHAR(4)&amp;lt;/th&amp;gt;
&amp;lt;th&amp;gt;存储需求&amp;lt;/th&amp;gt;
&amp;lt;th&amp;gt;VARCHAR(4)&amp;lt;/th&amp;gt;
&amp;lt;th&amp;gt;存储需求&amp;lt;/th&amp;gt;
&amp;lt;/thead&amp;gt;
&amp;lt;tbody&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;&#39;&#39;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&#39;    &#39;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;4个字节&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&#39;&#39;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;1个字节&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;&#39;ab&#39;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&#39;ab  &#39;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;4个字节&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&#39;ab&#39;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;3个字节&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;&#39;abcd&#39;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&#39;abcd&#39;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;4个字节&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&#39;abcd&#39;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;5个字节&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;&#39;abcdefgh&#39;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&#39;abcd&#39;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;4个字节&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&#39;abcd&#39;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;5个字节&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;&lt;/p&gt;
&lt;p&gt;从上面可以看得出来CHAR的长度是固定的，不管你存储的数据是多少他都会都固定的长度。而VARCHAR则处可变长度但他要在总长度上加1字符，这个用来存储位置。所以实际应用中用户可以根据自己的数据类型来做。&lt;/p&gt;
&lt;p&gt;请注意，上表中最后一行的值只适用不使用严格模式时;如果MySQL运行在严格模式，超过列长度的值不被保存，并且会出现错误。&lt;/p&gt;
&lt;p&gt;从CHAR(4)和VARCHAR(4)列检索的值并不总是相同，因为检索时从CHAR列删除了尾部的空格。通过下面的例子说明差别：&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; CREATE TABLE test(a VARCHAR(4), b CHAR(4));&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; INSERT INTO test VALUES (&#39;ab  &#39;, &#39;ab  &#39;);&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; SELECT CONCAT(a, &#39;+&#39;), CONCAT(b, &#39;+&#39;) FROM test;&lt;/p&gt;
&lt;p&gt;结果如下：
&amp;lt;table&amp;gt;
&amp;lt;thead&amp;gt;
&amp;lt;th&amp;gt;CONCAT(a, &#39;+&#39;)&amp;lt;/th&amp;gt;
&amp;lt;th&amp;gt;CONCAT(b, &#39;+&#39;)&amp;lt;/th&amp;gt;
&amp;lt;/thead&amp;gt;
&amp;lt;tbody&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;ab  +&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;ab+&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;&lt;/p&gt;
&lt;p&gt;从上面可以看出来，由于某种原因CHAR有固定长度，所以在处理速度上要比VARCHAR快很多，但是相对浪费存储空间，所以对存储不大，但在速度上有要求的可以使用CHAR类型，反之可以用VARCHAR类型来实现。&lt;/p&gt;
&lt;p&gt;#建议&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;MyISAM存储引擎 建议使用固定长度，数据列代替可变长度的数据列&lt;/li&gt;
&lt;li&gt;INNODB 存储引擎 建议使用VARCHAR类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</content>
  </entry>
  
  <entry>
    <title>TCP字节流和UDP数据报区别</title>
    <link href="https://hoohack.me/blog/2015/2015-01-01-TCP-and-UDP-difference/"/>
    <updated>2015-01-01T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2015/2015-01-01-TCP-and-UDP-difference/</id>
    <content type="html">&lt;p&gt;两者的区别在于TCP接收的是一堆数据，而每次取多少由主机决定;而UDP发的是数据报，客户发送多少就接收多少。&lt;/p&gt;
&lt;p&gt;拥有这些区别的原因是由于TCP和UDP的特性不同而决定的。TCP是面向连接的，也就是说，在连接持续的过程中，socket中收到的数据都是由同一台主机发出的，因此，知道保证数据是有序的到达就行了，至于每次读取多少数据自己看着办。
而UDP是无连接的协议，也就是说，只要知道接收端的IP和端口，且网络是可达的，任何主机都可以向接收端发送数据。这时候，如果一次能读取超过一个报文的数据，则会乱套。比如，主机A向发送了报文P1，主机B发送了报文P2，如果能够读取超过一个报文的数据，那么就会将P1和P2的数据合并在了一起，这样的数据是没有意义的。&lt;/p&gt;
&lt;p&gt;#两个协议的其他区别&lt;/p&gt;
&lt;p&gt;##TCP(Transmission Control Protocol)传输控制协议
TCP是面向连接的、可靠的流协议。流就是指不间断的数据结构。TCP为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。
此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在才会发送数据，从而可以控制通信流量的浪费。&lt;/p&gt;
&lt;p&gt;##UDP (User Datagram Protocol) 用户数据报协议
UDP是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在UDP的情况下，虽然可以确保发送信息的大小，却不能保证信息一定会到达。因此，应用有时会根据自己的需要进行重发处理。
UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。由于UDP面向无连接，它可以随时发送数据。再加上UDP本身的处理既简单又高效，因此经常用于以下方面：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;包总量较少的通信(DNS、SNMP等)&lt;/li&gt;
&lt;li&gt;视频、音频等多媒体通信(即时通信)&lt;/li&gt;
&lt;li&gt;限定于LAN等特定网络中的应用通信&lt;/li&gt;
&lt;li&gt;广播通信(广播、多播)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;##TCP和UDP区分使用
可能有人会认为，鉴于TCP是可靠的传输协议，那么它一定优于UDP。其实不然。TCP和UDP的优缺点无法简单地、绝对地去做比较。那么，对这两种协议应该如何加以区分使用呢？下面做一简单说明。&lt;/p&gt;
&lt;p&gt;TCP用于在传输层有必要实现可靠传输的情况。由于它是面向有连接并具备顺序控制、重发控制等机制的，所以它可以为应用提供可靠传输。&lt;/p&gt;
&lt;p&gt;而在一方面，UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信。举一个IP电话进行通话的例子。如果使用TCP，数据在传送途中如果丢失会被重发，但这样无法流畅地传输通话人的声音，
会导致无法进行正常交流。而采用UDP，它不会进行重发处理。从而也就不会有声音大幅度延迟到达的问题。即使有部分数据丢失，也只是会影响某一小部分的通话。此外，
在多播与广播通信中也使用UDP而不是TCP。
因此，TCI和UDP应该根据应用的目的按需使用。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>回首2014这一年，2015年目标</title>
    <link href="https://hoohack.me/blog/2014/2014-12-30-review-2014-and-2015-goal/"/>
    <updated>2014-12-30T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2014/2014-12-30-review-2014-and-2015-goal/</id>
    <content type="html">&lt;p&gt;许久没有动笔总结自己的学习、生活、工作。趁着这2014年的末尾，总结自己2014这一年的旅程。&lt;/p&gt;
&lt;p&gt;2014年，没有向往年那样做年度计划，因为我知道，这一年，我只需要完成一件事------找一份工作。这一年里，是忙碌的一年。&lt;/p&gt;
&lt;p&gt;#工作
大三的下学期一开始，就开始准备着找暑期实习工作的复习，因为毕竟自己的水平跟别人相比相差甚远，所以只能比别人多付出一些。&lt;/p&gt;
&lt;p&gt;这一个阶段的复习过程并没有十分认真。一切都怪自己的浮躁，总想要得到太多的东西，却没有付出相应的努力。所以最后没有找到好的暑期实习，不能怨天尤人。
中途去过一家小公司做PHP开发，由于在那个公司做的是一个相对来说比较大的项目，自己一个人不敢承担下来，所以只好放弃了那个实习机会。后来经过一些
努力后，找到了份PHP实习工作。里面的工作是&lt;a href=&quot;http://www.ecduo.com/&quot;&gt;多商网站&lt;/a&gt;的维护和&lt;a href=&quot;http://m.ecduo.com/&quot;&gt;手机版&lt;/a&gt;的开发。&lt;/p&gt;
&lt;p&gt;暑期实习的总结&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在公司上班不同于在学校做项目，不能马虎，不管什么错误，只要出错的就是你的错误，要对自己的每一行代码负责，要细心&lt;/li&gt;
&lt;li&gt;工作中的项目，如果一些功能有框架实现了，除非你有把握你的实现方法、性能以及安全性比开源框架高，否则就使用框架&lt;/li&gt;
&lt;li&gt;工作中要了解工作以外的内容，要知道你的代码为公司带来怎样的便利和收益以及其他业务，工作并非仅仅只是敲代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;实习结束后马上开始2015届秋季校招，这次汲取了上次的经验，于是就对着自己想要应聘的职位(WEB开发)去复习。校招找工作的经历比较奇葩，中途还被骗过一次。
经过了一段时间的复习，无奈自己的基础比较薄弱，最后还是没能去到心宜的公司工作，但是也找到一份自己满意的工作。感谢上天给我这个机会，也感谢这家公司的招聘人员给我这个机会。
工作已尘埃落定，不管找得怎么样，也不管别人怎么说。有苦自己知,有泪偷偷流。
有一位工作了几年的前辈跟我说过：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不管你在什么公司工作，工作几年之后，你会感谢当初那些应聘不成功的公司。因为几年之后你在该公司得到的东西未必是你在其他公司能得到的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;#学习
这一年的学习目标是大学以来最清晰的一年。&lt;/p&gt;
&lt;p&gt;大一的时候懵懵懂懂，什么都不知道，也不知道自己的方向是什么。只是在追求奖学金，现在看来，那时也算是在锻炼一种坚持的能力吧。&lt;/p&gt;
&lt;p&gt;大二一年，度过了大一时的懵懂期，也得到了自己想要的东西。开始探索自己喜欢的东西，不断地尝试，不断地失败，不断地在失败中尝试。但是还是没有探索出自己的方向，只是了解到有编程这一门艺术(在我看来，我觉得编程是一种艺术)。&lt;/p&gt;
&lt;p&gt;大三一年，还处于一种迷茫期，还是不知道自己究竟想往哪个方向发展。于是还是在不断的尝试中，但是这一年的尝试比较有目的，在尝试的过程中会去想自己是否喜欢，是否感兴趣。&lt;/p&gt;
&lt;p&gt;大四的上半年，可以说是看到了自己的方向，想从事有关WEB开发的工作。于是不断地学习，学习。学习自己想学的东西。也在这个过程中发现自己越来越喜欢编程了。真的就慢慢的喜欢上它了。也许适合我自己的性格，总是不能无所事事，如果无所事事就会觉得不安。碰巧编程这门艺术需要活到老学到老。&lt;/p&gt;
&lt;p&gt;这一年来从迷茫到现在看到一丝丝希望，也是一个成长的过程吧。一个长辈跟我说过一句话我记忆犹新：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;得不到就顺其自然咯，有努力去争取过就好了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;嗯，顺其自然，是在认真付出了努力的前提下，而不是无所作为地等待。正如佛教里的一句话：&lt;code&gt;因上努力，果上随缘。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;#生活
这一年为了学习和工作熬了不少。导致身体的机能严重受损了，3月份去看了一次病花了近3000大洋。多么痛的领悟。&lt;/p&gt;
&lt;p&gt;明年的目标是要好好对待自己的身体，工作室的部长告诉我说&lt;code&gt;保持足够的睡眠是关键。&lt;/code&gt;不然等你做出你想要的东西你也无法享受了。&lt;/p&gt;
&lt;p&gt;也学会了一种乐器--ukulele。毕竟生活不仅仅是工作和学习。&lt;/p&gt;
&lt;p&gt;这一年收获了不少真情，在工作室的一年时间里是我大学最开心的一年，不仅学习到了很多技术，而且还结交到了一群好友。友谊，是世界上最珍贵的东西之一。自己的感情也比较稳定，继续走下去，感谢一路上有你！&lt;/p&gt;
&lt;p&gt;#博客
开始写博客，也是14年的一大收获。由于自己平时比较多想法，而且喜欢把想法通过文字表达出来，所以喜欢写写自己的生活，记录自己的学习笔记，表达自己的想法。刚开始在一些博客网站上注册帐号，后来打算觉得能自定义的东西太少了，所以想
开一个属于自己的站点。后来发现自己租错了服务器，不能进行自己的配置。到现在，发现github可以作为一个托管服务器，而且可以使用jekyll用markdown写文章然后生成静态网页。觉得这个就是是自己想要的博客站点类型。于是马上使用之。希望能养成一个经常写博客的好习惯。&lt;/p&gt;
&lt;p&gt;#2015目标
2015年，开始进入工作。相比2014年，也许会有更多的挑战和机会，但我仍非常期望下一年的到来。也希望自己自己------不要停止前进，&lt;code&gt;活到老，学到老。&lt;/code&gt;
2014年中做得好的继续保持下去，没有做好的就努力把它做好。没有达到自己期望的则继续努力！&lt;/p&gt;
&lt;p&gt;&amp;quot;放下自己的自尊心，卑微地前行。&amp;quot;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Linux修改环境变量</title>
    <link href="https://hoohack.me/blog/2014/2014-12-29-linux-change-path/"/>
    <updated>2014-12-29T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2014/2014-12-29-linux-change-path/</id>
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;在Linux操作系统中，有时候跟着教程安装了一些软件，安装成功后，很高兴的准备运行该软件相应命令，但是偶尔会遇到&amp;quot;Command not found...&amp;quot;的提示。原因是因为你安装的软件需要设置环境变量才能运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Linux操作系统下修改环境变量有以下三种方法(以设置jekyll的环境变量为例)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、直接赋值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在命令行中输入&lt;/p&gt;
&lt;p&gt;PATH=$PATH:/usr/lib64/ruby/gems/2.1.0/gems/jekyll-2.5.3/bin&lt;/p&gt;
&lt;p&gt;使用这种方法，只对当前会话有效，也就是说每当登出或注销系统后，PATH设置就会失效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、修改/ect/profile文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在文件末尾添加&lt;/p&gt;
&lt;p&gt;export PATH=$PATH:/usr/lib64/ruby/gems/2.1.0/gems/jekyll-2.5.3/bin //注意：&amp;quot;=&amp;quot;号的两边不能有任何空格
这种方法最好，除非你手动强制修改PATH的值，否则将不会被改变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、修改.bachrc/.bash_profile文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在文件末尾添加&lt;/p&gt;
&lt;p&gt;export PATH=$PATH:/usr/lib64/ruby/gems/2.1.0/gems/jekyll-2.5.3/bin&lt;/p&gt;
&lt;p&gt;这种方法是针对当前用户起作用的，当你注销系统后也会失效&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：对于2,3方法，想让PATH生效，必须重新登陆才能实现，以下方法可以简化工作：
如果修改了/etc/profile，那么编辑结束后执行
&lt;code&gt;source profile&lt;/code&gt;
或执行点命令&lt;code&gt;./profile&lt;/code&gt;
PATH的值就会立即生效了。
这个方法的原理就是再执行一次/etc/profile shell脚本，注意如果用sh /etc/profile是不行
的，因为sh是在子shell进程中执行的，即使PATH改变了也不会反应到当前环境中，但是source是
在当前 shell进程中执行的，所以我们能看到PATH的改变。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
  </entry>
  
  <entry>
    <title>读书笔记：高性能网站建设</title>
    <link href="https://hoohack.me/blog/2014/2014-12-28-read-high-performance-web-sites/"/>
    <updated>2014-12-28T00:00:00Z</updated>
    <id>https://hoohack.me/blog/2014/2014-12-28-read-high-performance-web-sites/</id>
    <content type="html">&lt;p&gt;&lt;strong&gt;第一章  减少HTTP请求&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;使用图片地图：当导航栏包含多张图片时，可以将其合并成一张图片，再通过计算位置触发不同的链接&lt;/li&gt;
&lt;li&gt;CSS sprites：将图标合并，引入一张背景图，通过CSS控制其位置&lt;/li&gt;
&lt;li&gt;内联图片：将图片编码后再放到data后面。可用PHP的base64_encode对图片文件进行编码。&lt;/li&gt;
&lt;li&gt;合并脚本和样式文件：理想情况下一个页面一个CSS文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;第二章  使用CDN(Content Delivery Networks)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://zh.wikipedia.org/zh-cn/%E5%85%A7%E5%AE%B9%E5%82%B3%E9%81%9E%E7%B6%B2%E8%B7%AF&quot;&gt;CDN&lt;/a&gt;是指内容分发网络
CDN的做法是指将组建分布到其他服务器上
缺点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;响应时间可能会受到其他网站的影响&lt;/li&gt;
&lt;li&gt;无法直接控制组件服务器所带来的特殊麻烦&lt;/li&gt;
&lt;li&gt;工作度量会随CDN性能下降所影响&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;第三章    为组件添加长的Expires头&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Expires 属性设置页面在失效前被缓存的时间。如果用户在页面失效前返回同一页面，缓存的版本将显示出来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四章  压缩脚本和样式表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过压缩文件从而减少HTTP响应大小来减少响应时间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第五章  将样式表放在顶部&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将样式表放在页面顶部加载可以保证页面基本内容的呈现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第六章  将脚本文件放在底部&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将脚本放在底部加载可以实现页面的逐步呈现和提高下载的并行度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果脚本使用document.write向页面中插入内容，就不能将其移动到页面中靠后的位置。但是如果一个脚本可以延迟加载，那么它一定可以移到页面底部加载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;第七章  避免CSS表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CSS表达式是动态设置CSS属性的强大（但危险）方法。
如使用CSS表达式可以实现隔一个小时切换一次背景颜色：&lt;/p&gt;
&lt;p&gt;background-color: expression((new Date()).getHours()%2?&amp;quot;#FFFFFF&amp;quot;: &amp;quot;#000000&amp;quot; );&lt;/p&gt;
&lt;p&gt;表达式的问题在于对其进行的求值频率比人们期望的高。它们不只在页面呈现和大小改变时求值，当页面滚动、甚至用户鼠标在页面上移过时都要求值。
如果一定要使用CSS表达式，有两种技术可以避免CSS表达式产生这一问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;创建一次性表达式&lt;/li&gt;
&lt;li&gt;使用事件处理器取代CSS表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;第八章  使用外部的Javascript和CSS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你的网站的本质上能够为用户带来高完整缓存率，使用外部文件的收益就更大。如果不大可能产生完整缓存，则内联是更好的选择。
如果你的网站中的每个/很多页面都使用了相同的Javascript和CSS，使用外部文件可以提高这些组件的重用率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第九章  减少DNS查找&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Internet是通过IP地址来查找服务器的。由于IP地址很难记忆，通常使用包含主机名的URL来取代它，但当浏览器发送其请求时，IP地址仍然是必需的。这就是&lt;a href=&quot;http://zh.wikipedia.org/zh/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F&quot;&gt;DNS&lt;/a&gt;(Domain Name System)所处的角色。DNS将主机名映射到IP地址上，就像电话本将人名映射到他们的电话号码一样。当你在浏览器中键入github.com时，连接到浏览器的DNS解析器就会返回服务器的IP地址。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DNS查找可以被缓存起来以提高性能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;第十章  精简JavaScript&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;精简是从代码中移除不必要的字符以减小文件大小，进而改善加载时间的实践。在代码被精简后，所有的注释以及不必要的空白字符(空格、换行和制表符)都将被移除。对于JavaScript而言，这可以改善响应时间效率，因为下载的文件大小减小了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第十一章  避免重定向&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重定向用于将用户从一个URL重新路由到另一个URL。
在重定向完毕并且HTML文档下载完毕之前，没有任何东西显示给用户。
重定向会使你的页面变慢&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给URL的结尾添加斜线&amp;quot;/&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;第十二章  移除重复脚本&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在页面中多次包含相同的脚本会使页面变慢&lt;/li&gt;
&lt;li&gt;在IE中，如果脚本没有被缓存，或在重新加载页面时，会产生额外的HTTP请求&lt;/li&gt;
&lt;li&gt;在Firefox和IE中，脚本会被多次求值&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;第十三章 配置或移除ETag&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实体标签(Entity Tag,&lt;a href=&quot;http://zh.wikipedia.org/zh-cn/HTTP_ETag&quot;&gt;ETag&lt;/a&gt;)，是Web服务器和浏览器用于确认缓存组件的有效性的一种机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第十四章  使Ajax可缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;确保Ajax请求遵守性能指导，尤其应具有长久的Expires头。&lt;/p&gt;
</content>
  </entry>
</feed>